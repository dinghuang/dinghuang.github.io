<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="WSWvVPyzUsUM54ydNcrE1pUzdYt5xGKnqD1i7XpWVF8" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/site.webmanifest">


  <meta name="msapplication-config" content="/images/browserconfig.xml" />



  <meta name="keywords" content="Welcome" />










<meta name="description" content="学习、生活、闲谈、足球">
<meta property="og:type" content="website">
<meta property="og:title" content="一只病猫">
<meta property="og:url" content="https://dinghuang.github.io/index.html">
<meta property="og:site_name" content="一只病猫">
<meta property="og:description" content="学习、生活、闲谈、足球">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一只病猫">
<meta name="twitter:description" content="学习、生活、闲谈、足球">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dinghuang.github.io/"/>





  <title>一只病猫</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-108021384-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?00a1ba3f5c477c92d7c1ccbb00c6427b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一只病猫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">静坐常思己过，闲谈莫论人非</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'HcRPHRrBuwozvgUoLNyX','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2020/09/08/如何画架构设计图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/08/如何画架构设计图/" itemprop="url">如何画架构设计图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-08T15:47:00+08:00">
                2020-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/08/如何画架构设计图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/09/08/如何画架构设计图/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何画架构设计图"><a href="#如何画架构设计图" class="headerlink" title="如何画架构设计图"></a>如何画架构设计图</h1><p>转载于<a href="https://www.zhihu.com/question/27440059/answer/780182558?utm_campaign=shareopn&amp;utm_content=group2_Answer&amp;utm_medium=social&amp;utm_oi=771100730449731584&amp;utm_source=wechat_session&amp;s_r=0" target="_blank" rel="noopener">知乎</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><p>架构就是对系统中的实体以及实体之间的关系所进行的抽象描述，是一系列的决策。</p>
<p>架构是结构和愿景。</p>
<p>系统架构是概念的体现，是对物/信息的功能与形式元素之间的对应情况所做的分配，是对元素之间的关系以及元素同周边环境之间的关系所做的定义。</p>
<p>做好架构是个复杂的任务有了架构之后，就需要让干系人理解、遵循相关决策。</p>
<h3 id="什么是架构图"><a href="#什么是架构图" class="headerlink" title="什么是架构图"></a>什么是架构图</h3><p>系统架构图是为了抽象的表示软件系统的整体轮廓和各个组件之间的相互关系和约束边界，以及软件系统的物理部署和软件系统的演进方向的整体视图。</p>
<h3 id="架构图的作用"><a href="#架构图的作用" class="headerlink" title="架构图的作用"></a>架构图的作用</h3><p>一图胜千言。要让干系人理解、遵循架构决策，就需要把架构信息传递出去。架构图就是一个很好的载体。那么，画架构图是为了：</p>
<ul>
<li>解决沟通障碍</li>
<li>达成共识</li>
<li>减少歧义</li>
</ul>
<h2 id="架构图分类"><a href="#架构图分类" class="headerlink" title="架构图分类"></a>架构图分类</h2><p>搜集了很多资料，分类有很多，有一种比较流行的是4+1视图，分别为场景视图、逻辑视图、物理视图、处理流程视图和开发视图。</p>
<h3 id="场景视图"><a href="#场景视图" class="headerlink" title="场景视图"></a>场景视图</h3><p>场景视图用于描述系统的参与者与功能用例间的关系,反映系统的最终需求和交互设计,通常由用例图表示。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-d85450f5fde7b1b952c375aeb5b08ef9_1440w.jpg" alt="image"></p>
<h3 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h3><p>逻辑视图用于描述系统软件功能拆解后的组件关系,组件约束和边界,反映系统整体组成与系统如何构建的过程,通常由UML的组件图和类图来表示。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-e3e7793037d994f51a70875c976bae8d_1440w.jpg" alt="image"></p>
<h3 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h3><p>物理视图用于描述系统软件到物理硬件的映射关系,反映出系统的组件是如何部署到一组可计算机器节点上,用于指导软件系统的部署实施过程</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-f8aa7bd39f8c1ff151d42abe295eac1e_1440w.jpg" alt="image"></p>
<h3 id="处理流程视图"><a href="#处理流程视图" class="headerlink" title="处理流程视图"></a>处理流程视图</h3><p>处理流程视图用于描述系统软件组件之间的通信时序,数据的输入输出,反映系统的功能流程与数据流程,通常由时序图和流程图表示。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-f75cf601674f20a7b06df2a3cc2fb934_1440w.jpg" alt="image"></p>
<h3 id="开发视图"><a href="#开发视图" class="headerlink" title="开发视图"></a>开发视图</h3><p>开发视图用于描述系统的模块划分和组成,以及细化到内部包的组成设计,服务于开发人员,反映系统开发实施过程。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-594b11d0f1c0b0e2bba824f5d489e403_1440w.jpg" alt="image"></p>
<p>5 种架构视图从不同角度表示一个软件系统的不同特征，组合到一起作为架构蓝图描述系统架构。</p>
<h2 id="好的架构图"><a href="#好的架构图" class="headerlink" title="好的架构图"></a>好的架构图</h2><p>上面的分类是前人的经验总结，图也是从网上摘来的，那么这些图画的好不好呢？是不是我们要依葫芦画瓢去画这样一些图？</p>
<p>先不去管这些图好不好，我们通过对这些图的分类以及作用，思考了一下，总结下来，我们认为，在画出一个好的架构图之前， 首先应该要明确其受众，再想清楚要给他们传递什么信息 ，所以，不要为了画一个物理视图去画物理视图，为了画一个逻辑视图去画逻辑视图，而应该根据受众的不同，传递的信息的不同，用图准确地表达出来，最后的图可能就是在这样一些分类里。那么，画出的图好不好的一个直接标准就是：受众有没有准确接收到想传递的信息。</p>
<p>明确这两点之后，从受众角度来说，一个好的架构图是不需要解释的，它应该是自描述的，并且要具备一致性和足够的准确性，能够与代码相呼应。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>方框代表什么？</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-1542f3d3594594c88b2abad7926f32af_1440w.jpg" alt="image"></p>
<p>为什么适用方框而不是圆形，它有什么特殊的含义吗？随意使用方框或者其它形状可能会引起混淆。</p>
<ul>
<li>虚线、实线什么意思？箭头什么意思？颜色什么意思？</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-f793c4721c9101087656c109c315585c_1440w.jpg" alt="image"></p>
<p>随意使用线条或者箭头可能会引起误会。</p>
<ul>
<li>运行时与编译时冲突？层级冲突？</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-f793c4721c9101087656c109c315585c_1440w.jpg" alt="image"></p>
<p>架构是一项复杂的工作，只使用单个图表来表示架构很容易造成莫名其妙的语义混乱。</p>
<h2 id="如何更好的表达软件架构"><a href="#如何更好的表达软件架构" class="headerlink" title="如何更好的表达软件架构"></a>如何更好的表达软件架构</h2><h3 id="C4"><a href="#C4" class="headerlink" title="C4"></a>C4</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-8576e8884006dfb5e2e88fa4405ae0f9_1440w.jpg" alt="image"></p>
<p>C4 模型使用容器（应用程序、数据存储、微服务等）、组件和代码来描述一个软件系统的静态结构。这几种图比较容易画，也给出了画图要点，但最关键的是，我们认为，它明确指出了每种图可能的受众以及意义。</p>
<p>下面的案例来自C4官网，然后加上了一些我们的理解。</p>
<h3 id="语境图-System-Context-Diagram"><a href="#语境图-System-Context-Diagram" class="headerlink" title="语境图(System Context Diagram)"></a>语境图(System Context Diagram)</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-cf751ecece5c86fef705d44e422f088b_1440w.jpg" alt="image"></p>
<p>这是一个想象的待建设的互联网银行系统，它使用外部的大型机银行系统存取客户账户、交易信息，通过外部电邮系统给客户发邮件。可以看到，非常简单、清晰，相信不需要解释，都看的明白，里面包含了需要建设的系统本身，系统的客户，和这个系统有交互的周边系统。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>这样一个简单的图，可以告诉我们，要构建的系统是什么；它的用户是谁，谁会用它，它要如何融入已有的IT环境。这个图的受众可以是开发团队的内部人员、外部的技术或非技术人员。即：</p>
<ul>
<li>构建的系统是什么</li>
<li>谁会用它</li>
<li>如何融入已有的IT环境</li>
</ul>
<h4 id="怎么画"><a href="#怎么画" class="headerlink" title="怎么画"></a>怎么画</h4><p>中间是自己的系统，周围是用户和其它与之相互作用的系统。这个图的关键就是梳理清楚待建设系统的用户和高层次的依赖，梳理清楚了画下来只需要几分钟时间。</p>
<h3 id="容器图-Container-Diagram"><a href="#容器图-Container-Diagram" class="headerlink" title="容器图(Container Diagram)"></a>容器图(Container Diagram)</h3><p>容器图是把语境图里待建设的系统做了一个展开。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-542d65da584b32dbfe6e63d208484670_1440w.jpg" alt="image"></p>
<p>上图中，除了用户和外围系统，要建设的系统包括一个基于java\spring mvc的web应用提供系统的功能入口，基于xamarin架构的手机app提供手机端的功能入口，一个基于java的api应用提供服务，一个mysql数据库用于存储，各个应用之间的交互都在箭头线上写明了。</p>
<p>看这张图的时候，不会去关注到图中是直角方框还是圆角方框，不会关注是实线箭头还是虚线箭头，甚至箭头的指向也没有引起太多注意。</p>
<p>我们有许多的画图方式，都对框、线的含义做了定义，这就需要画图的人和看图的人都清晰的理解这些定义，才能读全图里的信息，而现实是，这往往是非常高的一个要求，所以，很多图只能看个大概的含义。</p>
<h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>这个图的受众可以是团队内部或外部的开发人员，也可以是运维人员。用途可以罗列为：</p>
<ul>
<li>展现了软件系统的整体形态</li>
<li>体现了高层次的技术决策</li>
<li>系统中的职责是如何分布的，容器间的是如何交互的</li>
<li>告诉开发者在哪里写代码</li>
</ul>
<h4 id="怎么画-1"><a href="#怎么画-1" class="headerlink" title="怎么画"></a>怎么画</h4><p>用一个框图来表示，内部可能包括名称、技术选择、职责，以及这些框图之间的交互，如果涉及外部系统，最好明确边界</p>
<h3 id="组件图-Component-Diagram"><a href="#组件图-Component-Diagram" class="headerlink" title="组件图(Component Diagram)"></a>组件图(Component Diagram)</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-b320fa5f7733cb8e7b9f45a910aadb3f_1440w.jpg" alt="image"></p>
<p>组件图是把某个容器进行展开，描述其内部的模块。</p>
<h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><p>这个图主要是给内部开发人员看的，怎么去做代码的组织和构建。其用途有</p>
<ul>
<li>描述了系统由哪些组件/服务组成</li>
<li>厘清了组件之间的关系和依赖</li>
<li>为软件开发如何分解交付提供了框架</li>
</ul>
<h3 id="类图-Code-Class-Diagram"><a href="#类图-Code-Class-Diagram" class="headerlink" title="类图(Code/Class Diagram)"></a>类图(Code/Class Diagram)</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-bbfef0211b32a11ee209140f964ae233_1440w.jpg" alt="image"></p>
<h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><h3 id="本地协作"><a href="#本地协作" class="headerlink" title="本地协作"></a>本地协作</h3><h4 id="Mac-OmniGraffle"><a href="#Mac-OmniGraffle" class="headerlink" title="Mac:OmniGraffle"></a>Mac:OmniGraffle</h4><p>OmniGraffle 是由 The Omni Group 制作的一款绘图软件，它曾获得苹果设计奖。OmniGraffle 可以支持流程图、逻辑图或者网页产品模型设计等，功能非常强大。与 Graffle 对应的是在Windows平台广泛应用的 MS Visio（ Graffle 这个词据说就是为了和Visio区分而硬造出来的）</p>
<h4 id="Windows-Visio"><a href="#Windows-Visio" class="headerlink" title="Windows:Visio"></a>Windows:Visio</h4><p>Office Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。<br>Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。</p>
<h3 id="在线协作"><a href="#在线协作" class="headerlink" title="在线协作"></a>在线协作</h3><h4 id="Process-On"><a href="#Process-On" class="headerlink" title="Process On"></a>Process On</h4><p>是一款用HTML5、Canvas以及JavaScript技术开发而成的在线网页版作图工具。只需在工具栏拖放对应的图形到画布中,就可进行编辑，还支持流程图、思维导图、原型、拓扑图等，最让人心动的就是有实时协助的功能，从此再也不需要和同学、老师、领导之间来回传送文件，直接邀请，一起协作完成。</p>
<h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>下面是 城市运营态势 工具的一个架构图。作为一个应该自描述的架构图，这里不多做解释了。如果有看不明白的，那肯定是还画的不够好。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-a6bc2de3271462f663b3d0203ba42050_1440w.jpg" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2020/07/06/ELK日志管理系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/ELK日志管理系统/" itemprop="url">ELK日志管理系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-06T18:33:00+08:00">
                2020-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/06/ELK日志管理系统/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/07/06/ELK日志管理系统/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官方文档:<a href="https://www.elastic.co/guide/en/elastic-stack/current/overview.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elastic-stack/current/overview.html</a></p>
<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>本教程基于Elasticsearch版本7.7.0</p>
<p>要在docker中搭建，要起3个套件</p>
<p>其中elasticearch会遇到docker内存问题，可以看这个解决<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html</a></p>
<p>或者<br>macOS with Docker for Mac</p>
<p>The vm.max_map_count setting must be set within the xhyve virtual machine:</p>
<p>From the command line, run:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen ~<span class="regexp">/Library/</span>Containers<span class="regexp">/com.docker.docker/</span>Data<span class="regexp">/vms/</span><span class="number">0</span><span class="regexp">/tty</span></span><br></pre></td></tr></table></figure>
<p>Press enter and use<code>sysctl</code> to configure vm.max_map_count:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.<span class="attribute">max_map_count</span>=262144</span><br></pre></td></tr></table></figure></p>
<p>To exit the screen session, type Ctrl a d.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create elasticsearch</span><br><span class="line">docker pull docker<span class="selector-class">.elastic</span><span class="selector-class">.co</span>/elasticsearch/elasticsearch:<span class="number">7.7</span>.<span class="number">0</span></span><br><span class="line">docker run -d -<span class="selector-tag">p</span> <span class="number">9200</span>:<span class="number">9200</span> -<span class="selector-tag">p</span> <span class="number">9300</span>:<span class="number">9300</span> --network elasticsearch -e <span class="string">"discovery.type=single-node"</span> --name elasticsearch docker<span class="selector-class">.elastic</span><span class="selector-class">.co</span>/elasticsearch/elasticsearch:<span class="number">7.7</span>.<span class="number">0</span></span><br><span class="line">docker pull docker<span class="selector-class">.elastic</span><span class="selector-class">.co</span>/kibana/kibana:<span class="number">7.7</span>.<span class="number">0</span></span><br><span class="line">docker run -d --link elasticsearch:elasticsearch --name kibana -<span class="selector-tag">p</span> <span class="number">5601</span>:<span class="number">5601</span> --network elasticsearch docker<span class="selector-class">.elastic</span><span class="selector-class">.co</span>/kibana/kibana:<span class="number">7.7</span>.<span class="number">0</span></span><br><span class="line">docker pull docker<span class="selector-class">.elastic</span><span class="selector-class">.co</span>/logstash/logstash:<span class="number">7.7</span>.<span class="number">0</span></span><br><span class="line">docker run -d -<span class="selector-tag">p</span> <span class="number">5044</span>:<span class="number">5044</span>  --network elasticsearch --link elasticsearch:elasticsearch --name logstash docker<span class="selector-class">.elastic</span><span class="selector-class">.co</span>/logstash/logstash:<span class="number">7.7</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>遇到错误<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Security must be explicitly enabled when <span class="keyword">using</span> <span class="keyword">a</span> [basic] license. Enable security <span class="keyword">by</span> setting [xpack.security.enabled] <span class="built_in">to</span> [<span class="literal">true</span>] <span class="keyword">in</span> <span class="keyword">the</span> elasticsearch.yml <span class="built_in">file</span> <span class="keyword">and</span> restart <span class="keyword">the</span> node.</span><br></pre></td></tr></table></figure></p>
<p>编辑elasticsearch.yml，加入<code>xpack.security.enabled:true</code>,然后重启节点<br>重启时遇到错误:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [<span class="number">1</span>] bootstrap checks failed</span><br><span class="line"> [<span class="number">1</span>]: Transport SSL must be enabled <span class="keyword">if</span> security <span class="keyword">is</span> enabled <span class="keyword">on</span> a [basic] license. Please <span class="keyword">set</span> [xpack.security.transport.ssl.enabled] <span class="keyword">to</span> [<span class="literal">true</span>] <span class="keyword">or</span> disable security <span class="keyword">by</span> setting [xpack.security.enabled] <span class="keyword">to</span> [<span class="literal">false</span>]</span><br></pre></td></tr></table></figure></p>
<p>编辑elasticsearch.yml，加入<code>xpack.security.transport.ssl.enabled:true</code>,然后重启节点</p>
<p>执行设置用户名和密码的命令,这里需要为4个用户分别设置密码，<code>elastic, kibana, logstash_system,beats_system</code></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch-<span class="built_in">setup</span>-passwords interactive</span><br></pre></td></tr></table></figure>
<h1 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h1><p>进入logstash容器里面修改配置文件<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it <span class="number">54</span>b504186a47 <span class="regexp">/bin/</span>bash <span class="comment"># 这里 54b504186a47是容器id</span></span><br><span class="line">vi <span class="regexp">/usr/</span>share<span class="regexp">/logstash/</span>config<span class="regexp">/logstash.yml</span></span><br></pre></td></tr></table></figure></p>
<p>logstash.yml配置文件如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http<span class="selector-class">.host</span>: <span class="string">"0.0.0.0"</span></span><br><span class="line">xpack<span class="selector-class">.monitoring</span><span class="selector-class">.elasticsearch</span><span class="selector-class">.hosts</span>: [ <span class="string">"http://elasticsearch:9200"</span> ]</span><br><span class="line">path<span class="selector-class">.config</span>: /usr/share/logstash/config<span class="comment">/*.conf</span></span><br><span class="line"><span class="comment">path.logs: /var/log/logstash</span></span><br></pre></td></tr></table></figure></p>
<p>修改logstash-sample.conf<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    <span class="attr">mode</span> =&gt; <span class="string">"server"</span></span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">"0.0.0.0"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; json_lines</span><br><span class="line">    <span class="attr">port</span> =&gt; <span class="number">5044</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">"http://elasticsearch:9200"</span>]</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">"springboot-logstash-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">    <span class="comment">#user =&gt; "elastic"</span></span><br><span class="line">    <span class="comment">#password =&gt; "changeme"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样logstash的读取就是通过一个tcp服务读取</p>
<h1 id="springboot结合"><a href="#springboot结合" class="headerlink" title="springboot结合"></a>springboot结合</h1><p>引入包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>添加配置文件<code>logback-spring.xml</code><br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/base.xml"</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"LOGSTASH"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>127.0.0.1:5044<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 日志输出编码 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span></span></span></span><br><span class="line"><span class="xml">                 class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">timeZone</span>&gt;</span>UTC<span class="tag">&lt;/<span class="name">timeZone</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">                        "logLevel": "%level",</span></span><br><span class="line"><span class="template-variable">                        "serviceName": "$&#123;springAppName:-&#125;</span><span class="xml">",</span></span><br><span class="line"><span class="xml">                        "pid": "$</span><span class="template-variable">&#123;PID:-&#125;</span><span class="xml">",</span></span><br><span class="line"><span class="xml">                        "thread": "%thread",</span></span><br><span class="line"><span class="xml">                        "class": "%logger</span><span class="template-variable">&#123;40&#125;</span><span class="xml">",</span></span><br><span class="line"><span class="xml">                        "rest": "%message"</span></span><br><span class="line"><span class="xml">                        &#125;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"LOGSTASH"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>启动应用，配置kibana的索引，如图所示<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG469.png" alt="image"></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG470.png" alt="image"></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG471.png" alt="image"></p>
<p>如果添加了索引，页面没有显示索引，还要继续添加的话，这个是Kibana的问题，重启一下Kibana容器就好了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2020/06/23/业务埋点设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/23/业务埋点设计/" itemprop="url">业务埋点设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-23T18:33:00+08:00">
                2020-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序设计/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/23/业务埋点设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/06/23/业务埋点设计/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>可以先看一本书《精通Web Analytics 2.0》</p>
<h2 id="埋点是什么"><a href="#埋点是什么" class="headerlink" title="埋点是什么"></a>埋点是什么</h2><p>所谓埋点就是在应用中特定的流程收集一些信息，用来跟踪应用使用的状况，后续用来进一步优化产品或是提供运营的数据支撑，包括访问数（Visits），访客数（Visitor），停留时长（Time On Site），页面浏览数（Page Views）和跳出率（Bounce Rate）。这样的信息收集可以大致分为两种：页面统计（track this virtual page view），统计操作行为（track this button by an event）。</p>
<h2 id="埋点是谁的工作"><a href="#埋点是谁的工作" class="headerlink" title="埋点是谁的工作"></a>埋点是谁的工作</h2><p>现在公司通常都会有数据产品经理或业务线数据分析师，结合版本迭代过程进行埋点规划。如果是代码埋点，还需要开发完成相应的埋点代码。</p>
<h2 id="埋点的意义"><a href="#埋点的意义" class="headerlink" title="埋点的意义"></a>埋点的意义</h2><p>埋点就是为了对产品进行持续追踪，通过深度数据分析不断优化产品。好比去医院体检，医生测了你身体的各个健康指标，以此来判断你的健康状况。埋点的目的，其实就是随时或者定期监测你的产品的“健康”状况。</p>
<p>任何一个系统在设计初始阶段只关心核心业务的功能，等到系统上线以后，数据分析师对用户行为分析时会发现缺少很多数据，此时需要采用埋点的方法进行采集需要的数据。</p>
<p>业务人员主要通过自有或第三方的数据统计平台了解产品的概览性数据指标，包括新增用户数、活跃用户数等。这些指标能帮助企业宏观的了解用户访问的整体情况和趋势，从整体上把握产品的运营状况，但很难基于这些指标直接得到切实的产品改进策略。</p>
<p>而埋点将产品数据分析的深度下钻到流量分布和流动层面，通过对产品中的用户交互行为的统计分析，对宏观指标进行深入剖析，发现指标背后的问题，寻找人群的行为特点和关系，洞察用户行为与提升业务价值之间的潜在关联，了解组成特定数据现象的原因，并据此构建产品优化 迭代 和运营策略。</p>
<p>对于产品来说，用户在你的产品里做了什么、停留了多久、有什么异样，都是需要关注的。比如用户点击率怎么样？用户在核心使用路径上是否顺畅？有没有得到用户的认可？有没有因为设计按钮过多导致用户行为无效？用户希望有什么样的功能更新等等问题都可以通过埋点的方法实现。</p>
<p>埋点做好才能用来进行数据驱动产品和精细化运营。而埋点质量的好坏也直接影响到了产品运营的质量。因此它贯穿了产品的整个生命周期，为产品优化指明了方向。所以说，好的数据埋点，就成功了一半。</p>
<h2 id="when-amp-amp-where"><a href="#when-amp-amp-where" class="headerlink" title="when &amp;&amp; where"></a>when &amp;&amp; where</h2><p>埋点是目的导向。</p>
<p>在产品规划时就要思考数据埋点问题，如果在产品外发后再考虑怎么埋点，就会导致前期版本用户的数据无法收集，想要看某个数据时就会非常无奈，只有等到新版本完善来弥补。</p>
<p>思考要埋哪些点、埋点的形式，需要紧密结合产品迭代的方向、运营需求，并和数据开发等进行充分沟通以确认：</p>
<ul>
<li>埋点能够得到想要的数据解决/支持；</li>
<li>能够得到当前版本的复盘情况；</li>
<li>后续版本的数据支撑。</li>
</ul>
<p>通常的沟通过程以 埋点文档为载体；数据埋点评审为终结。</p>
<h3 id="当前版本的复盘情况："><a href="#当前版本的复盘情况：" class="headerlink" title="当前版本的复盘情况："></a>当前版本的复盘情况：</h3><ul>
<li>新版本功能使用情况，是否符合预期；</li>
<li>新功能上线后对其他功能点的影响？是否为整体均有积极作用；</li>
<li>版本运营活动目标群体的特征获取;</li>
<li>新增商业化目标的监测……</li>
</ul>
<h3 id="后续版本的数据支撑："><a href="#后续版本的数据支撑：" class="headerlink" title="后续版本的数据支撑："></a>后续版本的数据支撑：</h3><ul>
<li>规划方向的用户行为分析</li>
<li>画像特征分析</li>
</ul>
<h1 id="埋点指标："><a href="#埋点指标：" class="headerlink" title="埋点指标："></a>埋点指标：</h1><h2 id="基础指标"><a href="#基础指标" class="headerlink" title="基础指标"></a>基础指标</h2><p>基础指标是一些常用的参数指标，比如用户行为相关的，有用户数、新增用户数、活跃用户数等；用户设备相关的，比如电脑系统、地区、语言、国家、产品版本等；用户属性相关的，性别、年龄等。这一部分一般很难通过埋点拿到，但是通过一般第三方工具可以看个大概。</p>
<h2 id="用户行为数据指标"><a href="#用户行为数据指标" class="headerlink" title="用户行为数据指标"></a>用户行为数据指标</h2><p>用户行为的行为数据，就是埋点的核心了。这一部分根据不同的产品，收集的数据也不同。再拿PC端的腾讯视频举例，每个用户每天使用腾讯视频的时长是多少？每次看的是哪些视频？用户最喜欢看哪个频道的视频？每个频道的使用情况是怎么样的？用户一般是在一天中的哪个时间段打开腾讯视频的。想要看的数据非常多，而这些，都是要提前规划好，有目的性得去决定要埋什么点、怎么埋。如果你的目的是为了研究一下用户对弹幕的接受程度，那围绕弹幕，设置一些指标数据，比如发布弹幕的次数和频率？看视频时是否开启了弹幕？这样的话，就能够通过数据，看出用户对弹幕的真实反映，对于提升产品功能和运营都有很大帮助。</p>
<h2 id="核心质量指标"><a href="#核心质量指标" class="headerlink" title="核心质量指标"></a>核心质量指标</h2><p>Crash等一些因为产品质量引起的问题，都是用户所不能忍受的。而且用户量越大，越容易出现产品质量问题。尤其是一些产品，他的产品属性决定了，产品质量是吸引用户购买的一个很重要的因素。比如迅雷、photoshop等软件，核心质量的指标能帮助我们监控产品的“健康”情况。</p>
<p>这里说的质量指标，不单单指产品的 异常退出率、Crash率， 还包括和产品自身业务相关的指标。比如，对于视频编辑产品， 编辑成功率 是很重要的指标；对于迅雷， 下载成功率 是核心指标；对于在线类产品， 资源解析 成功率 是核心指标……</p>
<h2 id="访问与访客"><a href="#访问与访客" class="headerlink" title="访问与访客"></a>访问与访客</h2><p>访问次数（Visits）与访问人数（Vistors）是几乎所有应用都需要统计的指标，这也是最基础的指标。对于应用的统计来说，经常看到的DAU（日活跃用户数量），MAU（用户数量统计），UV（独立（IP）访客）等指标都是指统计访客（Vistors）。访问（Visits）是指会话层，用户打开应用花一段时间浏览又离开，从指标定义（访问次数）来说这被称之为统计会话（Session）数。一次会话（Session 或 Visit）是打开应用的第一个请求（打开应用）和最后一个请求决定的。如果用户打开应用然后放下手机或是离开电脑，并在接下来30分钟内没有任何动作，此次会话自动结束，通常也算作一次访问或会话期（30分钟是早起网页版应用约定俗成的会话数定义，目前用户停留在应用的时长变长，30分钟的限定也可能随之不同，总之是能代表一次用户访问的时长）。在计算访问人数（Vistors）时，埋点上报的数据是尽可能接近真实访客的人数。对于有需要统计独立访客这个指标的场景，这里还是需要强调一下，访问人数（Vistors）并不是真实独立的人，因此收集数据时必须知道访问人数虽然能够很好的反映使用应用的真实访问者的数量，但不等于使用应用的真实人数。（原因是，重复安装的应用，或是手机参数被修改都会使得独立访客的指标收到影响。计算访问人数的埋点都是依赖Cookie，用户打开应用，应用都会在此人的终端创建一个独立Cookie, Cookie会被保留，但还是难免会被用户手动清理或是Cookie被禁用导致同一用户使用应用Cookie不一致，所以独立访客只能高度接近于使用应用的真实人数。）</p>
<h2 id="停留时长"><a href="#停留时长" class="headerlink" title="停留时长"></a>停留时长</h2><p>停留时长用来衡量用户在应用的某一个页面或是一次访问（会话）所停留的时间。页面停留时长，表示在每个页面所花费的时间；例如：首页就是进入首页（10：00）到离开首页进入下一个页面(10:01)的时长，首页停留时长计算为1分钟。页面A是2分钟。停留时长的数据并不都是一定采集得到的，比如页面B进入时间（10：03），离开出现异常或是退出时间没有记录，这时候计算就是0 （所以指标计算时需要了解埋点的状况，剔除这样的无效数据）。应用的停留时长，表示一次访问（会话）所停留的时间，计算起来就是所有页面的访问时长，同样是上一个流程，应用的停留时长就是4分钟。</p>
<h2 id="跳出率"><a href="#跳出率" class="headerlink" title="跳出率"></a>跳出率</h2><p>跳出率的计算方法现在在各个公司还是很多种，最经常被使用的是：用户只访问了一个页面所占的会话比例（原因是：假设这种场景，用户来了访问了一个页面就离开了，想想用户使用的心里画面应该是：打开应用，心想什么鬼，然后关闭应用甚至卸载了。这个场景多可怕，这也是为什么跳出率指标被如此关注）跳出率可以分解到两个层次：一是整个应用的跳出率，二是重点的着陆页的跳出率，甚至是搜索关键词的跳出率。跳出率的指标可操作性非常强，通过统计跳出率可以直接发现页面的问题发现关键词的问题。</p>
<h2 id="退出率"><a href="#退出率" class="headerlink" title="退出率"></a>退出率</h2><p>退出率是针对页面的，这个指标的目标很简单，就是在针对某个页面有多少用户离开了应用，主要用户反映用户从应用离开的情况。哪些页面需要被改进最快的方式被发掘。（注意：退出率高不一定是坏事。例如：预测流程的最终节点的退出率就应该是高的）</p>
<h2 id="转化率"><a href="#转化率" class="headerlink" title="转化率"></a>转化率</h2><p>我们在产品上投入这么多，不就是为了衡量产出么？所以对于电商类应用，还有比转化率更值得关注的指标吗？转化率的计算方法是某种产出除以独立访客或是访问量，对于电商产品来说，就是提交订单用户数除以独立访客。转化率的计算看起来想到那简单，但却是埋点中最贴近业务的数据收集。这也是最体现埋点技巧的指标，需要结合业务特点制定计算方法。提交订单量/访客数是最基本的转化率，转化率还可以分层次，指定用户路径的，如：完成某条路径的提交订单数/访客数。</p>
<h2 id="参与度"><a href="#参与度" class="headerlink" title="参与度"></a>参与度</h2><p>参与度并不是一个指标，而是一系列的指标的统称，例如访问深度，访问频次，针对电商的下单次数，针对内容服务商的播放次数，及用户行为序列这些都可以是衡量参与度的指标。之所以把参与度列为一个指标，是希望大家明白把指标结合业务，产生化学反应，活学活用去发现事物的本质。</p>
<h1 id="数据采集普遍遇到的几个问题"><a href="#数据采集普遍遇到的几个问题" class="headerlink" title="数据采集普遍遇到的几个问题"></a>数据采集普遍遇到的几个问题</h1><ul>
<li>实时性，对于工具性产品在无网条件下的数据，无法实时上报；</li>
<li>完整性，由于用户隐私协议&amp;欧盟通用数据保护条例的，部分数据无法采集；</li>
<li>异常，android_id、idfa、idfv 随版本升级变化或无法获取。</li>
</ul>
<h1 id="怎么埋点"><a href="#怎么埋点" class="headerlink" title="怎么埋点"></a>怎么埋点</h1><h2 id="代码埋点"><a href="#代码埋点" class="headerlink" title="代码埋点"></a>代码埋点</h2><p>以为需要监测网站上/app上用户的行为，是需要在网页/app中加上一些代码的，当用户触发相应行为时，进行数据上报，也就是代码埋点。这样的代码，在网站上叫监测代码，在app中叫SDK（Software Development Kit）。市场上的第三方数据采集均支持代码埋点，GA, GrowingIO，神策等。</p>
<ul>
<li>优点<ul>
<li>采集的数据比较具有针对性，更加适合精细化数据分析。</li>
<li>同时也能提高数据的准确性。</li>
</ul>
</li>
<li>缺点<ul>
<li>每一个控件的埋点都需要添加相应的代码，不仅工作量大，而且限定了必须是技术开发人员才能完成。</li>
<li>每一次产品迭代，都需要更新埋点方案。</li>
</ul>
</li>
<li>适用场景<ul>
<li>有具体的业务分析需求，且按照各个事件埋点的方式不能满足。</li>
<li>需要对埋点事件进行传参等自定义属性设置。代码埋点虽然较复杂，但功能最完善，覆盖了埋点中的不同业务需求。</li>
</ul>
</li>
</ul>
<h2 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h2><p>利用可视化交互手段，数据产品/数据分析师可以通过可视化界面（管理后台连接设备） 配置事件，如下是腾讯移动分析的可视化埋点界面。可视化埋点仍需要先配置相关事件，再采集。</p>
<p>例如腾讯的<a href="https://mta.qq.com/" target="_blank" rel="noopener">https://mta.qq.com/</a><br><img src="https://mta.qq.com/v3/docs/assets/autotrack05.png" alt="image"></p>
<p>蚂蚁金服的移动开发平台<br><a href="https://tech.antfin.com/docs/2/49549" target="_blank" rel="noopener">https://tech.antfin.com/docs/2/49549</a></p>
<ul>
<li>优点<ul>
<li>业务人员可用，无需技术人员进行SDK嵌入，不懂代码的产品运营人员也可通过后台可视化界面配置和统计埋点并实时下发到客户端生效。</li>
<li>无需版本更新，由于不需要嵌入新SDK，不需要发布新版本，可谓即时生效。</li>
<li>对所有版本生效：新增埋点在所有版本生效，不存在迭代问题。</li>
</ul>
</li>
<li>缺点<ul>
<li>可覆盖的功能有限，目前并不是所有控件操作都可以通过这种方案进行定制。</li>
<li>不能自定义交互事件属性，由于获取的是交互事件元素的DOMpath，无法对具体事件设置参数。</li>
<li>不支持可以不断加载的内容瀑布流交互。</li>
</ul>
</li>
<li>适用场景<ul>
<li>分析或统计需求简单，不需要对埋点事件进行传参等自定义属性设置。</li>
<li>频繁上线或更新的H5类型的运营活动</li>
</ul>
</li>
</ul>
<h2 id="无埋点"><a href="#无埋点" class="headerlink" title="无埋点"></a>无埋点</h2><p>无埋点是指开发人员集成采集 SDK 后，SDK 便直接开始捕捉和监测用户在应用里的所有行为，并全部上报，不需要开发人员添加额外代码。</p>
<p>数据分析师/数据产品 通过管理后台的圈选功能来选出自己关注的用户行为，并给出事件命名。之后就可以结合时间属性、用户属性、事件进行分析了。所以无埋点并不是真的不用埋点了。目前市场第三方工具GrowingIO支持无埋点全量行为数据抓取<a href="https://growingio.jinshuju.com/" target="_blank" rel="noopener">https://growingio.jinshuju.com/</a></p>
<ul>
<li>优点<ul>
<li>因为无埋点对页面所有元素进行埋点，那么这个页面每个元素被点击的概率你也就知道，对点击概率比较大的元素可以进行深入分析。</li>
<li>可以在系统上线后使用，支持基于全量的数据回溯，因为无埋点在你部署SDK的时候数据就一直在收集，可帮助进行启发式、探索式的数据分析。</li>
<li>它技术门槛低，部署简单。</li>
</ul>
</li>
<li>缺点<ul>
<li>无埋点无法采集自定义属性，只使用通用大部门，通用的场景。</li>
<li>数据形式非业务导向，因为是对所有事件数据的自动收集，没有按照业务需求进行事件或区域设置，业务或数据人员在使用时或许不能直接使用，需要二次计算或处理。</li>
<li>兼容性不好，传输时效性较差等问题，因为是对所有的元素数据都收集，会给数据传输和服务器带来较大的压力。</li>
</ul>
</li>
<li>适用场景<ul>
<li>分析或统计需求简单，不需要对埋点事件进行传参等自定义属性设置的事件。</li>
<li>针对快速、频繁上线和迭代的H5类型的运营活动的评估。</li>
</ul>
</li>
</ul>
<p>总体来说，无埋点和可视化埋点更侧重结果的展现，对过程追溯少，更适合产品经理分析基础的产品功能流畅度、用户体验、产品路径设置等。代码埋点和后端埋点，不仅能展现结果，也会记录用户行为过程，支持深度的行为分析和偏好洞察，还可将行为数据与业务数据打通，适合产品和运营人员深度使用。</p>
<p>无论采用哪种埋点方式，都应该根据业务场景和产品阶段，梳理和构建数据分析体系。埋点规划混乱、数据采集无序、数据分析断层，最终将会让企业陷入“有数据而无价值”的境地。</p>
<h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><p><img src="http://qiniu.zlt2000.cn/FncpOSYb_pvFPf0kr9H7tU4ktdvq" alt="image"></p>
<p>通过 日志埋点 来实现业务监控和行为分析主要需要以下4个步骤</p>
<p>数据生成(埋点)<br>数据收集<br>数据解析(结构化)<br>数据落盘<br>数据使用(展示/分析)</p>
<h2 id="数据使用"><a href="#数据使用" class="headerlink" title="数据使用"></a>数据使用</h2><p><img src="http://qiniu.zlt2000.cn/FgAqw5FNDtsLfwUdNnlxShiJ64hk" alt="image"></p>
<h1 id="如何做数据埋点"><a href="#如何做数据埋点" class="headerlink" title="如何做数据埋点"></a>如何做数据埋点</h1><p>其实这个问题不应该问别人，应该问你自己，通过上文，我们已经知道了，如果你想绘制基础的人群画像你就需要获取用户机型、网络类型、操作系统，IP地域等数据；如果你想分析每一个注册转化率，你就需要获取每一个步骤的点击次数，然后制作成漏斗，看那一步转化率出现了问题……目的不一样，获取的数据也不一样，使用的埋点技术也不一样。<br><img src="https://img.shangyexinzhi.com/xztest-image/article/417f5f73ed680cfbab173acbf316212c.jpeg" alt="image"></p>
<p>那么，我们该如何选择埋点方式呢？</p>
<p>我们的目的是实现深度数据分析，不应该采用与其他企业通用的埋点方法，应该采用适合自己的埋点方法。也就是做到“因系统而异、避免千系统一面的情况。</p>
<p>在系统刚上线的初期阶段，我们可以采用无埋点的方式。因为我们通过UV、PV、点击率等基本指标及即可满足数据分析需求。如果产品上线时间很长，我们需要进行深度数据分析则选择代码埋点。它可以帮我们收集需要的属性。另外，如何埋点既可以在前端实现，也可以在后端实现，我们推荐在后端实现。因为后端数据可以保证数据的准确性。最后，如果您为了方便快捷并且免费，可以选择第三方统计工具，但是一定要选择适合自己业务的统计工具。</p>
<p>从业务过程中采集埋点，是数据驱动型公司的必要条件。一般公司的产品功能评审环节，不仅有 PRD (Product requirement document），还加入了对应的 DRD ( Data requirement document）。对于埋点而言，DRD 需要明确业务目标与埋点缺口之间的关系以及需求的优先级。埋点的需求大多来自于 DRD，整个过程会涉及多个角色，主要包括产品经理、业务数据负责人、开发工程师、测试工程师，如图所示。</p>
<p><img src="https://img.36krcdn.com/20200409/v2_d43dfb858dae4481bcefe8567e2b55fe_img_000" alt="image"></p>
<p>总之，如果您需要深度分析，选择后端（手动）埋点和无埋点组合的方案；如果您只是想看宏观数据，可以选择无埋点。无论采用哪种埋点方法，一定要慎重，根据需要来设置，最好不要出现错埋或者漏埋的情况。最后，数据分析师一定要和业务工程团队（部署实施埋点的部门）配合好才能实现完美的数据采集方案，有时候沟通比选择埋点方式更重。</p>
<h1 id="优秀的实践案例"><a href="#优秀的实践案例" class="headerlink" title="优秀的实践案例"></a>优秀的实践案例</h1><p>有赞埋点实践<a href="https://tech.youzan.com/track-1/" target="_blank" rel="noopener">https://tech.youzan.com/track-1/</a></p>
<p>美团点评前端无痕埋点实践<a href="https://tech.meituan.com/2017/03/02/mt-mobile-analytics-practice.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/03/02/mt-mobile-analytics-practice.html</a></p>
<p>产品经理该如何做好数据埋点<a href="https://www.uisdc.com/product-manager-makes-data-event-tracking" target="_blank" rel="noopener">https://www.uisdc.com/product-manager-makes-data-event-tracking</a></p>
<p>数据统计埋点工作框架及细节规范<a href="https://www.inneed.club/articles/detail/pkx0epxgew" target="_blank" rel="noopener">https://www.inneed.club/articles/detail/pkx0epxgew</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2020/03/14/Activiti7.X结合SpringBoot2.1、Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/14/Activiti7.X结合SpringBoot2.1、Mybatis/" itemprop="url">Activiti7.X结合SpringBoot2.1、Mybatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-14T18:33:00+08:00">
                2020-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/14/Activiti7.X结合SpringBoot2.1、Mybatis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/03/14/Activiti7.X结合SpringBoot2.1、Mybatis/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Activiti7-X结合SpringBoot2-1、Mybatis"><a href="#Activiti7-X结合SpringBoot2-1、Mybatis" class="headerlink" title="Activiti7.X结合SpringBoot2.1、Mybatis"></a>Activiti7.X结合SpringBoot2.1、Mybatis</h1><h2 id="Activiti简介"><a href="#Activiti简介" class="headerlink" title="Activiti简介"></a>Activiti简介</h2><h3 id="Activiti介绍"><a href="#Activiti介绍" class="headerlink" title="Activiti介绍"></a>Activiti介绍</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2317879.png" alt="image"></p>
<p>Activiti 是由 jBPM 的创建者 Tom Baeyens 离开 JBoss 之后建立的项目，构建在开发 jBPM 版本 1 到 4 时积累的多年经验的基础之上，旨在创建下一代的 BPM 解决方案。</p>
<p>Activiti是一个开源的工作流引擎，它实现了BPMN 2.0规范，可以发布设计好的流程定义，并通过api进行流程调度。</p>
<p>Activiti 作为一个遵从 Apache 许可的工作流和业务流程管理开源平台，其核心是基于Java的超快速、超稳定的 BPMN2.0 流程引擎，强调流程服务的可嵌入性和可扩展性，同时更加强调面向业务人员。</p>
<p>Activiti 流程引擎重点关注在系统开发的易用性和轻量性上。每一项 BPM 业务功能 Activiti 流程引擎都以服务的形式提供给开发人员。通过使用这些服务，开发人员能够构建出功能丰富、轻便且高效的 BPM 应用程序。</p>
<p>Activiti是一个针对企业用户、开发人员、系统管理员的轻量级工作流业务管理平台，其核心是使用Java开发的快速、稳定的BPMN e 2.0流程引擎。Activiti是在ApacheV2许可下发布的，可以运行在任何类型的Java程序中，例如服务器、集群、云服务等。Activiti可以完美地与Spring集成。同时，基于简约思想的设计使Activiti非常轻量级。</p>
<p>目前Activiti有2个版本，一个本地的core，一个可以支持分布式的cloud，本文只介绍core，新版 Activiti 7.0.0 发布后，Activiti Cloud 现在是新一代商业自动化平台，提供一组旨在在分布式基础架构上运行的 Cloud原生构建块。Cloud可以参考<a href="https://activiti.gitbook.io/activiti-7-developers-guide/getting-started" target="_blank" rel="noopener">官网</a></p>
<p>Activiti 7.x 主要突出了 Spring Boot 2.x 应用程序中的 ProcessRuntime 和 TaskRuntime API 的使用。</p>
<h3 id="BPMN"><a href="#BPMN" class="headerlink" title="BPMN"></a>BPMN</h3><p>BPMN（Business Process Model And Notation）-业务流程模型和符号是由BPMI（Business Process Management Initiative）开发的一套标准的业务流程建模符号，使用BPMN提供的符号可以创建业务流程。</p>
<p>Activiti 就是使用BPMN 2.0 进行流程建模、流程执行管理，它包括很多的建模符号，比如：Event 用一个圆圈表示，它是流程中运行过程中发生的事情。</p>
<p>一个bpmn图形的例子：</p>
<p>首先当事人发起一个请假单<br>其次他所在部门的经理对请假单进行审核<br>然后人事经理进行复核并进行备案<br>最后请假流程结束</p>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>代码库地址：<a href="https://github.com/dinghuang/activiti-service.git" target="_blank" rel="noopener">https://github.com/dinghuang/activiti-service.git</a></p>
<p>创建maven应用，pom引入包<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span><br><span class="line"><span class="xml">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dinghuang-framework-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dinghuang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>activiti<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>activiti project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">mapstruct</span>&gt;</span>1.3.0.Final<span class="tag">&lt;/<span class="name">mapstruct</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">activiti.version</span>&gt;</span>7.1.0.M6<span class="tag">&lt;/<span class="name">activiti.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">spring-boot</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">spring-boot</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">fastjson</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">fastjson</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">commons-collections</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">commons-collections</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">commons-lang3</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">commons-lang3</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">swagger-annotations</span>&gt;</span>1.5.16<span class="tag">&lt;/<span class="name">swagger-annotations</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">springfox-swagger2</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">springfox-swagger2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">druid</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">druid</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">mybatis-plus-boot-starter</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">mybatis-plus-boot-starter</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">feign-hystrix</span>&gt;</span>9.5.0<span class="tag">&lt;/<span class="name">feign-hystrix</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">lombok</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">lombok</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">mysql-connector-java</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">mysql-connector-java</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">liquibase-core</span>&gt;</span>3.5.3<span class="tag">&lt;/<span class="name">liquibase-core</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">validation-api</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">validation-api</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">hibernate-validator</span>&gt;</span>6.0.15.Final<span class="tag">&lt;/<span class="name">hibernate-validator</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti.dependencies<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;activiti.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;activiti.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>42.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Activiti生成流程图 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-image-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring-boot&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dinghuang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dinghuang-framework-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="comment">&lt;!--这个配置是因为lombok跟mapstruct一起用的时候maven对注解的解析器选择有点问题--&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">path</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;mapstruct&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">path</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">compilerArg</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            -Amapstruct.defaultComponentModel=spring</span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;/<span class="name">compilerArg</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="与mysql结合"><a href="#与mysql结合" class="headerlink" title="与mysql结合"></a>与mysql结合</h3><p>在<code>resource</code>目录下准备文件<code>activiti.cfg.xml</code>，内容如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml <span class="built_in">version</span>=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line">    &lt;bean <span class="built_in">id</span>=<span class="string">"processEngineConfiguration"</span> <span class="built_in">class</span>=<span class="string">"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"databaseType"</span> value=<span class="string">"mysql"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"jdbcUrl"</span> value=<span class="string">"jdbc:mysql://localhost:3306/activiti"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"jdbcDriver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"jdbcUsername"</span> value=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"jdbcPassword"</span> value=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>执行下面的代码，初始化db数据库或者配置springboot配置文件，会自动生成25个表，代码执行如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.dinghuang.activiti.conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.impl.db.DbSchemaCreate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dinghuang123@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/2/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DbSchemaCreate.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr"> activiti:</span></span><br><span class="line">  <span class="comment"># 自动建表</span></span><br><span class="line"><span class="attr">  database-schema:</span> <span class="string">ACTIVITI</span></span><br><span class="line">  <span class="comment">#表示启动时检查数据库表，不存在则创建</span></span><br><span class="line"><span class="attr">  database-schema-update:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#表示哪种情况下使用历史表，这里配置为full表示全部记录历史，方便绘制流程图</span></span><br><span class="line"><span class="attr">  history-level:</span> <span class="string">full</span></span><br><span class="line">  <span class="comment">#表示使用历史表，如果不配置，则工程启动后可以检查数据库，只建立了17张表，历史表没有建立，则流程图及运行节点无法展示</span></span><br><span class="line"><span class="attr">  db-history-used:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">project:</span></span><br><span class="line"><span class="attr">  manifest:</span></span><br><span class="line"><span class="attr">    file:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="attr">classpath:/default-project.json</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">org.activiti:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></p>
<h4 id="数据库说明"><a href="#数据库说明" class="headerlink" title="数据库说明"></a>数据库说明</h4><p>数据库会生成25张表，ER图如图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/activiti.png" alt="image"><br>表的列表：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG430.png" alt="image"></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ACT_RE_*</span>: RE表示repository，这个前缀的表包含了流程定义和流程静态资源</span><br><span class="line"><span class="attribute">ACT_RU_*</span>: RU表示runtime，这些运行时的表，包含流程实例，任务，变量，异步任务等运行中的数据。Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。</span><br><span class="line"><span class="attribute">ACT_ID_*</span>: ID表示identity，这些表包含身份信息，比如用户，组等。这些表现在已废弃。</span><br><span class="line"><span class="attribute">ACT_HI_*</span>: HI表示history，这些表包含历史数据，比如历史流程实例， 变量，任务等。</span><br><span class="line"><span class="attribute">ACT_GE_*</span>: 通用数据， 用于不同场景下。</span><br><span class="line"><span class="attribute">ACT_EVT_*</span>: EVT表示EVENT，目前只有一张表ACT_EVT_LOG，存储事件处理日志，方便管理员跟踪处理</span><br></pre></td></tr></table></figure>
<p>具体表详解可以参考<a href="https://www.chenmin.info/2018/07/28/Activiti-23%E5%BC%A0%E8%A1%A8%E5%8F%8A7%E5%A4%A7%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3/#7%E5%A4%A7%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">文章</a></p>
<h3 id="表详解"><a href="#表详解" class="headerlink" title="表详解"></a>表详解</h3><table>
<thead>
<tr>
<th>表</th>
<th>意义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACT_EVT_LOG</td>
<td>事件处理日志</td>
<td></td>
</tr>
<tr>
<td>ACT_GE_BYTEARRAY</td>
<td>二进制数据表</td>
<td>存储流程定义相关的部署信息。即流程定义文档的存放地。每部署一次就会增加两条记录，一条是关于bpmn规则文件的，一条是图片的（如果部署时只指定了bpmn一个文件，activiti会在部署时解析bpmn文件内容自动生成流程图）。两个文件不是很大，都是以二进制形式存储在数据库中。</td>
</tr>
<tr>
<td>ACT_GE_PROPERTY</td>
<td>主键生成表</td>
<td>主张表将生成下次流程部署的主键ID。    </td>
</tr>
<tr>
<td>ACT_HI_ACTINST</td>
<td>历史节点表</td>
<td>只记录usertask内容,某一次流程的执行一共经历了多少个活动</td>
</tr>
<tr>
<td>ACT_HI_ATTACHMENT</td>
<td>历史附件表</td>
<td></td>
</tr>
<tr>
<td>ACT_HI_COMMENT</td>
<td>历史意见表</td>
<td></td>
</tr>
<tr>
<td>ACT_HI_DETAIL</td>
<td>历史详情表，提供历史变量的查询</td>
<td>流程中产生的变量详细，包括控制流程流转的变量等</td>
</tr>
<tr>
<td>ACT_HI_IDENTITYLINK</td>
<td>历史流程人员表</td>
<td></td>
</tr>
<tr>
<td>ACT_HI_PROCINST</td>
<td>历史流程实例表</td>
<td></td>
</tr>
<tr>
<td>ACT_HI_TASKINST</td>
<td>历史任务实例表</td>
<td>一次流程的执行一共经历了多少个任务</td>
</tr>
<tr>
<td>ACT_HI_VARINST</td>
<td>历史变量表</td>
<td></td>
</tr>
<tr>
<td>ACT_PROCDEF_INFO</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ACT_RE_DEPLOYMENT</td>
<td>部署信息表</td>
<td>存放流程定义的显示名和部署时间，每部署一次增加一条记录</td>
</tr>
<tr>
<td>ACT_RE_MODEL</td>
<td>流程设计模型部署表</td>
<td>流程设计器设计流程后，保存数据到该表</td>
</tr>
<tr>
<td>ACT_RE_PROCDEF</td>
<td>流程定义数据表</td>
<td>存放流程定义的属性信息，部署每个新的流程定义都会在这张表中增加一条记录。注意：当流程定义的key相同的情况下，使用的是版本升级</td>
</tr>
<tr>
<td>ACT_RU_EVENT_SUBSCR</td>
<td>throwEvent，catchEvent时间监听信息表</td>
<td></td>
</tr>
<tr>
<td>ACT_RU_EXECUTION</td>
<td>运行时流程执行实例表</td>
<td>历史流程变量</td>
</tr>
<tr>
<td>ACT_RU_IDENTITYLINK</td>
<td>运行时流程人员表</td>
<td>主要存储任务节点与参与者的相关信息</td>
</tr>
<tr>
<td>ACT_RU_INTEGRATION</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ACT_RU_JOB</td>
<td>运行时定时任务数据表    </td>
</tr>
<tr>
<td>ACT_RU_TIMER_JOB</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ACT_RU_SUSPENDED_JOB</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ACT_RU_TASK</td>
<td>运行时任务节点表</td>
<td></td>
</tr>
<tr>
<td>ACT_RU_TIMER_JOB</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ACT_RU_VARIABLE</td>
<td>运行时流程变量数据表</td>
<td>通过JavaBean设置的流程变量，在act_ru_variable中存储的类型为serializable，变量真正存储的地方在act_ge_bytearray中。</td>
</tr>
<tr>
<td>ACT_ID_GROUP</td>
<td>用户组信息表</td>
<td>已废弃    </td>
</tr>
<tr>
<td>ACT_ID_INFO</td>
<td>用户扩展信息表</td>
<td>已废弃</td>
</tr>
<tr>
<td>ACT_ID_MEMBERSHIP</td>
<td>用户与用户组对应信息表</td>
<td>已废弃    </td>
</tr>
<tr>
<td>ACT_ID_USER</td>
<td>用户信息表</td>
<td>已废弃</td>
</tr>
</tbody>
</table>
<h2 id="工作流使用"><a href="#工作流使用" class="headerlink" title="工作流使用"></a>工作流使用</h2><p>activiti7内置了Spring security框架,官方demo跟spring结合的必须与spring-security结合，这里我不用spring-security，因为现在没有用户表了，所以自定义一些用户角色表去结合，更容易理解。</p>
<blockquote>
<p>关于security问题<br>activiti7最新的类似Runtime API和Task API都集成了security。<br>如果使用上述的API,那么必须要使用security，不能屏蔽security，否则会报错。<br>使用引擎服务类的时候，可以排除security，因为这些是最原始的API。但是activiti7官方已经明确说了，随时可能会干掉这些API。不建议开发人员直接使用引擎类以及引擎配置了、服务类等。</p>
</blockquote>
<h3 id="相关配置类"><a href="#相关配置类" class="headerlink" title="相关配置类"></a>相关配置类</h3><h4 id="自定义id策略"><a href="#自定义id策略" class="headerlink" title="自定义id策略"></a>自定义id策略</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">org</span><span class="selector-class">.dinghuang</span><span class="selector-class">.activiti</span><span class="selector-class">.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">com</span><span class="selector-class">.baomidou</span><span class="selector-class">.mybatisplus</span><span class="selector-class">.core</span><span class="selector-class">.toolkit</span><span class="selector-class">.IdWorker</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.activiti</span><span class="selector-class">.engine</span><span class="selector-class">.impl</span><span class="selector-class">.cfg</span><span class="selector-class">.IdGenerator</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.stereotype</span><span class="selector-class">.Component</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义id策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author dinghuang123@gmail.com</span></span><br><span class="line"><span class="comment"> * @since 2020/3/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="keyword">Component</span></span><br><span class="line"><span class="keyword">public</span> class ActivitiIdGeneratorConfiguration implements IdGenerator &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">Override</span></span><br><span class="line">    public String getNextId() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">String</span><span class="selector-class">.valueOf</span>(<span class="selector-tag">IdWorker</span><span class="selector-class">.getId</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义用户组"><a href="#自定义用户组" class="headerlink" title="自定义用户组"></a>自定义用户组</h4><p>activiti7已经抛弃了identity相关的表，同时与springSecurity结合，所以这边如果想自定义可以这么改，但是实际用途不大，最重要的是要结合自己的用户表设计来。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package org.dinghuang.activiti.conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.api.runtime.shared.identity.UserGroupManager;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">List</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">Map</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * 重写用户权限</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @author dinghuang123@gmail.com</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @since 2020/3/2</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ActivitiUserGroupManagerConfiguration</span> <span class="keyword">implements</span> <span class="title">UserGroupManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ActivitiUserGroupManagerConfiguration.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; groups = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; userRoleMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        roles.add(<span class="string">"workCreate"</span>);</span><br><span class="line">        roles.add(<span class="string">"workPermit"</span>);</span><br><span class="line">        roles.add(<span class="string">"workLeader"</span>);</span><br><span class="line"></span><br><span class="line">        groups.add(<span class="string">"workGroupA"</span>);</span><br><span class="line"></span><br><span class="line">        users.add(<span class="string">"admin"</span>);</span><br><span class="line">        users.add(<span class="string">"laowang"</span>);</span><br><span class="line">        users.add(<span class="string">"xiaofang"</span>);</span><br><span class="line"></span><br><span class="line">        userRoleMap.put(<span class="string">"admin"</span>, <span class="string">"workCreate"</span>);</span><br><span class="line">        userRoleMap.put(<span class="string">"laowang"</span>, <span class="string">"workPermit"</span>);</span><br><span class="line">        userRoleMap.put(<span class="string">"xiaofang"</span>, <span class="string">"workLeader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getUserGroups(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        LOGGER.info(<span class="string">"get user groups"</span>);</span><br><span class="line">        <span class="keyword">return</span> groups;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getUserRoles(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">String</span> role = userRoleMap.<span class="keyword">get</span>(s);</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(role);</span><br><span class="line">        LOGGER.info(<span class="string">"get user roles"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getGroups() &#123;</span><br><span class="line">        LOGGER.info(<span class="string">"get groups"</span>);</span><br><span class="line">        <span class="keyword">return</span> groups;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getUsers() &#123;</span><br><span class="line">        LOGGER.info(<span class="string">"get users"</span>);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="其他自定义配置"><a href="#其他自定义配置" class="headerlink" title="其他自定义配置"></a>其他自定义配置</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.dinghuang.activiti.conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.api.runtime.shared.identity.UserGroupManager;</span><br><span class="line"><span class="keyword">import</span> org.activiti.core.common.spring.project.ProjectModelService;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.impl.history.HistoryLevel;</span><br><span class="line"><span class="keyword">import</span> org.activiti.spring.SpringAsyncExecutor;</span><br><span class="line"><span class="keyword">import</span> org.activiti.spring.SpringProcessEngineConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.dinghuang.activiti.controller.ActivitiController;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dinghuang123@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/3/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivitiSpringIdentityAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ActivitiController.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_SECONDS = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager platformTransactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserGroupManager userGroupManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ActivitiIdGeneratorConfiguration activitiIdGeneratorConfiguration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProjectModelService projectModelService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理引擎配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">SpringProcessEngineConfiguration <span class="title">springProcessEngineConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpringProcessEngineConfiguration configuration = <span class="keyword">new</span> SpringProcessEngineConfiguration(projectModelService);</span><br><span class="line">        configuration.setDataSource(<span class="keyword">this</span>.dataSource);</span><br><span class="line">        configuration.setTransactionManager(<span class="keyword">this</span>.platformTransactionManager);</span><br><span class="line">        SpringAsyncExecutor asyncExecutor = <span class="keyword">new</span> SpringAsyncExecutor();</span><br><span class="line">        asyncExecutor.setTaskExecutor(workFlowAsync());</span><br><span class="line">        configuration.setAsyncExecutor(asyncExecutor);</span><br><span class="line">        configuration.setDatabaseSchemaUpdate(<span class="string">"true"</span>);</span><br><span class="line">        configuration.setUserGroupManager(<span class="keyword">this</span>.userGroupManager);</span><br><span class="line">        configuration.setHistoryLevel(HistoryLevel.FULL);</span><br><span class="line">        configuration.setDbHistoryUsed(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setIdGenerator(<span class="keyword">this</span>.activitiIdGeneratorConfiguration);</span><br><span class="line">        Resource[] resources = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 启动自动部署流程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resources = <span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath*:bpmn/*.bpmn"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.<span class="keyword">error</span>(<span class="string">"Start the automated deployment process error"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        configuration.setDeploymentResources(resources);</span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"workFlowTaskExecutor"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function">ThreadPoolTaskExecutor <span class="title">workFlowAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(CORE_POOL_SIZE);</span><br><span class="line">        executor.setMaxPoolSize(MAX_POOL_SIZE);</span><br><span class="line">        executor.setKeepAliveSeconds(KEEP_ALIVE_SECONDS);</span><br><span class="line">        executor.setQueueCapacity(QUEUE_CAPACITY);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"workFlowTaskExecutor-"</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为去掉了springSecurity,所以启动类得排除springSecurity的自动配置。<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.dinghuang.activiti;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@SpringBootApplication</span>(exclude = &#123;</span><br><span class="line">        org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.<span class="keyword">class</span>,</span><br><span class="line">        org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration.<span class="keyword">class</span>,</span><br><span class="line">        org.activiti.core.common.spring.identity.config.ActivitiSpringIdentityAutoConfiguration.<span class="keyword">class</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ActivitiApplication &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ActivitiApplication.<span class="keyword">class</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> InternalResourceViewResolver setupViewResolver() &#123;</span><br><span class="line">        InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">        <span class="comment">/** 设置视图路径的前缀 */</span></span><br><span class="line">        resolver.setPrefix(<span class="string">"resources/templates"</span>);</span><br><span class="line">        <span class="comment">/** 设置视图路径的后缀 */</span></span><br><span class="line">        resolver.setSuffix(<span class="string">".html"</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="流程绘制"><a href="#流程绘制" class="headerlink" title="流程绘制"></a>流程绘制</h2><p>流程绘制这里提供2种，一种用IDEA下载ActiBPM插件去画，这里给一段我自己画的xml<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> standalone=<span class="string">"yes"</span><span class="meta">?&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/MODEL"</span> <span class="attr">xmlns:activiti</span>=<span class="string">"http://activiti.org/bpmn"</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/DI"</span> <span class="attr">xmlns:dc</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DC"</span> <span class="attr">xmlns:di</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DI"</span> <span class="attr">xmlns:tns</span>=<span class="string">"http://sourceforge.net/bpmn/definitions/a123123"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:yaoqiang</span>=<span class="string">"http://bpmn.sourceforge.net"</span> <span class="attr">expressionLanguage</span>=<span class="string">"http://www.w3.org/1999/XPath"</span> <span class="attr">id</span>=<span class="string">"m1583310491794"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">targetNamespace</span>=<span class="string">"http://sourceforge.net/bpmn/definitions/a123123"</span> <span class="attr">typeLanguage</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">"dinghuangTest"</span> <span class="attr">isClosed</span>=<span class="string">"false"</span> <span class="attr">isExecutable</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"请假流程"</span> <span class="attr">processType</span>=<span class="string">"None"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">"_2"</span> <span class="attr">name</span>=<span class="string">"开始"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">activiti:assignee</span>=<span class="string">"bilu"</span> <span class="attr">activiti:candidateGroups</span>=<span class="string">"manager"</span> <span class="attr">activiti:exclusive</span>=<span class="string">"true"</span> <span class="attr">id</span>=<span class="string">"_3"</span> <span class="attr">name</span>=<span class="string">"部门经理审批"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">"_4"</span> <span class="attr">name</span>=<span class="string">"结束"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"_5"</span> <span class="attr">sourceRef</span>=<span class="string">"_2"</span> <span class="attr">targetRef</span>=<span class="string">"_3"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"_6"</span> <span class="attr">name</span>=<span class="string">"事情不重要"</span> <span class="attr">sourceRef</span>=<span class="string">"_3"</span> <span class="attr">targetRef</span>=<span class="string">"_4"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">"tFormalExpression"</span>&gt;</span>&lt;![CDATA[$</span><span class="template-variable">&#123;!important&#125;</span><span class="xml">]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">activiti:candidateGroups</span>=<span class="string">"admin"</span> <span class="attr">activiti:exclusive</span>=<span class="string">"true"</span> <span class="attr">id</span>=<span class="string">"_7"</span> <span class="attr">name</span>=<span class="string">"总经理审批"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"_8"</span> <span class="attr">name</span>=<span class="string">"事情重要"</span> <span class="attr">sourceRef</span>=<span class="string">"_3"</span> <span class="attr">targetRef</span>=<span class="string">"_7"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">"tFormalExpression"</span>&gt;</span>&lt;![CDATA[$</span><span class="template-variable">&#123;important&#125;</span><span class="xml">]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"_9"</span> <span class="attr">name</span>=<span class="string">"审批通过"</span> <span class="attr">sourceRef</span>=<span class="string">"_7"</span> <span class="attr">targetRef</span>=<span class="string">"_4"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">documentation</span>=<span class="string">"background=#3C3F41;count=1;horizontalcount=1;orientation=0;width=842.4;height=1195.2;imageableWidth=832.4;imageableHeight=1185.2;imageableX=5.0;imageableY=5.0"</span> <span class="attr">id</span>=<span class="string">"Diagram-_1"</span> <span class="attr">name</span>=<span class="string">"New Diagram"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">"dinghuangTest"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"_2"</span> <span class="attr">id</span>=<span class="string">"Shape-_2"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"32.0"</span> <span class="attr">width</span>=<span class="string">"32.0"</span> <span class="attr">x</span>=<span class="string">"100.0"</span> <span class="attr">y</span>=<span class="string">"135.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"32.0"</span> <span class="attr">width</span>=<span class="string">"32.0"</span> <span class="attr">x</span>=<span class="string">"0.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"_3"</span> <span class="attr">id</span>=<span class="string">"Shape-_3"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"85.0"</span> <span class="attr">x</span>=<span class="string">"235.0"</span> <span class="attr">y</span>=<span class="string">"140.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"85.0"</span> <span class="attr">x</span>=<span class="string">"0.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"_4"</span> <span class="attr">id</span>=<span class="string">"Shape-_4"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"32.0"</span> <span class="attr">width</span>=<span class="string">"32.0"</span> <span class="attr">x</span>=<span class="string">"565.0"</span> <span class="attr">y</span>=<span class="string">"160.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"32.0"</span> <span class="attr">width</span>=<span class="string">"32.0"</span> <span class="attr">x</span>=<span class="string">"0.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"_7"</span> <span class="attr">id</span>=<span class="string">"Shape-_7"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"85.0"</span> <span class="attr">x</span>=<span class="string">"415.0"</span> <span class="attr">y</span>=<span class="string">"55.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"85.0"</span> <span class="attr">x</span>=<span class="string">"0.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"_5"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge__5"</span> <span class="attr">sourceElement</span>=<span class="string">"_2"</span> <span class="attr">targetElement</span>=<span class="string">"_3"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">di:waypoint</span> <span class="attr">x</span>=<span class="string">"132.0"</span> <span class="attr">y</span>=<span class="string">"151.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">di:waypoint</span> <span class="attr">x</span>=<span class="string">"235.0"</span> <span class="attr">y</span>=<span class="string">"167.5"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"0.0"</span> <span class="attr">width</span>=<span class="string">"0.0"</span> <span class="attr">x</span>=<span class="string">"0.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"_6"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge__6"</span> <span class="attr">sourceElement</span>=<span class="string">"_3"</span> <span class="attr">targetElement</span>=<span class="string">"_4"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">di:waypoint</span> <span class="attr">x</span>=<span class="string">"320.0"</span> <span class="attr">y</span>=<span class="string">"167.5"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">di:waypoint</span> <span class="attr">x</span>=<span class="string">"565.0"</span> <span class="attr">y</span>=<span class="string">"176.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"0.0"</span> <span class="attr">width</span>=<span class="string">"0.0"</span> <span class="attr">x</span>=<span class="string">"0.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"_8"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge__8"</span> <span class="attr">sourceElement</span>=<span class="string">"_3"</span> <span class="attr">targetElement</span>=<span class="string">"_7"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">di:waypoint</span> <span class="attr">x</span>=<span class="string">"320.0"</span> <span class="attr">y</span>=<span class="string">"167.5"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">di:waypoint</span> <span class="attr">x</span>=<span class="string">"415.0"</span> <span class="attr">y</span>=<span class="string">"82.5"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"0.0"</span> <span class="attr">width</span>=<span class="string">"0.0"</span> <span class="attr">x</span>=<span class="string">"0.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"_9"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge__9"</span> <span class="attr">sourceElement</span>=<span class="string">"_7"</span> <span class="attr">targetElement</span>=<span class="string">"_4"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">di:waypoint</span> <span class="attr">x</span>=<span class="string">"500.0"</span> <span class="attr">y</span>=<span class="string">"82.5"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">di:waypoint</span> <span class="attr">x</span>=<span class="string">"565.0"</span> <span class="attr">y</span>=<span class="string">"176.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">dc:Bounds</span> <span class="attr">height</span>=<span class="string">"0.0"</span> <span class="attr">width</span>=<span class="string">"0.0"</span> <span class="attr">x</span>=<span class="string">"0.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">bpmndi:BPMNLabel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这是一个很简单的流程，如图所示:<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG432.png" alt="image"></p>
<h3 id="前端实现自定义流程、输出流程图"><a href="#前端实现自定义流程、输出流程图" class="headerlink" title="前端实现自定义流程、输出流程图"></a>前端实现自定义流程、输出流程图</h3><p>官方提供bpmn.js可以实现前端拖动画图，github地址：<a href="https://github.com/bpmn-io/bpmn-js" target="_blank" rel="noopener">https://github.com/bpmn-io/bpmn-js</a></p>
<p>可以把这个加到项目中，这里就不解释了。</p>
<p>前端实现输出流程图效果如下，流程节点会高亮显示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG433.png" alt="image"></p>
<p>这里是我写的一个小demo，代码可以查看我的github代码库。项目启动后，访问<a href="http://localhost:8080/v1/activiti/index" target="_blank" rel="noopener">http://localhost:8080/v1/activiti/index</a></p>
<h2 id="接口调试"><a href="#接口调试" class="headerlink" title="接口调试"></a>接口调试</h2><p>服务启动后访问地址：<a href="http://localhost:8080/swagger-ui.html#/" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html#/</a><br>接口已经写在代码中，如果需要调试的话，顺序是</p>
<ul>
<li>启动实例流程</li>
<li>根据用户名称查询任务列表（用户名bilu，拿到任务id后去完成任务）</li>
<li>审批approve</li>
<li>回退 back<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG434.png" alt="image"></li>
</ul>
<h3 id="实现随意跳转和回退撤回功能"><a href="#实现随意跳转和回退撤回功能" class="headerlink" title="实现随意跳转和回退撤回功能"></a>实现随意跳转和回退撤回功能</h3><p>因为activiti7是以图的形式来操作的，所以这边就要考虑连线的情况。</p>
<p>本文写了并行和串行的撤回以及撤回功能的连线的图，最终效果图如图所示<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG451.png" alt="image"></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    * 输出图像</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    * @param response               响应实体</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    * @param bpmnModel              图像对象</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    * @param flowIds                已执行的线集合</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    * @param executedActivityIdList void 已执行的节点ID集合</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">   public <span class="keyword">void</span> outputImg(HttpServletResponse response, BpmnModel bpmnModel, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; flowIds, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; executedActivityIdList) &#123;</span><br><span class="line">       InputStream imageStream = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           imageStream = <span class="keyword">new</span> DefaultProcessDiagramGenerator().generateDiagram(bpmnModel, executedActivityIdList, flowIds, <span class="string">"宋体"</span>, <span class="string">"微软雅黑"</span>, <span class="string">"黑体"</span>, <span class="keyword">true</span>, <span class="string">"png"</span>);</span><br><span class="line">           <span class="comment">// 输出资源内容到相应对象</span></span><br><span class="line">           byte[] b = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">           <span class="built_in">int</span> len;</span><br><span class="line">           <span class="keyword">while</span> ((len = imageStream.read(b, <span class="number">0</span>, <span class="number">1024</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">               response.getOutputStream().write(b, <span class="number">0</span>, len);</span><br><span class="line">           &#125;</span><br><span class="line">           response.getOutputStream().flush();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           LOGGER.error(<span class="string">"out put process img error！"</span>, e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 流关闭</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (imageStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   imageStream.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               LOGGER.error(<span class="string">"IoException"</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public <span class="keyword">void</span> showImg(<span class="built_in">String</span> instanceKey, HttpServletResponse response) &#123;</span><br><span class="line">       <span class="keyword">if</span> (instanceKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">           LOGGER.error(<span class="string">"process instance not exist"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取流程实例</span></span><br><span class="line">       HistoricProcessInstance processInstance = historyService.createHistoricProcessInstanceQuery().processInstanceId(instanceKey).singleResult();</span><br><span class="line">       <span class="keyword">if</span> (processInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">           LOGGER.error(<span class="string">"process instance &#123;&#125; not exist"</span>, instanceKey);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 根据流程对象获取流程对象模型</span></span><br><span class="line">       BpmnModel bpmnModel = repositoryService.getBpmnModel(processInstance.getProcessDefinitionId());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//查看已执行的节点集合, 获取流程历史中已执行节点，并按照节点在流程中执行先后顺序排序</span></span><br><span class="line">       <span class="comment">// 构造历史流程查询</span></span><br><span class="line">       HistoricActivityInstanceQuery historyInstanceQuery = historyService.createHistoricActivityInstanceQuery().processInstanceId(instanceKey);</span><br><span class="line">       <span class="comment">// 查询历史节点,根据id排序</span></span><br><span class="line">       <span class="built_in">List</span>&lt;HistoricActivityInstance&gt; historicActivityInstanceList = historyInstanceQuery.orderBy(HistoricActivityInstanceQueryProperty.HISTORIC_ACTIVITY_INSTANCE_ID).asc().list();</span><br><span class="line">       <span class="keyword">if</span> (historicActivityInstanceList == <span class="keyword">null</span> || historicActivityInstanceList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           LOGGER.info(<span class="string">"process instance history node info not exist"</span>, instanceKey);</span><br><span class="line">           outputImg(response, bpmnModel, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap = getFlowNodeMap(historicActivityInstanceList, processInstance.getProcessDefinitionId());</span><br><span class="line">       <span class="comment">//处理撤回这种情况 根据id排序</span></span><br><span class="line">       <span class="built_in">List</span>&lt;Task&gt; tasks = taskService.createTaskQuery().processInstanceId(instanceKey).orderBy(TaskQueryProperty.TASK_ID).asc().list();</span><br><span class="line">       <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; executedActivityIdList = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">       <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; taskIdList = tasks == <span class="keyword">null</span> ? <span class="keyword">null</span> : tasks.stream().map(TaskInfo::getId).collect(Collectors.toList());</span><br><span class="line">       <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; taskKeyList = tasks == <span class="keyword">null</span> ? <span class="keyword">null</span> : tasks.stream().map(TaskInfo::getTaskDefinitionKey).collect(Collectors.toList());</span><br><span class="line">       <span class="keyword">if</span> (tasks != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//串行</span></span><br><span class="line">           <span class="keyword">if</span> (tasks.size() == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; historicActivityInstanceList.size(); i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (historicActivityInstanceList.<span class="keyword">get</span>(i).getTaskId() == <span class="keyword">null</span> || !historicActivityInstanceList.<span class="keyword">get</span>(i).getActivityId().equals(tasks.<span class="keyword">get</span>(<span class="number">0</span>).getTaskDefinitionKey())) &#123;</span><br><span class="line">                       executedActivityIdList.add(historicActivityInstanceList.<span class="keyword">get</span>(i).getActivityId());</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       executedActivityIdList.add(historicActivityInstanceList.<span class="keyword">get</span>(i).getActivityId());</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="built_in">List</span>&lt;HistoricVariableInstance&gt; historicVariableInstances = historyService.createHistoricVariableInstanceQuery()</span><br><span class="line">                       .processInstanceId(processInstance.getId()).list();</span><br><span class="line">               <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricVariableInstance&gt; historicVariableInstanceMap = historicVariableInstances.stream()</span><br><span class="line">                       .collect(Collectors.toMap(HistoricVariableInstance::getVariableName,</span><br><span class="line">                               historicVariableInstance -&gt; historicVariableInstance, BinaryOperator.maxBy(Comparator.comparing(HistoricVariableInstance::getId))));</span><br><span class="line">               <span class="comment">//并行</span></span><br><span class="line">               Collection&lt;FlowElement&gt; flowElementCollection = bpmnModel.getMainProcess().getFlowElements();</span><br><span class="line">               <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; parentMap = <span class="keyword">new</span> HashMap&lt;&gt;(tasks.size());</span><br><span class="line">               <span class="keyword">for</span> (FlowElement flowElement : flowElementCollection) &#123;</span><br><span class="line">                   <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; parentCodeList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                   <span class="keyword">if</span> (flowNodeMap.<span class="keyword">get</span>(flowElement.getId()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="built_in">List</span>&lt;SequenceFlow&gt; sequenceFlows = flowNodeMap.<span class="keyword">get</span>(flowElement.getId()).getIncomingFlows();</span><br><span class="line">                       <span class="keyword">if</span> (sequenceFlows != <span class="keyword">null</span> &amp;&amp; !sequenceFlows.isEmpty()) &#123;</span><br><span class="line">                           <span class="keyword">for</span> (SequenceFlow sequenceFlow : sequenceFlows) &#123;</span><br><span class="line">                               parentCodeList.add(sequenceFlow.getSourceRef());</span><br><span class="line">                           &#125;</span><br><span class="line">                           parentMap.put(flowElement.getId(), parentCodeList);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; sameParentTaskCode = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">                   <span class="comment">//找到所有任务拥有相同父级的集合任务</span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="built_in">String</span> taskKey : parentMap.<span class="keyword">get</span>(task.getTaskDefinitionKey())) &#123;</span><br><span class="line">                       <span class="keyword">for</span> (<span class="built_in">String</span> key : parentMap.keySet()) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (parentMap.<span class="keyword">get</span>(key).contains(taskKey)) &#123;</span><br><span class="line">                               sameParentTaskCode.add(key);</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//说明是并行，但是做完的任务</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="built_in">String</span> sameParentTask : sameParentTaskCode) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!taskKeyList.contains(sameParentTask)) &#123;</span><br><span class="line">                       <span class="built_in">List</span>&lt;SequenceFlow&gt; sequenceFlows = flowNodeMap.<span class="keyword">get</span>(sameParentTask).getOutgoingFlows();</span><br><span class="line">                       <span class="keyword">if</span> (sequenceFlows != <span class="keyword">null</span> &amp;&amp; !sequenceFlows.isEmpty()) &#123;</span><br><span class="line">                           <span class="keyword">for</span> (SequenceFlow sequenceFlow : sequenceFlows) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (querySequenceFlowCondition(sequenceFlow, historicVariableInstanceMap)) &#123;</span><br><span class="line">                                   executedActivityIdList.add(sequenceFlow.getTargetRef());</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (<span class="built_in">String</span> taskKey : sameParentTaskCode) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; historicActivityInstanceList.size(); i++) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (historicActivityInstanceList.<span class="keyword">get</span>(i).getTaskId() == <span class="keyword">null</span> || !historicActivityInstanceList.<span class="keyword">get</span>(i).getActivityId().equals(taskKey)) &#123;</span><br><span class="line">                           executedActivityIdList.add(historicActivityInstanceList.<span class="keyword">get</span>(i).getActivityId());</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           executedActivityIdList.add(historicActivityInstanceList.<span class="keyword">get</span>(i).getActivityId());</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取流程走过的线</span></span><br><span class="line">       <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; executedActivityIdListResult = <span class="keyword">new</span> ArrayList&lt;&gt;(executedActivityIdList);</span><br><span class="line">       <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; flowIds = getHighLightedFlows(bpmnModel, historicActivityInstanceList, executedActivityIdListResult, taskIdList);</span><br><span class="line">       <span class="comment">//输出图像，并设置高亮</span></span><br><span class="line">       outputImg(response, bpmnModel, flowIds, executedActivityIdListResult);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; getFlowNodeMap(<span class="built_in">List</span>&lt;HistoricActivityInstance&gt; historicActivityInstanceList, <span class="built_in">String</span> processDefinitionId) &#123;</span><br><span class="line">       org.activiti.bpmn.model.Process process = repositoryService</span><br><span class="line">               .getBpmnModel(processDefinitionId)</span><br><span class="line">               .getMainProcess();</span><br><span class="line">       <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap = <span class="keyword">new</span> HashMap&lt;&gt;(historicActivityInstanceList.size());</span><br><span class="line">       <span class="keyword">for</span> (HistoricActivityInstance historicActivityInstance : historicActivityInstanceList) &#123;</span><br><span class="line">           <span class="keyword">if</span> (flowNodeMap.<span class="keyword">get</span>(historicActivityInstance.getActivityId()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               FlowNode sourceNode = (FlowNode) process.getFlowElement(historicActivityInstance.getActivityId());</span><br><span class="line">               flowNodeMap.put(historicActivityInstance.getActivityId(), sourceNode);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flowNodeMap;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    * 撤回任务</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    * @param currentTaskId currentTaskId</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    * @param targetTaskId  targetTaskId 目标任务，如果为空，默认返回上级，如果找到上级有2个，那目标任务必须得传</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">   public <span class="keyword">void</span> backTask(<span class="built_in">String</span> currentTaskId, <span class="built_in">String</span> targetTaskId) &#123;</span><br><span class="line">       <span class="comment">//准备数据</span></span><br><span class="line">       TaskService taskService = processEngine.getTaskService();</span><br><span class="line">       <span class="comment">// 当前任务</span></span><br><span class="line">       Task currentTask = taskService.createTaskQuery().taskId(currentTaskId).singleResult();</span><br><span class="line">       <span class="built_in">String</span> processInstanceId = currentTask.getProcessInstanceId();</span><br><span class="line">       <span class="comment">// 获取流程定义</span></span><br><span class="line">       <span class="comment">//任务历史数据</span></span><br><span class="line">       <span class="built_in">List</span>&lt;HistoricTaskInstance&gt; historicTaskInstances = historyService</span><br><span class="line">               .createHistoricTaskInstanceQuery()</span><br><span class="line">               .processInstanceId(currentTask.getProcessInstanceId())</span><br><span class="line">               .orderBy(HistoricTaskInstanceQueryProperty.HISTORIC_TASK_INSTANCE_ID)</span><br><span class="line">               .desc()</span><br><span class="line">               .list();</span><br><span class="line">       <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricTaskInstance&gt; historicTaskInstanceMap = historicTaskInstances.stream().collect(Collectors.toMap(HistoricTaskInstance::getId, <span class="built_in">Function</span>.identity()));</span><br><span class="line">       <span class="comment">//所有节点操作数据</span></span><br><span class="line">       HistoricActivityInstanceQuery historyInstanceQuery = historyService.createHistoricActivityInstanceQuery().processInstanceId(processInstanceId);</span><br><span class="line">       <span class="built_in">List</span>&lt;HistoricActivityInstance&gt; historicActivityInstanceList = historyInstanceQuery.orderBy(HistoricActivityInstanceQueryProperty.HISTORIC_ACTIVITY_INSTANCE_ID).asc().list();</span><br><span class="line">       <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt;&gt; historicActivityInstanceMap = historicActivityInstanceList.stream().collect(Collectors.groupingBy(HistoricActivityInstance::getActivityId));</span><br><span class="line">       <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap = getFlowNodeMap(historicActivityInstanceList, currentTask.getProcessDefinitionId());</span><br><span class="line">       <span class="comment">//排除当前任务外的所有正在进行的任务</span></span><br><span class="line">       <span class="built_in">List</span>&lt;Task&gt; taskList = taskService.createTaskQuery().processInstanceId(processInstanceId).list().stream().filter(task -&gt; !task.getId().equals(currentTask.getId())).collect(Collectors.toList());</span><br><span class="line">       handleBackTask(currentTask, currentTask.getTaskDefinitionKey(), targetTaskId, historicTaskInstanceMap, historicActivityInstanceMap, flowNodeMap, taskList, historicActivityInstanceList);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">   public <span class="keyword">void</span> handleBackTask(Task currentTask, <span class="built_in">String</span> taskDefinitionKey, <span class="built_in">String</span> targetTaskId, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricTaskInstance&gt; historicTaskInstanceMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt;&gt; historicActivityInstanceMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap, <span class="built_in">List</span>&lt;Task&gt; taskList, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt; historicActivityInstanceList) &#123;</span><br><span class="line">       <span class="comment">//判断是否并行</span></span><br><span class="line">       <span class="keyword">if</span> (taskList == <span class="keyword">null</span> || taskList.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">//串行</span></span><br><span class="line">           handleSerial(currentTask, taskDefinitionKey, targetTaskId, historicTaskInstanceMap, historicActivityInstanceMap, flowNodeMap, taskList, historicActivityInstanceList);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//并行</span></span><br><span class="line">           handleParallel(currentTask, taskDefinitionKey, targetTaskId, historicTaskInstanceMap, historicActivityInstanceMap, flowNodeMap, taskList, historicActivityInstanceList);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">   public <span class="keyword">void</span> handleParallel(Task currentTask, <span class="built_in">String</span> taskDefinitionKey, <span class="built_in">String</span> targetTaskId, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricTaskInstance&gt; historicTaskInstanceMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt;&gt; historicActivityInstanceMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap, <span class="built_in">List</span>&lt;Task&gt; taskList, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt; historicActivityInstanceList) &#123;</span><br><span class="line">       <span class="built_in">List</span>&lt;SequenceFlow&gt; sequenceFlows = flowNodeMap.<span class="keyword">get</span>(taskDefinitionKey).getIncomingFlows();</span><br><span class="line">       <span class="keyword">if</span> (sequenceFlows.size() == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//当前节点的上级节点只有一条</span></span><br><span class="line">           SequenceFlow sequenceFlow = sequenceFlows.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//查询历史节点</span></span><br><span class="line">           HistoricActivityInstance historicActivityInstance = historicActivityInstanceList.stream().filter(query -&gt; query.getActivityId().equals(sequenceFlow.getSourceRef())).collect(Collectors.toList()).<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//判断来源类型</span></span><br><span class="line">           <span class="keyword">if</span> (historicActivityInstance.getActivityType().equals(PARALLEL_GATEWAY)) &#123;</span><br><span class="line">               <span class="comment">//网关</span></span><br><span class="line">               <span class="comment">//查找网关的父任务</span></span><br><span class="line">               <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; parentFlowNodes = queryParentFlowNode(historicActivityInstance.getActivityId(), flowNodeMap);</span><br><span class="line">               <span class="keyword">if</span> (!parentFlowNodes.isEmpty()) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (parentFlowNodes.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                       <span class="comment">//如果只有一个父节点</span></span><br><span class="line">                       <span class="built_in">String</span> activityId = <span class="keyword">new</span> ArrayList&lt;&gt;(parentFlowNodes).<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">                       <span class="keyword">if</span> (historicActivityInstanceMap.<span class="keyword">get</span>(activityId).<span class="keyword">get</span>(<span class="number">0</span>).getActivityType().equals(USER_TASK)) &#123;</span><br><span class="line">                           <span class="comment">//用户任务</span></span><br><span class="line">                           deleteTaskMultiple(flowNodeMap, <span class="keyword">null</span>, <span class="keyword">null</span>, activityId, currentTask, taskList, historicActivityInstance.getActivityId());</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">//递归去查找父任务的前一个</span></span><br><span class="line">                           handleBackTask(currentTask, historicActivityInstanceMap.<span class="keyword">get</span>(activityId).<span class="keyword">get</span>(<span class="number">0</span>).getActivityId(), targetTaskId, historicTaskInstanceMap, historicActivityInstanceMap, flowNodeMap, taskList, historicActivityInstanceList);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">//当前节点的上级节点有多条 这里需要指定要回退的taskId</span></span><br><span class="line">                       deleteTaskMultiple(flowNodeMap, historicTaskInstanceMap, targetTaskId, <span class="keyword">null</span>, currentTask, taskList, historicActivityInstance.getActivityId());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//没有父级任务，图有问题</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> CommonValidateException(<span class="string">"bpmn doc error"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (historicActivityInstance.getActivityType().equals(USER_TASK)) &#123;</span><br><span class="line">               <span class="comment">//用户任务</span></span><br><span class="line">               deleteTaskMultiple(flowNodeMap, <span class="keyword">null</span>, <span class="keyword">null</span>, historicActivityInstance.getActivityId(), currentTask, taskList, historicActivityInstance.getActivityId());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//todo 还没想好这种场景</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> CommonValidateException(BPMN_NOT_SUPPORT);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//当前节点的上级节点有多条 这里需要指定要回退的taskId</span></span><br><span class="line">           deleteTaskMultiple(flowNodeMap, historicTaskInstanceMap, targetTaskId, <span class="keyword">null</span>, currentTask, taskList, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">   public <span class="keyword">void</span> handleSerial(Task currentTask, <span class="built_in">String</span> taskDefinitionKey, <span class="built_in">String</span> targetTaskId, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricTaskInstance&gt; historicTaskInstanceMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt;&gt; historicActivityInstanceMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap, <span class="built_in">List</span>&lt;Task&gt; taskList, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt; historicActivityInstanceList) &#123;</span><br><span class="line">       FlowNode currentNode = flowNodeMap.<span class="keyword">get</span>(taskDefinitionKey);</span><br><span class="line">       <span class="built_in">List</span>&lt;SequenceFlow&gt; sequenceFlows = currentNode.getIncomingFlows();</span><br><span class="line">       <span class="keyword">if</span> (sequenceFlows.size() == <span class="number">1</span>) &#123;</span><br><span class="line">           SequenceFlow sequenceFlow = sequenceFlows.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">           HistoricActivityInstance historicActivityInstance = historicActivityInstanceMap.<span class="keyword">get</span>(sequenceFlow.getSourceRef()).<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//网关</span></span><br><span class="line">           <span class="keyword">if</span> (historicActivityInstance.getActivityType().equals(PARALLEL_GATEWAY) || historicActivityInstance.getActivityType().equals(EXCLUSIVE_GATEWAY)) &#123;</span><br><span class="line">               <span class="comment">//查找网关的父任务</span></span><br><span class="line">               <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; parentFlowNodes = queryParentFlowNode(historicActivityInstance.getActivityId(), flowNodeMap);</span><br><span class="line">               <span class="keyword">if</span> (!parentFlowNodes.isEmpty()) &#123;</span><br><span class="line">                   handleBackTaskSingle(parentFlowNodes, currentTask, targetTaskId, historicTaskInstanceMap, historicActivityInstanceMap, flowNodeMap, taskList, historicActivityInstanceList);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//当前节点的上级节点有多条 这里需要指定要回退的taskId</span></span><br><span class="line">                   deleteTaskMultiple(flowNodeMap, historicTaskInstanceMap, targetTaskId, <span class="keyword">null</span>, currentTask, taskList, <span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (historicActivityInstance.getActivityType().equals(USER_TASK)) &#123;</span><br><span class="line">               deleteTaskSingle(flowNodeMap, historicActivityInstance.getActivityId(), currentTask.getId());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//todo 还没想好这种场景</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> CommonValidateException(BPMN_NOT_SUPPORT);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricVariableInstance&gt; historicVariableInstanceMap = getHistoricVariableInstanceMap(currentTask.getProcessInstanceId());</span><br><span class="line">           <span class="comment">//串行的也有多条连线，可能是通过排他网关过来的</span></span><br><span class="line">           <span class="built_in">Set</span>&lt;HistoricActivityInstance&gt; historicActivityInstances = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (SequenceFlow sequenceFlow : sequenceFlows) &#123;</span><br><span class="line">               <span class="comment">//这边他的parent可能是没做过的，要找做过的</span></span><br><span class="line">               <span class="keyword">if</span> (historicActivityInstanceMap.<span class="keyword">get</span>(sequenceFlow.getSourceRef()) != <span class="keyword">null</span> &amp;&amp; querySequenceFlowCondition(sequenceFlow, historicVariableInstanceMap)) &#123;</span><br><span class="line">                   historicActivityInstances.addAll(historicActivityInstanceMap.<span class="keyword">get</span>(sequenceFlow.getSourceRef()));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//走过的只有一个</span></span><br><span class="line">           <span class="keyword">if</span> (historicActivityInstances.size() == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="built_in">List</span>&lt;HistoricActivityInstance&gt; historicActivityInstancesList = <span class="keyword">new</span> ArrayList&lt;&gt;(historicActivityInstances);</span><br><span class="line">               <span class="keyword">if</span> (historicActivityInstancesList.<span class="keyword">get</span>(<span class="number">0</span>).getActivityType().equals(USER_TASK)) &#123;</span><br><span class="line">                   deleteTaskSingle(flowNodeMap, historicActivityInstancesList.<span class="keyword">get</span>(<span class="number">0</span>).getActivityId(), currentTask.getId());</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (historicActivityInstancesList.<span class="keyword">get</span>(<span class="number">0</span>).getActivityType().equals(EXCLUSIVE_GATEWAY)) &#123;</span><br><span class="line">                   <span class="comment">//排他网关</span></span><br><span class="line">                   <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; parentFlowNodes = queryParentFlowNode(historicActivityInstancesList.<span class="keyword">get</span>(<span class="number">0</span>).getActivityId(), flowNodeMap);</span><br><span class="line">                   handleBackTaskSingle(parentFlowNodes, currentTask, targetTaskId, historicTaskInstanceMap, historicActivityInstanceMap, flowNodeMap, taskList, historicActivityInstanceList);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//todo 还没想好这种场景</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> CommonValidateException(BPMN_NOT_SUPPORT);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//当前节点的上级节点有多条 这里需要指定要回退的taskId</span></span><br><span class="line">               deleteTaskMultiple(flowNodeMap, historicTaskInstanceMap, targetTaskId, <span class="keyword">null</span>, currentTask, taskList, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricVariableInstance&gt; getHistoricVariableInstanceMap(<span class="built_in">String</span> processInstanceId) &#123;</span><br><span class="line">       <span class="built_in">List</span>&lt;HistoricVariableInstance&gt; historicVariableInstances = historyService.createHistoricVariableInstanceQuery()</span><br><span class="line">               .processInstanceId(processInstanceId).list();</span><br><span class="line">       <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricVariableInstance&gt; historicVariableInstanceMap = historicVariableInstances.stream()</span><br><span class="line">               .collect(Collectors.toMap(HistoricVariableInstance::getVariableName,</span><br><span class="line">                       historicVariableInstance -&gt; historicVariableInstance, BinaryOperator.maxBy(Comparator.comparing(HistoricVariableInstance::getId))));</span><br><span class="line">       <span class="keyword">return</span> historicVariableInstanceMap;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">   public <span class="keyword">void</span> handleBackTaskSingle(<span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; parentFlowNodes, Task currentTask, <span class="built_in">String</span> targetTaskId, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricTaskInstance&gt; historicTaskInstanceMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt;&gt; historicActivityInstanceMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap, <span class="built_in">List</span>&lt;Task&gt; taskList, <span class="built_in">List</span>&lt;HistoricActivityInstance&gt; historicActivityInstanceList) &#123;</span><br><span class="line">       <span class="keyword">if</span> (parentFlowNodes.size() == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; parentFlowNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(parentFlowNodes);</span><br><span class="line">           <span class="keyword">if</span> (historicActivityInstanceMap.<span class="keyword">get</span>(parentFlowNodeList.<span class="keyword">get</span>(<span class="number">0</span>)).<span class="keyword">get</span>(<span class="number">0</span>).getActivityType().equals(USER_TASK)) &#123;</span><br><span class="line">               deleteTaskSingle(flowNodeMap, parentFlowNodeList.<span class="keyword">get</span>(<span class="number">0</span>), currentTask.getId());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//递归去查找父任务的前一个</span></span><br><span class="line">               handleBackTask(currentTask, historicActivityInstanceMap.<span class="keyword">get</span>(parentFlowNodeList.<span class="keyword">get</span>(<span class="number">0</span>)).<span class="keyword">get</span>(<span class="number">0</span>).getActivityId(), targetTaskId, historicTaskInstanceMap, historicActivityInstanceMap, flowNodeMap, taskList, historicActivityInstanceList);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//当前节点的上级节点有多条 这里需要指定要回退的taskId</span></span><br><span class="line">           deleteTaskMultiple(flowNodeMap, historicTaskInstanceMap, targetTaskId, <span class="keyword">null</span>, currentTask, taskList, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private <span class="keyword">void</span> validatorTargetTask(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricTaskInstance&gt; historicTaskInstanceMap, <span class="built_in">String</span> targetTaskId) &#123;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(targetTaskId) || StringUtils.isBlank(targetTaskId)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CommonValidateException(<span class="string">"target task id cannot be null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (historicTaskInstanceMap == <span class="keyword">null</span> || historicTaskInstanceMap.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CommonValidateException(<span class="string">"historic task instance cannot be null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">   public <span class="keyword">void</span> deleteTaskMultiple(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, HistoricTaskInstance&gt; historicTaskInstanceMap, <span class="built_in">String</span> targetTaskId, <span class="built_in">String</span> targetTaskDefinitionKey, Task currentTask, <span class="built_in">List</span>&lt;Task&gt; taskList, <span class="built_in">String</span> targetParentTaskDefinitionKey) &#123;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(targetTaskDefinitionKey) || StringUtils.isBlank(targetTaskDefinitionKey)) &#123;</span><br><span class="line">           validatorTargetTask(historicTaskInstanceMap, targetTaskId);</span><br><span class="line">           targetTaskDefinitionKey = historicTaskInstanceMap.<span class="keyword">get</span>(targetTaskId).getTaskDefinitionKey();</span><br><span class="line">       &#125;</span><br><span class="line">       FlowNode targetNode = flowNodeMap.<span class="keyword">get</span>(targetTaskDefinitionKey);</span><br><span class="line">       ManagementService managementService = processEngine.getManagementService();</span><br><span class="line">       <span class="comment">//删除当前任务</span></span><br><span class="line">       managementService.executeCommand(<span class="keyword">new</span> DeleteTaskCmd(currentTask.getId()));</span><br><span class="line">       <span class="comment">// 删除当前运行的其他相同父任务的子任务</span></span><br><span class="line">       <span class="built_in">Set</span>&lt;Task&gt; sameParentTasks = getSameParentTasks(flowNodeMap, taskList, targetParentTaskDefinitionKey);</span><br><span class="line">       <span class="keyword">for</span> (Task task : sameParentTasks) &#123;</span><br><span class="line">           managementService.executeCommand(<span class="keyword">new</span> DeleteTaskCmd(task.getId()));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 流程执行到来源节点</span></span><br><span class="line">       managementService.executeCommand(<span class="keyword">new</span> SetFLowNodeAndGoCmd(targetNode, currentTask.getExecutionId()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">   public <span class="keyword">void</span> deleteTaskSingle(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap, <span class="built_in">String</span> targetTaskActivitiId, <span class="built_in">String</span> currentTaskId) &#123;</span><br><span class="line">       ManagementService managementService = processEngine.getManagementService();</span><br><span class="line">       FlowNode targetNode = flowNodeMap.<span class="keyword">get</span>(targetTaskActivitiId);</span><br><span class="line">       <span class="comment">// 删除当前运行任务</span></span><br><span class="line">       <span class="built_in">String</span> executionEntityId = managementService.executeCommand(<span class="keyword">new</span> DeleteTaskCmd(currentTaskId));</span><br><span class="line">       <span class="comment">// 流程执行到来源节点</span></span><br><span class="line">       managementService.executeCommand(<span class="keyword">new</span> SetFLowNodeAndGoCmd(targetNode, executionEntityId));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; queryParentFlowNode(<span class="built_in">String</span> activityId, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap) &#123;</span><br><span class="line">       <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; flowNodeList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">String</span> key : flowNodeMap.keySet()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!key.equals(activityId)) &#123;</span><br><span class="line">               FlowNode flowNode = flowNodeMap.<span class="keyword">get</span>(key);</span><br><span class="line">               <span class="built_in">List</span>&lt;SequenceFlow&gt; sequenceFlows = flowNode.getOutgoingFlows();</span><br><span class="line">               <span class="keyword">for</span> (SequenceFlow sequenceFlow : sequenceFlows) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (sequenceFlow.getTargetRef().equals(activityId)) &#123;</span><br><span class="line">                       flowNodeList.add(key);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flowNodeList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private <span class="built_in">Set</span>&lt;Task&gt; getSameParentTasks(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, FlowNode&gt; flowNodeMap, <span class="built_in">List</span>&lt;Task&gt; taskList, <span class="built_in">String</span> taskDefinitionKey) &#123;</span><br><span class="line">       <span class="keyword">if</span> (taskDefinitionKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(taskList);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">Set</span>&lt;Task&gt; tasks = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Task task : taskList) &#123;</span><br><span class="line">           <span class="built_in">List</span>&lt;SequenceFlow&gt; sequenceFlows = flowNodeMap.<span class="keyword">get</span>(task.getTaskDefinitionKey()).getIncomingFlows();</span><br><span class="line">           <span class="keyword">for</span> (SequenceFlow sequenceFlow : sequenceFlows) &#123;</span><br><span class="line">               <span class="keyword">if</span> (sequenceFlow.getSourceRef().equals(taskDefinitionKey)) &#123;</span><br><span class="line">                   tasks.add(task);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tasks;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">   public <span class="keyword">void</span> importBpmnFile(MultipartFile file, <span class="built_in">String</span> type, <span class="built_in">String</span> typeName) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           InputStream fileInputStream = file.getInputStream();</span><br><span class="line">           <span class="comment">//创建转换对象</span></span><br><span class="line">           BpmnXMLConverter bpmnXMLConverter = <span class="keyword">new</span> BpmnXMLConverter();</span><br><span class="line">           <span class="comment">//读取xml文件</span></span><br><span class="line">           XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();</span><br><span class="line">           XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(fileInputStream);</span><br><span class="line">           <span class="comment">//将xml文件转换成BpmnModel</span></span><br><span class="line">           BpmnModel bpmnModel = bpmnXMLConverter.convertToBpmnModel(xmlStreamReader);</span><br><span class="line">           bpmnModel.getMainProcess().setId(type);</span><br><span class="line">           bpmnModel.getMainProcess().setName(typeName);</span><br><span class="line">           Deployment deployment = repositoryService.createDeployment()</span><br><span class="line">                   .addBpmnModel(typeName + <span class="string">".bpmn"</span>, bpmnModel)</span><br><span class="line">                   .key(IdWorker.getIdStr())</span><br><span class="line">                   .deploy();</span><br><span class="line">           ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().deploymentId(deployment.getId()).singleResult();</span><br><span class="line">           BpmnModel model = repositoryService.getBpmnModel(processDefinition.getId());</span><br><span class="line">           <span class="keyword">if</span> (model != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Collection&lt;FlowElement&gt; flowElementCollection = model.getMainProcess().getFlowElements();</span><br><span class="line">               <span class="keyword">for</span> (FlowElement e : flowElementCollection) &#123;</span><br><span class="line">                   LOGGER.info(<span class="string">"flowelement id:"</span> + e.getId() + <span class="string">"  name:"</span> + e.getName() + <span class="string">"   class:"</span> + e.getClass().toString());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           activitiRepository.updateActReProcdef(processDefinition.getId());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           LOGGER.error(<span class="string">"导入流程定义失败:&#123;&#125;"</span>, e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/09/18/面试分享(七).操作系统相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/18/面试分享(七).操作系统相关/" itemprop="url">面试分享(七).操作系统相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-18T18:33:00+08:00">
                2019-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/18/面试分享(七).操作系统相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/09/18/面试分享(七).操作系统相关/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><h2 id="什么是socket，网络传输有哪几个层级"><a href="#什么是socket，网络传输有哪几个层级" class="headerlink" title="什么是socket，网络传输有哪几个层级"></a>什么是socket，网络传输有哪几个层级</h2><h3 id="什么是socket"><a href="#什么是socket" class="headerlink" title="什么是socket"></a>什么是socket</h3><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/6c224f4a20a446230b22bd709422720e0cf3d733.jpg" alt="image"></p>
<p>建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口;HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。</p>
<p>Socket的英文原义是”孔”或”插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。</p>
<p>Socket正如其英文原意那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。</p>
<h3 id="网络传输有哪几个层级"><a href="#网络传输有哪几个层级" class="headerlink" title="网络传输有哪几个层级"></a>网络传输有哪几个层级</h3><p>所谓的协议就是双方进行数据传输的一种格式。</p>
<p>网络中，一帧以太网数据包的格式：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/656312-e4cc3edef27a091d.png" alt="image"></p>
<table>
<thead>
<tr>
<th>层级</th>
<th>名称</th>
<th>包含的协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>应用层</td>
<td>例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>例如XDR、ASN.1、SMB、AFP、NCP</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>例如TCP、UDP、RTP、SCTP、SPX、ATP、IL</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>例如线路、无线电、光纤、信鸽</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>层级</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>应用层</td>
<td>文件传输，电子邮件，文件服务，虚拟终端</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>数据格式化，代码转换，数据加密</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>解除或建立与别的结点的联系</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>提供端对端的接口</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>为数据包选择路由</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>传输有地址的帧以及错误检测功能</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>以二进制数据形式在物理媒体上传输数据</td>
</tr>
</tbody>
</table>
<p>TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。</p>
<p>把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。(可以这样理解:TCP和UDP都是用来传输其他协议的)</p>
<p>而Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p>
<p>ip地址</p>
<p>每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。</p>
<p>Internet委员会定义了5种IP地址类型以适合不同容量的网络，即A类~E类。<br>其中A、B、C3类（如下表格）由InternetNIC在全球范围内统一分配，D、E类为特殊地址</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/656312-4926f3bcdcdc2369.png" alt="image"></p>
<h3 id="TIME-WAIT是什么状态还记得吗，什么情况下网络会出现这个状态"><a href="#TIME-WAIT是什么状态还记得吗，什么情况下网络会出现这个状态" class="headerlink" title="TIME_WAIT是什么状态还记得吗，什么情况下网络会出现这个状态"></a>TIME_WAIT是什么状态还记得吗，什么情况下网络会出现这个状态</h3><h4 id="出现原因分析"><a href="#出现原因分析" class="headerlink" title="出现原因分析"></a>出现原因分析</h4><p>TCP连接的终止<br>TCP建立一个连接至少需要交换三个分组，也因此称之为TCP的三路握手（three-way handshake），然而在TCP终止连接时，由于双方都需要发送一个FIN分节给对端确认，因此TCP终止连接一般是需要交换四个分节。具体来看： </p>
<p>1、 应用进程（active close）首先调用close，于是导致TCP发送一个FIN分节，表示数据已分送完毕，请求关闭套接字。 </p>
<p>2、 另一端应用进程（passive close）接受收到FIN，并由该端的TCP确认（确认的过程是TCP发送ACK分节给对端套接字）。FIN的接受也作为文件结束符传递给上层应用进程。这里的文件结束符并非应用进程的EOF，在TCP字节流中，EOF的读或写通过收发一个特殊的FIN分节来实现</p>
<p>3、 另端（passive close）应用进程在接受到文件束符后，会调用close关闭它的套接字，这导致该端的TCP也发送了一个FIN分节。 </p>
<p>4、 主动关闭端（active close）接受到这个FIN后，TCP对它进行确认。（TCP发送ACK分节，值得注意的是主动关闭端在未接受到FIN之前，它的状态就是TIME_WAIT）。 </p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/39ffa41f-7d9a-3b5f-b3c3-4dfd3605b121.gif" alt="image"></p>
<p>综上所述：<code>TIME_WAIT</code>状态出现场景是主动关闭端在未接受到FIN之前，它的状态就是<code>TIME_WAIT</code>。</p>
<h4 id="TCP为什么如此设计"><a href="#TCP为什么如此设计" class="headerlink" title="TCP为什么如此设计"></a>TCP为什么如此设计</h4><p>1。防止上一次连接中的包(特别是最后一个ACK包)，迷路后重新出现，影响新连接  （经过2MSL(max segment lifetime)，上一次连接中所有的重复包都会消失）。</p>
<p>2。可靠的关闭TCP连接  在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发<br>  fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以  主动方要处于 <code>TIME_WAIT</code> 状态，而不能是 CLOSED 。<code>TIME_WAIT</code> 并不会占用很大资源的，除非受到攻击。还有，如果一方 send 或 recv 超时，就会直接进入 CLOSED 状态。</p>
<h4 id="规避大量出现TIME-WAIT的方法"><a href="#规避大量出现TIME-WAIT的方法" class="headerlink" title="规避大量出现TIME_WAIT的方法"></a>规避大量出现TIME_WAIT的方法</h4><ul>
<li><code>net.ipv4.tcp_tw_reuse</code>和<code>net.ipv4.tcp_tw_recycle</code>的开启都是为了回收处于<code>TIME_WAIT</code>状态的资源。</li>
<li><code>net.ipv4.tcp_fin_timeout</code>这个时间可以减少在异常情况下服务器从<code>FIN-WAIT-2</code>转到<code>TIME_WAIT</code>的时间。</li>
<li><code>net.ipv4.tcp_keepalive_*</code>一系列参数，是用来设置服务器检测连接存活的相关配置。</li>
</ul>
<p>在服务器的日常维护过程中，会经常用到下面的命令：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk '/<span class="symbol">^tcp</span>/ &#123;++<span class="keyword">S</span>[<span class="built_in">$NF</span>]&#125; END &#123;<span class="keyword">for</span>(a in <span class="keyword">S</span>) <span class="keyword">print</span> a, <span class="keyword">S</span>[a]&#125;'</span><br></pre></td></tr></table></figure>
<p>它会显示例如下面的信息：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TIME_WAIT <span class="number">814</span></span><br><span class="line">CLOSE_WAIT <span class="number">1</span></span><br><span class="line">FIN_WAIT1 <span class="number">1</span></span><br><span class="line">ESTABLISHED <span class="number">634</span></span><br><span class="line">SYN_RECV <span class="number">2</span></span><br><span class="line">LAST_ACK <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>常用的三个状态是：<code>ESTABLISHED</code> 表示正在通信，<code>TIME_WAIT</code> 表示主动关闭，<code>CLOSE_WAIT</code> 表示被动关闭。</p>
<h4 id="三次握手的详细描述"><a href="#三次握手的详细描述" class="headerlink" title="三次握手的详细描述"></a>三次握手的详细描述</h4><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
<p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p>既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p>
<blockquote>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
</blockquote>
<p>在书中同时举了一个例子，如下：</p>
<blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
</blockquote>
<p>这就很明白了，防止了服务器端的一直等待而浪费资源。</p>
<h4 id="四次挥手的详细描述"><a href="#四次挥手的详细描述" class="headerlink" title="四次挥手的详细描述"></a>四次挥手的详细描述</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
<ol>
<li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；</li>
<li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；</li>
<li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入<code>CLOSE_WAIT</code>状态；</li>
<li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>
</ol>
<p>至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。</p>
<h4 id="为什么要四次分手"><a href="#为什么要四次分手" class="headerlink" title="为什么要四次分手"></a>为什么要四次分手</h4><p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<ul>
<li><code>FIN_WAIT_1</code>: 这个状态要好好解释一下，其实<code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：<code>FIN_WAIT_1</code>状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到<code>FIN_WAIT_1</code>状态。而当对方回应ACK报文后，则进入到<code>FIN_WAIT_2</code>状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以<code>FIN_WAIT_1</code>状态一般是比较难见到的，而<code>FIN_WAIT_2</code>状态还有时常常可以用netstat看到。（主动方）</li>
<li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上<code>FIN_WAIT_2</code>状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li>
<li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到<code>CLOSE_WAIT</code>状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在<code>CLOSE_WAIT</code>状态下，需要完成的事情是等待你去关闭连接。（被动方）</li>
<li><code>LAST_ACK</code>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li>
<li><code>TIME_WAIT</code>: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。（主动方）</li>
<li><code>CLOSED</code>: 表示连接中断。</li>
</ul>
<h2 id="哪些典型的应用用的是UDP？"><a href="#哪些典型的应用用的是UDP？" class="headerlink" title="哪些典型的应用用的是UDP？"></a>哪些典型的应用用的是UDP？</h2><h4 id="TCP应用"><a href="#TCP应用" class="headerlink" title="TCP应用"></a>TCP应用</h4><p>（1）FTP：文件传输协议；</p>
<p>（2）SSH：安全登录、文件传送(SCP)和端口重定向；</p>
<p>（3）Telnet：不安全的文本传送；</p>
<p>（4）SMTP：简单邮件传输协议Simple Mail Transfer Protocol (E-mail)；</p>
<p>（5）HTTP：超文本传送协议 (WWW)；</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/730e0cf3d7ca7bcb389cf0c8b0096b63f724a875.png" alt="image"></p>
<h4 id="UDP应用"><a href="#UDP应用" class="headerlink" title="UDP应用"></a>UDP应用</h4><p>（1）流媒体</p>
<p>采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议如WebRTC是极佳的选择。</p>
<p>（2）实时游戏</p>
<p>对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p>
<p>采用UDP的经典游戏如FPS游戏Quake、CS，著名的游戏引擎Unity3D采用的也是RakNet。</p>
<p>（3）物联网</p>
<p>2014年google旗下的Nest建立Thread Group，推出了物联网通信协议Thread，完善物联网通信。</p>
<p>全球将近50%的人都在使用互联网，人们不断的追求更快、更好的服务，一切都在变化，在越来越多的领域，UDP将会抢占TCP的主导地位。</p>
<p>（4）QQ 文件传输、QQ语音、QQ视频</p>
<p>对于网络通讯质量要求不高的情况下，要求网络通讯速度能尽量快捷方便，就可以使用UDP技术。</p>
<h2 id="内核态和用户态、cas-和-sout-哪个用到了内核态和用户态的切换"><a href="#内核态和用户态、cas-和-sout-哪个用到了内核态和用户态的切换" class="headerlink" title="内核态和用户态、cas 和 sout 哪个用到了内核态和用户态的切换"></a>内核态和用户态、cas 和 sout 哪个用到了内核态和用户态的切换</h2><p>究竟什么是用户态，什么是内核态，这两个基本概念以前一直理解得不是很清楚，根本原因个人觉得是在于因为大部分时候我们在写程序时关注的重点和着眼的角度放在了实现的功能和代码的逻辑性上，先看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfork</span><span class="params">()</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> = = fork())&#123;  </span><br><span class="line"></span><br><span class="line">         <span class="built_in">printf</span>(“create <span class="keyword">new</span> process success!\n”);  </span><br><span class="line"></span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(“testfork ok\n”);  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，从功能的角度来看，就是实际执行了一个fork()，生成一个新的进程，从逻辑的角度看，就是判断了如果fork()返回的是则打印相关语句，然后函数最后再打印一句表示执行完整个testfork()函数。代码的执行逻辑和功能上看就是如此简单，一共四行代码，从上到下一句一句执行而已，完全看不出来哪里有体现出用户态和进程态的概念。</p>
<p>如果说前面两种是静态观察的角度看的话，我们还可以从动态的角度来看这段代码，即它被转换成CPU执行的指令后加载执行的过程，这时这段程序就是一个动态执行的指令序列。而究竟加载了哪些代码，如何加载就是和操作系统密切相关了。</p>
<h3 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h3><p>熟悉Unix/Linux系统的人都知道，fork的工作实际上是以系统调用的方式完成相应功能的，具体的工作是由sys_fork负责实施。其实无论是不是Unix或者Linux，对于任何操作系统来说，创建一个新的进程都是属于核心功能，因为它要做很多底层细致地工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做，于是就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。</p>
<p>特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查，相关的概念有 CPL、DPL和RPL，这里不再过多阐述。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于 Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。</p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p>现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在级特权级上时，就可以称之为运行在内核态。</p>
<p>虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的<code>testfork()</code>就不能直接调用 <code>sys_fork()</code>，因为前者是工作在用户态，属于用户态程序，而<code>sys_fork()</code>是工作在内核态，属于内核态程序。</p>
<p>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发 sys_fork()的执行时，就切换到了内核态。</p>
<h4 id="用户态和内核态的转换"><a href="#用户态和内核态的转换" class="headerlink" title="用户态和内核态的转换"></a>用户态和内核态的转换</h4><p>1）用户态切换到内核态的3种方式</p>
<p>a. 系统调用</p>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>b. 异常             </p>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p>c. 外围设备的中断</p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>
<p>2）具体的切换操作</p>
<p>从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：</p>
<p>[1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>[2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个</p>
<p>过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一</p>
<p>条指令。</p>
<p>[3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始</p>
<p>执行中断处理程序，这时就转到了内核态的程序执行了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/08/18/面试分享(六).算法相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/面试分享(六).算法相关/" itemprop="url">面试分享(六).算法相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T18:33:00+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/18/面试分享(六).算法相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/08/18/面试分享(六).算法相关/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h1><ul>
<li>递归使用中有什么需要注意的地方，递归写法一般可以用什么去替换？</li>
<li>如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG230.png" alt="image"></li>
<li>设计一个发号器，考虑集群和高并发的情况，要求发号器生成的id是递增趋势，通过id可以区分出来是今天生成的id还是昨天生成的id，但是生成的id中不能直接带有日期，要具有一定的混淆功能，白纸写代码</li>
<li>一个二位数组，每个元素都可以往上下左右四个方向走，寻找最长递增路径。如下图所示，最长递增路径即红色字体路径。白纸写代码。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG231.png" alt="image"></li>
<li>反转链表，要求时间复杂度O(N)，空间复杂度O(1)  </li>
<li>非递归实现斐波那契数列 </li>
<li>这一周股市价格为[2,6,1,4,8]，求哪一天买入哪一天卖出，可获得最大收益，最大收益为多少</li>
<li>按照箭头方向查找二叉树<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG233.png" alt="image"></li>
<li>表a b c之间用ID关联，求阴影部分的数据<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG234.png" alt="image"></li>
<li>一个整形无序数组，里面三个数只和等于一个目标值，求这三个数</li>
<li>链表问题<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG235.png" alt="image"></li>
<li>扑克牌问题<br>有十张扑克牌，从上面开始抽，抽出一张放桌子上，然后再抽出一张放扑克牌的最下面，这样循环往复的操作，直到手里的牌都没有了。这时，桌子上牌的顺序正好是1 2 3 4 5 6 7 8 9 10。要求写代码求出原顺序</li>
<li>手写大顶堆</li>
<li>手写LRU 算法</li>
<li>字符串相加<br>两个数字类型的字符串，直接转int或者double肯定都放不下，然后求这两个数的和，返回值还是字符串，15分钟时间，要求无Bug</li>
<li>寻找目标值位置<br>有一个二维数组，数组横向有序，纵向有序，求目标值的位置，10分钟时间</li>
<li>求字符串“efabcbaefehiabcba”中最长的回文数，不去重</li>
<li>反转int类型的值x，不要借用String，只用int 即可。&amp;&amp; 针对该程序，写出其应有的测试用例</li>
<li>top K 问题</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/07/18/面试分享(五).相关工具使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/面试分享(五).相关工具使用/" itemprop="url">面试分享(五).相关工具使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T18:33:00+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/18/面试分享(五).相关工具使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/07/18/面试分享(五).相关工具使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关工具使用"><a href="#相关工具使用" class="headerlink" title="相关工具使用"></a>相关工具使用</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis-中有几种类型-amp-各自底层怎么实现的-amp-项目中哪个地方用了什么类型，怎么使用的？"><a href="#Redis-中有几种类型-amp-各自底层怎么实现的-amp-项目中哪个地方用了什么类型，怎么使用的？" class="headerlink" title="Redis 中有几种类型 &amp; 各自底层怎么实现的 &amp; 项目中哪个地方用了什么类型，怎么使用的？"></a>Redis 中有几种类型 &amp; 各自底层怎么实现的 &amp; 项目中哪个地方用了什么类型，怎么使用的？</h3><p><a href="https://blog.csdn.net/wcf373722432/article/details/78678504" target="_blank" rel="noopener">redis底层原理</a></p>
<ul>
<li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li>
<li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li>
</ul>
<p>1 单线程模型</p>
<p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p>
<p>2 单线程模型每秒万级别处理能力的原因</p>
<p>（1）纯内存访问。数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。</p>
<p>（2）非阻塞I/O，Redis采用epoll做为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。</p>
<p>（3）单线程避免了线程切换和竞态产生的消耗。</p>
<p>（4）Redis采用单线程模型，每条命令执行如果占用大量时间，会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库。</p>
<h4 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h4><p>字符串类型是Redis中最为基础的数据存储类型，是一个由字节组成的序列，他在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据货Json对象描述信息等，是标准的key-value，一般来存字符串，整数和浮点数。Value最多可以容纳的数据长度为512MB<br>应用场景：很常见的场景用于统计网站访问数量，当前在线人数等。incr命令(++操作)</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173355068-1009075048.png" alt="image"></p>
<h4 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h4><p>Redis的列表允许用户从序列的两端推入或者弹出元素，列表由多个字符串值组成的有序可重复的序列，是链表结构，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。List中可以包含的最大元素数量是4294967295。<br>应用场景：1.最新消息排行榜。2.消息队列，以完成多程序之间的消息交换。可以用push操作将任务存在list中（生产者），然后线程在用pop操作将任务取出进行执行。（消费者）</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173319896-1986145136.png" alt="image"></p>
<h4 id="散列hash"><a href="#散列hash" class="headerlink" title="散列hash"></a>散列hash</h4><p>Redis中的散列可以看成具有String key和String value的map容器，可以将多个key-value存储到一个key中。每一个Hash可以存储4294967295个键值对。<br>应用场景：例如存储、读取、修改用户属性（name，age，pwd等）</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173425803-1568128972.png" alt="image"></p>
<h4 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h4><p>Redis的集合是无序不可重复的，和列表一样，在执行插入和删除和判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集差集操作。Set可包含的最大元素数量是4294967295。<br>应用场景：1.利用交集求共同好友。2.利用唯一性，可以统计访问网站的所有独立IP。3.好友推荐的时候根据tag求交集，大于某个threshold（临界值的）就可以推荐。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173450459-219862735.png" alt="image"></p>
<h4 id="有序集合sorted-set"><a href="#有序集合sorted-set" class="headerlink" title="有序集合sorted set"></a>有序集合sorted set</h4><p>和set很像，都是字符串的集合，都不允许重复的成员出现在一个set中。他们之间差别在于有序集合中每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。尽管有序集合中的成员必须是卫衣的，但是分数(score)却可以重复。<br>应用场景：可以用于一个大型在线游戏的积分排行榜，每当玩家的分数发生变化时，可以执行zadd更新玩家分数(score)，此后在通过zrange获取几分top ten的用户信息。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173530318-1825724249.png" alt="image"></p>
<h4 id="key的通用操作"><a href="#key的通用操作" class="headerlink" title="key的通用操作"></a>key的通用操作</h4><p>所有的数据类型都可以使用的<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173804350-2060665680.png" alt="image"></p>
<h3 id="Redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在Redis中已经过期了，怎么解决这种问题？"><a href="#Redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在Redis中已经过期了，怎么解决这种问题？" class="headerlink" title="Redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在Redis中已经过期了，怎么解决这种问题？"></a>Redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在Redis中已经过期了，怎么解决这种问题？</h3><p>解决redis分布式锁过期时间到了业务没执行完问题</p>
<p>很多同学在用分布式锁时,都是直接百度搜索找一个Redis分布式锁工具类就直接用了，其实Redis分布式锁比较正确的姿势是采用redisson这个客户端工具</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190311091746328.jpg" alt="image"></p>
<p>默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗。</p>
<h4 id="Redisson分布式锁的底层原理"><a href="#Redisson分布式锁的底层原理" class="headerlink" title="Redisson分布式锁的底层原理"></a>Redisson分布式锁的底层原理</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190328230407942.jpg" alt="image"></p>
<p>1）加锁机制</p>
<p>咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。</p>
<p>这里注意，仅仅只是选择一台机器！这点很关键！</p>
<p>紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190328230720469.jpg" alt="image"></p>
<p>为啥要用lua脚本呢？</p>
<p>因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的原子性。</p>
<p>那么，这段lua脚本是什么意思呢？</p>
<p>KEYS[1]代表的是你加锁的那个key，比如说：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">RLock lock</span> = redisson.getLock(<span class="string">"myLock"</span>);</span><br></pre></td></tr></table></figure>
<p>这里你自己设置了加锁的那个锁key就是“myLock”。</p>
<p>ARGV[1]代表的就是锁key的默认生存时间，默认30秒。</p>
<p>ARGV[2]代表的是加锁的客户端的ID，类似于下面这样：</p>
<p><code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code></p>
<p>给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。</p>
<p>如何加锁呢？很简单，用下面的命令：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset myLock </span><br><span class="line">8743c9c0<span class="string">-0795</span><span class="string">-4907</span><span class="string">-87</span>fd<span class="string">-6</span>c719a6b4586:1 1</span><br></pre></td></tr></table></figure>
<p>通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190328230756937.jpg" alt="image"></p>
<p>上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。</p>
<p>接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。</p>
<p>好了，到此为止，ok，加锁完成了。</p>
<p>（2）锁互斥机制</p>
<p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？</p>
<p>很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。</p>
<p>接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p>
<p>所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。</p>
<p>此时客户端2会进入一个while循环，不停的尝试加锁。</p>
<p>（3）watch dog自动延期机制</p>
<p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p>
<p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p>
<p>（4）可重入加锁机制</p>
<p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？</p>
<p>比如下面这种代码：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190328231154539.png" alt="image"></p>
<p>这时我们来分析一下上面那段lua脚本。</p>
<p>第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。</p>
<p>第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code></p>
<p>此时就会执行可重入加锁的逻辑，他会用：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incrby myLock </span><br><span class="line"></span><br><span class="line"> 8743c9c0<span class="string">-0795</span><span class="string">-4907</span><span class="string">-87</span>fd<span class="string">-6</span>c71a6b4586:1 1</span><br></pre></td></tr></table></figure>
<p>通过这个命令，对客户端1的加锁次数，累加1。</p>
<p>此时myLock数据结构变为下面这样：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190328231220198.jpg" alt="image"><br>（5）释放锁机制</p>
<p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。</p>
<p>其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。</p>
<p>如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：</p>
<p>“del myLock”命令，从redis里删除这个key。</p>
<p>然后呢，另外的客户端2就可以尝试完成加锁了。</p>
<p>这就是所谓的分布式锁的开源Redisson框架的实现机制。</p>
<p>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</p>
<p>（6）上述Redis分布式锁的缺点</p>
<p>其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。</p>
<p>但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。</p>
<p>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。</p>
<p>此时就会导致多个客户端对一个分布式锁完成了加锁。</p>
<p>这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</p>
<p>所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。</p>
<h3 id="Ehcache支持哪些缓存？"><a href="#Ehcache支持哪些缓存？" class="headerlink" title="Ehcache支持哪些缓存？"></a>Ehcache支持哪些缓存？</h3><h4 id="Ehcache"><a href="#Ehcache" class="headerlink" title="Ehcache"></a>Ehcache</h4><p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。</p>
<p>优点：</p>
<ul>
<li>快速</li>
<li>简单</li>
<li>缓存数据有两级：内存和磁盘，因此无需担心容量问题</li>
<li>缓存数据会在虚拟机重启的过程中写入磁盘</li>
<li>可以通过RMI、可插入API等方式进行分布式缓存</li>
<li>具有缓存和缓存管理器的侦听接口</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域</li>
<li>提供Hibernate的缓存实现</li>
<li>多种缓存策略，Ehcache提供了对大数据的内存和硬盘的存储，最近版本允许多实例、保存对象高灵活性、提供LRU、LFU、FIFO淘汰算法，基础属性支持热配置、支持的插件多</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用磁盘Cache的时候非常占用磁盘空间；</li>
<li>不能保证数据的安全</li>
</ul>
<h4 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h4><p>memcache 是一种高性能、分布式对象缓存系统，最初设计于缓解动态网站数据库加载数据的延迟性，你可以把它想象成一个大的内存HashTable，就是一个key-value键值缓存。</p>
<p>memcache C语言所编写，依赖于最近版本的GCC和libevent。多线程支持</p>
<p>优点：</p>
<p>一.部分容灾</p>
<p>假设只用一台memcache，如果这台memcache服务器挂掉了，那么请求将不断的冲击数据库，这样有可能搞死数据库，从而引发”雪崩“。如果使用多台memcache服务器，由于memcache使用一致性哈希算法，万一其中一台挂掉了，部分请求还是可以在memcache中命中，为修复系统赢得一些时间。</p>
<p>二.容量问题</p>
<p>一台memcache服务器的容量毕竟有限，可以使用多台memcache服务器，增加缓存容量。</p>
<p>三.均衡请求</p>
<p>使用多台memcache服务器，可以均衡请求，避免所有请求都冲进一台memcache服务器，导致服务器挂掉。</p>
<p>四.利用memcache分布式特性</p>
<p>使用一台memcache服务器，并没有利用memcache的数据分布式特性。</p>
<p>缺点：</p>
<ul>
<li>不能持久化存储</li>
<li>存储数据有限制：1M 【大于1M，认为就行分割】（内存碎片）</li>
<li>mm存储数据只能key-value</li>
<li>集群数据没有复制和同步机制 【崩溃不会影响程序，会从数据库中取数据】</li>
<li>内存回收不能及时 LRU(算法)：未使用内存》过期内存》最近最少使用内存 这是惰性删除</li>
</ul>
<h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>单线程、读写性能优异、支持数据持久化，支持AOF和RDB两种持久化方式、支持主从复制，主机会自动将数据同步到从机，可以进行读写分离；数据结构丰富：除了支持string类型的value外还支持string、hash、set、sortedset、list等数据结构。</p>
<p>缺点：</p>
<p>1 Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</p>
<p>2 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</p>
<p>3 Redis的主从复制采用全量复制，复制过程中主机会fork出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一次全量的数据复制，这对实际的系统运营造成了不小的麻烦。</p>
<p>4 Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</p>
<p>ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。<br>redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。<br>如果是单个应用或者对缓存访问要求很高的应用，用ehcache。<br>如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。</p>
<h3 id="Redis是单线程的还是多线程的，为什么这么快？"><a href="#Redis是单线程的还是多线程的，为什么这么快？" class="headerlink" title="Redis是单线程的还是多线程的，为什么这么快？"></a>Redis是单线程的还是多线程的，为什么这么快？</h3><p>Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p>
<p>它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</p>
<p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p>
<p>Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p>
<p>Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p>
<p>数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</p>
<p>（1）硬盘数据库的工作模式：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20170307142145648.png" alt="image"><br>（2）内存数据库的工作模式：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20170307142210929.png" alt="image"></p>
<h4 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h4><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I/O复用模型，非阻塞IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p>
<p>（1）多路 I/O 复用模型</p>
<p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>
<p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>
<h4 id="那么为什么Redis是单线程的"><a href="#那么为什么Redis是单线程的" class="headerlink" title="那么为什么Redis是单线程的"></a>那么为什么Redis是单线程的</h4><p>我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p>
<p>看到这里，你可能会气哭！本以为会有什么重大的技术要点才使得Redis使用单线程就可以这么快，没想到就是一句官方看似糊弄我们的回答！但是，我们已经可以很清楚的解释了为什么Redis这么快，并且正是由于在单线程模式的情况下已经很快了，就没有必要在使用多线程了！</p>
<p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p>
<p>警告1：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程：</p>
<h3 id="Redis-Hash中某个key过大，变为String类型的大key，怎么处理，使用中如何避免出现这种问题"><a href="#Redis-Hash中某个key过大，变为String类型的大key，怎么处理，使用中如何避免出现这种问题" class="headerlink" title="Redis Hash中某个key过大，变为String类型的大key，怎么处理，使用中如何避免出现这种问题?"></a>Redis Hash中某个key过大，变为String类型的大key，怎么处理，使用中如何避免出现这种问题?</h3><p>由于redis是单线程运行的，如果一次操作的value很大会对整个redis的响应时间造成负面影响，所以，业务上能拆则拆，下面举几个典型的分拆方案。</p>
<h4 id="单个简单的key存储的value很大"><a href="#单个简单的key存储的value很大" class="headerlink" title="单个简单的key存储的value很大"></a>单个简单的key存储的value很大</h4><p>1.1、 改对象需要每次都整存整取<br>可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响； </p>
<p>1.2、该对象每次只需要存取部分数据<br>可以像第一种做法一样，分拆成几个key-value， 也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性 </p>
<h4 id="hash，-set，zset，list-中存储过多的元素"><a href="#hash，-set，zset，list-中存储过多的元素" class="headerlink" title="hash， set，zset，list 中存储过多的元素"></a>hash， set，zset，list 中存储过多的元素</h4><p>类似于场景一种的第一个做法，可以将这些元素分拆。</p>
<p>以hash为例，原先的正常存取流程是 <code>hget(hashKey, field)</code> ; <code>hset(hashKey, field, value)</code><br>现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newHashKey  =  hashKey + (<span class="name">*hash*</span>(<span class="name">field</span>) % <span class="number">10000</span>）<span class="comment">;   </span></span><br><span class="line">hset (<span class="name">newHashKey</span>, field, value) <span class="comment">;  </span></span><br><span class="line">hget(<span class="name">newHashKey</span>, field)</span><br></pre></td></tr></table></figure></p>
<p>set, zset, list 也可以类似上述做法.</p>
<p>但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。</p>
<h3 id="哨兵机制、Redis两种备份方式的区别，项目中用的哪种，为什么？"><a href="#哨兵机制、Redis两种备份方式的区别，项目中用的哪种，为什么？" class="headerlink" title="哨兵机制、Redis两种备份方式的区别，项目中用的哪种，为什么？"></a>哨兵机制、Redis两种备份方式的区别，项目中用的哪种，为什么？</h3><h4 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h4><p>　为了解决一旦断电或者宕机，内存数据库中的数据将会全部丢失这个缺点，Redis提供了将内存数据持久化到硬盘，以及用持久化文件来恢复数据的功能。Redis 支持两种形式的持久化，一种是RDB快照（snapshotting），另外一种是AOF（append-only-file）。<br>　<br>　（1）RDB是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里，RDB持久化有两种触发机制，分别是自动触发和手动触发。在redis.windows.conf(linux就是redis.conf)文件的SNAPSHOTTING 下有个自动触发rdb持久化的策略：<br>　<br>　<img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190712111253693.png" alt="image"><br>　其中分别表示900s内，如果至少有一个key值变化，则保存到rdb；300s内，至少有10个key变化就保存；60s内至少有10000个key变化就保存。如果只需要redis的缓存功能那么就可以关掉rdb持久化，使用空串停用，如：save “”“”。</p>
<p>在这个配置下面还有几个关于rdb持久化的配置：</p>
<ul>
<li><code>stop-writes-on-bgsave-error yes</code>：默认yes，表示在后台通过rdb保存数据失败之后是否停止向redis写入数据（接收数据）。这样可以让用户意识到后台持久化失败了，避免后面数据不能持久化。</li>
<li><code>rdbcompression yes</code>：默认yes，表示存储的rdb快照是否进行压缩存储，如果关闭则快照会比较大。</li>
<li><code>rdbchecksum yes</code>：默认yes，存储之后是否对数据进行校验，若希望提升redis性能可以关闭。</li>
<li><code>dbfilename dump.rdb</code>：存储的rdb快照文件名。</li>
<li><code>dir ./</code>：设置快照存放路径，必须是目录，默认和当前配置文件在同一目录。</li>
</ul>
<p>手动触发rdb快照保存可以使用save和bgsave命令。save会阻塞当前redis，redis不能处理其他命令直到rdb过程完成，而bgsave会在后台异步进行保存（redis会执行fork操作创建一个子进程），阻塞只会在fork短时间内，redis内部rdb自动保存都是采用bgsave命令。</p>
<p>将备份文件dump.rdb放到配置文件指定的目录（默认是和redis配置文件同一目录）下，启动redis就会自动将数据加载到内存中。</p>
<p>（2）AOF 持久化是通过保存Redis服务器所执行的写命令来记录数据库状态。在redis的配置文件中APPEND ONLY MODE的下有关于AOF持久化的相关配置。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190712113151519.png" alt="image"></p>
<ul>
<li><code>appendonly</code>：表示是否开启AOF持久化，因为redis默认的是rdb方式，打开aof需要改为yes。</li>
<li><code>appendfilename</code>：aof文件名。</li>
<li><code>appendsync</code>：aof持久化策略配置。no表示不执行fsync，有系统保证数据同步到磁盘，速度最快但不安全；always表示每次写入都要执行fsync，以保证数据完全同步到磁盘，效率低；everysec则是每秒保存一次，可能会丢失者1s数据，兼顾安全和效率。</li>
<li><code>no-appendfsync-on-rewrite</code>：设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。</li>
<li><code>auto-aof-rewrite-percentage</code>：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。</li>
<li><code>auto-aof-rewrite-min-size</code>：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。</li>
<li><code>aof-load-truncated</code>：aof文件可能在尾部是不完整的（宕机或者断电等），如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes</li>
</ul>
<p>AOF文件不完整需要恢复可以使用命令：redis-check-aof –fix 进行修复。aof文件过大的时候也需要重写，和rdb的bgsave模式相似，都是创建子进程，设置重写缓冲区，在重写完成之后再将缓冲区文件写入aof文件。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。</p>
<p>AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</p>
<p>AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。</p>
<p>对于具有相同数据的的 Redis，AOF 文件通常会比 RDB文件体积更大。</p>
<p>虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</p>
<p>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>复制三份配置文件，分别更改端口号，并且配置文件的名字以端口号区分。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190712115045340.png" alt="image"><br>之后再更改每份配置文件：rdb文件名（dbfilename）、log日志文件名（logfile），之后使用下面三个命令启动三个redis服务端。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server<span class="selector-class">.exe</span> redis<span class="selector-class">.windows</span><span class="selector-class">.conf</span></span><br><span class="line">redis-server<span class="selector-class">.exe</span> redis<span class="selector-class">.windows-10087</span><span class="selector-class">.conf</span> </span><br><span class="line">redis-server<span class="selector-class">.exe</span> redis<span class="selector-class">.windows-10088</span><span class="selector-class">.conf</span></span><br></pre></td></tr></table></figure></p>
<p>通过info replication查看各个节点信息。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190712133813784.png" alt="image"><br>此时都是master节点，接着设置slave节点。使用slaveof命令把10087和10088设为slave。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2019071213421423.png" alt="image"><br>此时设为slave节点之后再使用info replication命令查看就发现role已经变为了slave了。现再在master节点写，在slave读。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2019071213445880.png" alt="image"><br>可以看见现在主从关系已经成功建立了。注：</p>
<p>（1）如果master以前还存在一些key，那么slave节点也是会有的，因为master会全量复制到slave。</p>
<p>（2）默认从节点是不能够执行写命令的，配置文件中slave-read-only默认是yes。</p>
<p>（3）主节点down掉之后，另外两个slave角色依然不变，并且在master恢复之后，仍然是master并且有两个slave节点。</p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>哨兵模式就是不时地监控redis是否按照预期良好地运行（至少是保证主节点是存在的），若一台主机出现问题时，哨兵会自动将该主机下的某一个从机设置为新的主机，并让其他从机和新主机建立主从关系（如果监控主机发生故障，就根据投票数自动将从库转化为主库）。首先启动多个redis，并配置主从关系，下面再配置哨兵监控master。</p>
<p>（1）在配置文件目录下面使用touch命令新建sentinel.conf文件，然后配置内容：</p>
<p>sentinel monitor 被监控主机名（自己起） ip地址 端口 得票数 如<code>：sentinel monitor my6379 127.0.0.1 6379 1</code>。1表示当主机挂掉之后得票数&gt;=1便成为主机。</p>
<p>（2）启动哨兵监控</p>
<p>使用命令：<code>./redis-sentinel /mrliu_project/redis/sentinel.conf</code> 注：<code>/mrliu_project/redis/sentinel.conf</code> 是配置文件所在目录</p>
<p>（3）exit退出master主机，之后查看哨兵控制台打印的日志，会发现在重新选择master。</p>
<blockquote>
<p>在redis稳定版之后，挂掉的主机在选举之后重新连接上，会设置为新选举的msater的从节点。</p>
</blockquote>
<p>启动三台带有redis的服务器133，132，130<br>分别更改redis.conf文件，并指定配置启动redis-server和redis-sentinel</p>
<p>进入redis的src目录：<code>./redis-server</code> <code>../redis.config</code> <code>./redis-sentinel</code> <code>../sentinel.conf</code>(哨兵配置需要自己touch)</p>
<p>133启动一个master和哨兵的服务器，</p>
<p>132启动两个redis服务(两份配置文件)，分别设为133的slave</p>
<p>130启动一个redis服务，设为133的slave</p>
<p>redis-config更改了一些目录和端口等，我大概改了如下内容：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">logfile</span> </span><br><span class="line"><span class="string">port</span> </span><br><span class="line"> <span class="comment">#bind.1 注释掉了</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">no</span> <span class="string">//关闭了</span></span><br></pre></td></tr></table></figure></p>
<p>注意（出现设置了slaveof之后发现主机一直未down可能是如下原因）：</p>
<p>（1）每个启动的redis服务需要注释掉bind(代表可以访问的主机)，不然其他redis服务器不能感知到该redis服务的存在</p>
<p> (2)每个redis服务需要更改protected-mode 为no，</p>
<p>（3）每台linux服务器需要打开端口，不然直接关闭firewall或者是iptables也行，命令systemctl stop firewalld和service iptables stop。 永久关闭防火墙使用disable。</p>
<p>（4）建议redis-server都配置为守护进程，daemon设为yes即可。</p>
<p>哨兵需要自建配置文件，在redis的src目录下使用 <code>./redis-sentinel ../sentinel_liu.conf</code> 启动，其中后面的是自己的哨兵配置文件，简易配置如下:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">26379</span></span><br><span class="line"> </span><br><span class="line">sentinel monitor liu_master <span class="number">192.168</span><span class="number">.15</span><span class="number">.130</span> <span class="number">6379</span> <span class="number">1</span><span class="comment">//监控的主机，后面代表超过机票就成为leader</span></span><br><span class="line">sentinel down-after-milliseconds liu_master <span class="number">10000</span><span class="comment">//可选，多久没心跳就认为down</span></span><br><span class="line">sentinel failover-timeout liu_master <span class="number">10000</span><span class="comment">//可选，代表每次选举间隔</span></span><br></pre></td></tr></table></figure></p>
<p>几台服务器如下:<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190822113301779.png" alt="image"><br>之后进入133使用info确认从节点有三个，</p>
<p>之后查看哨兵启动日志<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190822113645587.png" alt="image"><br>注：sdown代表哨兵主观任务下线，（后面是master断开之后的日志）odown是客观下线，当出现odown的时候，哨兵将不会监控该服务，任务确实下线了，然后开始选举。</p>
<p><strong>断开133的master，观察哨兵日志</strong><br>可以进入133的客户端，使用shutdown关掉，也可以在redis的src目录下使用./redis-cli shutdown关，也可以杀redis进程关。</p>
<p>哨兵日志如下（我这儿选了这么多次原因是其他机器防火墙开着，所以关了就选举成功了）:<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190822114009994.png" alt="image"></p>
<p>出现failover-end即是选举成功了，switch代表切换master到了130服务器节点，随后发现 +fix-slave-config日志，代表将132的6379redis服务和132的6380redis服务设为了130的slave节点，这时候130成为master，132的两个redis服务是slave节点。</p>
<p><strong>重新上线之前断开的133master，查看哨兵日志</strong></p>
<p>发现新上线的133设为了130redis服务的slave，下面去130服务器登上redis客户端输入info验证</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2019082211453965.png" alt="image"></p>
<p>发现回归后的master变为了新选举的master的slave节点。</p>
<h3 id="哨兵机制、选举算法"><a href="#哨兵机制、选举算法" class="headerlink" title="哨兵机制、选举算法"></a>哨兵机制、选举算法</h3><p>Redis Sentinel是一个分布式系统，为Redis提供高可用性解决方案。可以在一个架构中运行多个 Sentinel 进程(progress)， 这些进程使用流言协议(gossip protocols)来 接收关于主服务器是否下线的信息， 并使用投票协议(agreement protocols)来决定是否执行自动故 障迁移， 以及选择哪个从服务器作为新的主服务器。</p>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器(instance) 该系统执行以下三个任务:</p>
<ul>
<li>监控(Monitoring): Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒(Notification): 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移(Automaticfailover): 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中 一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器; 当客 户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主 服务器代替失效服务器。</li>
</ul>
<h4 id="Sentinel-工作原理分析"><a href="#Sentinel-工作原理分析" class="headerlink" title="Sentinel 工作原理分析"></a>Sentinel 工作原理分析</h4><p>（1）哨兵文件详解</p>
<p> 配置一：<code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code></p>
<p> 这个配置表达的是 哨兵节点定期监控 名字叫做 <code>&lt;master-name&gt;</code>  并且 IP 为 <code>&lt;ip&gt;</code> 端口号为 <code>&lt;port&gt;</code> 的主节点。<code>&lt;quorum&gt;</code> 表示的是哨兵判断主节点是否发生故障的票数。也就是说如果我们将<code>&lt;quorum&gt;</code>设置为2就代表至少要有两个哨兵认为主节点故障了，才算这个主节点是客观下线的了，一般是设置为sentinel节点数的一半加一。</p>
<p>配置二：<code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;times&gt;</code></p>
<p> 每个哨兵节点会定期发送ping命令来判断Redis节点和其余的哨兵节点是否是可达的，如果超过了配置的<code>&lt;times&gt;</code>时间没有收到pong回复，就主观判断节点是不可达的,<code>&lt;times&gt;</code>的单位为毫秒。</p>
<p>配置三：<code>sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code></p>
<p> 当哨兵节点都认为主节点故障时，哨兵投票选出的leader会进行故障转移，选出新的主节点，原来的从节点们会向新的主节点发起复制，这个配置就是控制在故障转移之后，每次可以向新的主节点发起复制的节点的个数，最多为<code>&lt;nums&gt;</code>个，因为如果不加控制会对主节点的网络和磁盘IO资源很大的开销。</p>
<p>配置四：<code>sentinel failover-timeout &lt;master-name&gt;  &lt;times&gt;</code></p>
<p> 这个代表哨兵进行故障转移时如果超过了配置的<code>&lt;times&gt;</code>时间就表示故障转移超时失败。</p>
<p>配置五： <code>sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code></p>
<p> 如果主节点设置了密码，则需要这个配置，否则哨兵无法对主节点进行监控。</p>
<p>（2）为什么要用到哨兵</p>
<p>哨兵(Sentinel)主要是为了解决在主从复制架构中出现宕机的情况,主要分为两种情况:</p>
<p>1).从Redis宕机</p>
<p>这个相对而言比较简单,在Redis中从库重新启动后会自动加入到主从架构中,自动完成同步数据。在Redis2.8版本后,主从断线后恢复<br>的情况下实现增量复制。</p>
<p>2).主Redis宕机</p>
<p>这个相对而言就会复杂一些,需要以下2步才能完成</p>
<p>a. 在从数据库中执行SLAVEOF NO ONE命令,断开主从关系并且提升为主库继续服务</p>
<p>b. 第二步,将主库重新启动后,执行SLAVEOF命令,将其设置为其他库的从库,这时数据就能更新回来</p>
<p>由于这个手动完成恢复的过程其实是比较麻烦的并且容易出错,所以Redis提供的哨兵(sentinel)的功能来解决</p>
<p>（3）哨兵机制（sentinel）的高可用<br>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506151546683-1575264043.png" alt="image"></p>
<p>在Server1 掉线后：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506151713821-882289333.png" alt="image"></p>
<p>升级Server2 为新的主服务器：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506151845249-976936123.png" alt="image"></p>
<p>（4）哨兵的定时监控</p>
<p>任务1：每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506152235025-339114870.png" alt="image"></p>
<p>任务2：每个哨兵节点每隔2秒会向redis数据节点的指定频道上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断，其实就是通过消息publish和subscribe来完成的</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506152337815-746306143.png" alt="image"></p>
<p>任务3：每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测，这个也是哨兵用来判断节点是否正常的重要依据</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506152441725-1928086557.png" alt="image"></p>
<p>主观下线：所谓主观下线，就是单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。</p>
<p>sentinel会以每秒一次的频率向所有与其建立了命令连接的实例（master，从服务，其他sentinel）发ping命令，通过判断ping回复是有效回复，还是无效回复来判断实例时候在线（对该sentinel来说是“主观在线”）。</p>
<p>sentinel配置文件中的down-after-milliseconds设置了判断主观下线的时间长度，如果实例在down-after-milliseconds毫秒内，返回的都是无效回复，那么sentinel回认为该实例已（主观）下线，修改其flags状态为SRI_S_DOWN。如果多个sentinel监视一个服务，有可能存在多个sentinel的down-after-milliseconds配置不同，这个在实际生产中要注意。</p>
<p>客观下线：当主观下线的节点是主节点时，此时该哨兵3节点会通过指令sentinel is-masterdown-by-addr寻求其它哨兵节点对主节点的判断，如果其他的哨兵也认为主节点主观线下了，则当认为主观下线的票数超过了quorum（选举）个数，此时哨兵节点则认为该主节点确实有问题，这样就客观下线了，大部分哨兵节点都同意下线操作，也就说是客观下线<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506155733210-1331107316.png" alt="image"></p>
<p>（5）哨兵lerder选举流程</p>
<p>如果主节点被判定为客观下线之后，就要选取一个哨兵节点来完成后面的故障转移工作，选举出一个leader的流程如下:</p>
<p>a)每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，会向其它哨兵发is-master-down-by-addr命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；</p>
<p>b)当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；</p>
<p>c)如果哨兵3发现自己在选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举…………</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506155956342-1186812006.png" alt="image"></p>
<p>（6）自动故障转移机制</p>
<p>在从节点中选择新的主节点</p>
<p>sentinel状态数据结构中保存了主服务的所有从服务信息，领头sentinel按照如下的规则从从服务列表中挑选出新的主服务</p>
<ul>
<li>过滤掉主观下线的节点 </li>
<li>选择slave-priority最高的节点，如果由则返回没有就继续选择</li>
<li>选择出复制偏移量最大的系节点，因为复制便宜量越大则数据复制的越完整，如果由就返回了，没有就继续</li>
<li>选择run_id最小的节点<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506160701394-131033031.png" alt="image"></li>
</ul>
<p>更新主从状态</p>
<p>通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。</p>
<p> 将已下线的主节点设置成新的主节点的从节点，当其回复正常时，复制新的主节点，变成新的主节点的从节点<br>同理，当已下线的服务重新上线时，sentinel会向其发送slaveof命令，让其成为新主的从</p>
<h4 id="Sentinel获取服务器信息"><a href="#Sentinel获取服务器信息" class="headerlink" title="Sentinel获取服务器信息"></a>Sentinel获取服务器信息</h4><p>（1） Sentinel获取主服务器信息</p>
<p>　　　　Sentinel默认会以每10秒一次的频率，通过命令连接向主服务器发送info命令，通过分析info命令的回复来获取主服务器的当前信息，就像在上篇讲到的复制功能，在客户端输入info replication 命令一样，Sentinel可以获取以下两方面的信息：</p>
<p>　　　　(1) 关于主服务器本身的信息，包括服务器run_id，role的服务器角色。</p>
<p>　　　　(2) 关于所有从服务器的信息，每个从服务器都由一个slave字符串开头的行记录，记录了从服务器IP和端口(主服务器中有从库的配置信息)。</p>
<p>（2）Sentinel获取从服务器信息</p>
<p>　　　　当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构(sentinelRedisInstance)之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。Sentinel默认会以每10秒一次的频率通过命令连接从服务器发送info命令，通过分析info命令的回复来获取从服务器的当前信息。包括:从服务器运行run_ID、从服务器角色role、主服务器的ip及端口、主从服务器的连接状态master_link_status、从服务器的优先级slave_priority。</p>
<p> （3）Sentinel向主从服务器发送信息</p>
<p> 　　　　在默认情况下, Sentinel会以每2秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506170747983-891987765.png" alt="image"><br>　这条命令向服务器的<em>sentinel</em>:hello频道发送了一条信息，信息的内容由多个参数组成：</p>
<p>　　　　(1) 以s_开头以参数记录的是sentinel本身的信息。</p>
<p>　　　　(2) 而m_开头的参数记录的则是主服务器的信息，如果sentinel正在监视的是主服务器，那么这些参数就是主服务器的信息，如果sentinel正在监视的是从服务器，那么这些参数记录就是从服务器正在复制的主服务器的信息。
　　　　
　　　　</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_ip</td>
<td>Sentinel的ip地址</td>
</tr>
<tr>
<td>S_port</td>
<td>Sentinel的端口号</td>
</tr>
<tr>
<td>S_runid</td>
<td>Sentinel的运行ID</td>
</tr>
<tr>
<td>S_epoch</td>
<td>Sentinel 的当前配置纪元</td>
</tr>
<tr>
<td>m_name</td>
<td>主服务器的名字</td>
</tr>
<tr>
<td>M_ip</td>
<td>主服务器的IP地址</td>
</tr>
<tr>
<td>M_port</td>
<td>主服务器的端口号</td>
</tr>
<tr>
<td>M_epoch</td>
<td>主服务器的当前配置纪元</td>
</tr>
</tbody>
</table>
<p>以下是一条sentinel通过publish命令向主服务器发送的信息示例：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506164653763-1864655064.png" alt="image"></p>
<p>这个示例中sentinel的ip地址为172.0.0.1端口号为26379, 运行ID为后面一串，当前纪元为0。主服务器的名字为mymaster,ip地址为127.0.0.1,端口号为6379, 当前纪元为0。</p>
<p>4）sentinel接收来自主服务器和从服务器的频道信息</p>
<p>　　　　当sentinel与一个主服务器或者从服务器建立起订阅连接之后,Sentinel就会通过订阅连接，向服务器发送以下命令：<code>subscribe_sentinel_:hello</code> 。对于每个与Sentinel连接的服务器，Sentinel既通过命令连向服务器的<code>_sentinel_:hello</code>频道发送信息，又通过订阅连接从服务器的<code>_sentinel_:hello</code>频道接收信息。</p>
<p>　　　　当有三个sentinel，分别是sentinel1、sentinel2 、sentinel3。三个sentinel在监视同一个服务器，那么当sentinel1向服务器的<code>_sentinel_:hello</code>频道发送一条信息时，所有订阅了<code>_sentinel_:hello</code>频道的sentinel(包括sentinel1自己在内)都会收到这条信息。</p>
<p>　　　　当一个sentinel从<code>_sentinel_:hello</code>频道收到一条信息时，sentinel会对这条信息进行分析，提取出信息中sentinel 的 ip 、port、runID等8个参数，并进行以下检查：</p>
<p>　　　　(1) 如果信息中记录的sentinel运行ID和接收信息的sentinel运行ID相同，那么说明这条信息是sentinel自己发送的，sentinel将丢弃这条信息，不做进一步处理。</p>
<p>　　　　(2) 相反地，如果信息中记录的sentinel运行ID和接收信息的sentinel运行ID不相同，那说明这条信息监视同一个服务器的其它sentinel发来的，接收信息的sentinel将根据信息中的参数，对相应主服务器的实例结构进行更新。</p>
<p> （5）sentinel更新自己的sentinels字典<br>　　　　sentinel为主服务器创建实例结构中的sentinels字典，保存了sentinel本身，还监视这个主服务器的其他sentinel的资料。当一个sentinel接收到其他sentinels发来的信息时，接收的sentinel会从信息中分析并提取出两方面参数:</p>
<p>　　　　(1)与sentinel有关的参数，包括sentinel的ip、port、runid、配置纪元。</p>
<p>　　　　(2)与主服务器有关的参数, 包括监视主服务器的ip、port、runid、配置纪元。</p>
<p>　　　　假设分别有三个sentinel: 127.0.0.1:26379、127.0.0.1:26380、127.0.0.1:26381。三个sentinel正在监视主服务器127.0.0.1:6379, 那么当127.0.0.1:26379这个sentinel接收到以下消息时：<br>　　　　<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506163455227-1906082072.png" alt="image"></p>
<p>这个sentinel将执行以下动作：</p>
<p>　　　　(1) 第一条信息发送者为自己，信息忽略。</p>
<p>　　　　(2) 第二条信息发送者为26381, sentinel会根据信息提取出内容，对sentinels字典中26381对应的实例结构进行更新。</p>
<p>　　　　(3) 第三条信息发送者为23680，同样更新字典中的23680对应的实例结构。</p>
<p>　　　　每个sentinel都有自己的一个sentinels字典， 对于26379的sentinel它的sentinels字典信息保存了26380和26381两个sentinel信息。其它sentinel也一样。<br>　　　　<br>（6）sentinel创建连向其他sentinel的命令连接</p>
<p>　　　　当sentinel通过频道信息发现一个新的sentinel时，不仅更新sentinels字典，还会创建一个连向sentinel命令连接，而新的sentinel也会创建连向这个sentinel的命令连接，最终监视同一个主服务器的多个sentinel将形成相互连接的网络。如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506163243221-854536312.png" alt="image"></p>
<p>4.Sentinel的工作原理总结</p>
<p> 1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</p>
<p> 2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 </p>
<p> 3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </p>
<p> 4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</p>
<p> 5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。</p>
<p> 6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。</p>
<p> 7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </p>
<p> 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="如何保证RocketMQ-消息的顺序性，如何解决重复消费问题。"><a href="#如何保证RocketMQ-消息的顺序性，如何解决重复消费问题。" class="headerlink" title="如何保证RocketMQ 消息的顺序性，如何解决重复消费问题。"></a>如何保证RocketMQ 消息的顺序性，如何解决重复消费问题。</h3><p>分布式消息系统作为实现分布式系统可扩展、可伸缩性的关键组件，需要具有高吞吐量、高可用等特点。而谈到消息系统的设计，就回避不了两个问题：</p>
<ul>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ul>
<p>RocketMQ作为阿里开源的一款高性能、高吞吐量的消息中间件，它是怎样来解决这两个问题的？RocketMQ有哪些关键特性？其实现原理是怎样的？</p>
<p>关键特性及其实现原理</p>
<h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p>消息有序指的是可以按照消息的发送顺序来消费。例如：一笔订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照顺序依次消费才有意义。与此同时多笔订单之间又是可以并行消费的。首先来看如下示例：</p>
<p>假如生产者产生了2条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0818e67d14dc4a09ba046f4c92094917_th.jpeg" alt="image"></p>
<p>你可能会采用这种方式保证消息顺序</p>
<p>假定M1发送到S1，M2发送到S2，如果要保证M1先于M2被消费，那么需要M1到达消费端被消费后，通知S2，然后S2再将M2发送到消费端。</p>
<p>这个模型存在的问题是，如果M1和M2分别发送到两台Server上，就不能保证M1先达到MQ集群，也不能保证M1被先消费。换个角度看，如果M2先于M1达到MQ集群，甚至M2被消费后，M1才达到消费端，这时消息也就乱序了，说明以上模型是不能保证消息的顺序的。如何才能在MQ集群保证消息的顺序？一种简单的方式就是将M1、M2发送到同一个Server上：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/fc2bc23834e4455d882487b14c3f287e_th.png" alt="image"></p>
<p>保证消息顺序，你改进后的方法</p>
<p>这样可以保证M1先于M2到达MQServer（生产者等待M1发送成功后再发送M2），根据先达到先被消费的原则，M1会先于M2被消费，这样就保证了消息的顺序。</p>
<p>这个模型也仅仅是理论上可以保证消息的顺序，在实际场景中可能会遇到下面的问题：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/f36a6e83f4b640f88a54c6f800ac6140_th.png" alt="image"></p>
<p>网络延迟问题</p>
<p>只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送M1耗时大于发送M2的耗时，那么M2就仍将被先消费，仍然不能保证消息的顺序。即使M1和M2同时到达消费端，由于不清楚消费端1和消费端2的负载情况，仍然有可能出现M2先于M1被消费的情况。</p>
<p>那如何解决这个问题？将M1和M2发往同一个消费者，且发送M1后，需要消费端响应成功后才能发送M2。</p>
<p>聪明的你可能已经想到另外的问题：如果M1被发送到消费端后，消费端1没有响应，那是继续发送M2呢，还是重新发送M1？一般为了保证消息一定被消费，肯定会选择重发M1到另外一个消费端2，就如下图所示。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/a19132aff6024e5cadd9ff5bb3da0595_th.jpeg" alt="image"></p>
<p>保证消息顺序的正确姿势</p>
<p>这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端1没有响应Server时有两种情况，一种是M1确实没有到达(数据在网络传送中丢失)，另外一种消费端已经消费M1且已经发送响应消息，只是MQ Server端没有收到。如果是第二种情况，重发M1，就会造成M1被重复消费。也就引入了我们要说的第二个问题，消息重复问题，这个后文会详细讲解。</p>
<p>回过头来看消息顺序问题，严格的顺序消息非常容易理解，也可以通过文中所描述的方式来简单处理。总结起来，要实现严格的顺序消息，简单且可行的办法就是：</p>
<p>保证生产者 - MQServer - 消费者是一对一对一的关系</p>
<p>这样的设计虽然简单易行，但也会存在一些很严重的问题，比如：</p>
<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li>
</ul>
<p>但我们的最终目标是要集群的高容错性和高吞吐量。这似乎是一对不可调和的矛盾，那么阿里是如何解决的？</p>
<p>世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！</p>
<p>有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。从这个角度来看消息的顺序问题，我们可以得出两个结论：</p>
<ul>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序</li>
</ul>
<p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是不是我们应该寻求的一种更合理的方式？</p>
<p>最后我们从源码角度分析RocketMQ怎么实现发送顺序消息的。</p>
<p>RocketMQ通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。比如下面的示例中，订单号相同的消息会被先后发送到同一个队列中：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/4bdaf71241734f4082e2fb58288deea1_th.png" alt="image"><br>在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/04e532402dfd4928803ec7b7a3e28458_th.png" alt="image"></p>
<h4 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h4><p>上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。</p>
<p>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p>消费端处理消息的业务逻辑保持幂等性</p>
<p>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</p>
<p>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</p>
<p>第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。</p>
<h5 id="那么如何解决消息重复投递的问题？"><a href="#那么如何解决消息重复投递的问题？" class="headerlink" title="那么如何解决消息重复投递的问题？"></a>那么如何解决消息重复投递的问题？</h5><p>以我们支付宝转账到余额宝为例，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加2万而不是1万了(上面讲顺序消费是讲过，这里再提一下)。</p>
<p>为什么相同的消息会被重复投递？比如余额宝处理完消息msg后，发送了处理成功的消息给支付宝，正常情况下支付宝应该要删除消息msg，但如果支付宝这时候悲剧的挂了，重启后一看消息msg还在，就会继续发送消息msg。</p>
<p>解决方法很简单，在余额宝这边增加消息应用状态表（message_apply）（这就是上文说的去重表吧），通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务） 。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each msg <span class="keyword">in</span><span class="built_in"> queue </span></span><br><span class="line"> </span><br><span class="line">Begin transaction </span><br><span class="line"> </span><br><span class="line">  select count(*) as cnt <span class="keyword">from</span> message_apply where <span class="attribute">msg_id</span>=msg.msg_id; </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> <span class="attribute">cnt</span>==0 then </span><br><span class="line"> </span><br><span class="line">    update B <span class="builtin-name">set</span> <span class="attribute">amount</span>=amount+10000 where <span class="attribute">userId</span>=1; </span><br><span class="line"> </span><br><span class="line">    insert into message_apply(msg_id) values(msg.msg_id); </span><br><span class="line"> </span><br><span class="line">End transaction </span><br><span class="line"> </span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></p>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ除了支持普通消息，顺序消息，另外还支持事务消息。首先讨论一下什么是事务消息以及支持事务消息的必要性。我们以一个转帐的场景为例来说明这个问题：Bob向Smith转账100块。</p>
<p>在单机环境下，执行事务的情况，大概是下面这个样子：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/71a6eae6558e40f2b716e287d2366cd4.png" alt="image"></p>
<p>单机环境下转账事务示意图</p>
<p>当用户增长到一定程度，Bob和Smith的账户及余额信息已经不在同一台服务器上了，那么上面的流程就变成了这样：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/91d61404bbb04736ac801f37266d584d.jpeg" alt="image"><br>集群环境下转账事务示意图</p>
<p>这时候你会发现，同样是一个转账的业务，在集群环境下，耗时居然成倍的增长，这显然是不能够接受的。那如何来规避这个问题？</p>
<p>大事务 = 小事务 + 异步</p>
<p>将大事务拆分成多个小事务异步执行。这样基本上能够将跨机事务的执行效率优化到与单机一致。转账的事务就可以分解成如下两个小事务：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/280154e1893e413db9c40e36f522688e_th.jpeg" alt="image"><br>小事务+异步消息</p>
<p>图中执行本地事务（Bob账户扣款）和发送异步消息应该保证同时成功或者同时失败，也就是扣款成功了，发送消息一定要成功，如果扣款失败了，就不能再发送消息。那问题是：我们是先扣款还是先发送消息呢？</p>
<p>首先看下先发送消息的情况，大致的示意图如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/6cb4f66c5afb43eaa2e485c5d0b60a49_th.jpeg" alt="image"></p>
<p>事务消息：先发送消息</p>
<p>存在的问题是：如果消息发送成功，但是扣款失败，消费端就会消费此消息，进而向Smith账户加钱。</p>
<p>先发消息不行，那就先扣款吧，大致的示意图如下：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c63941056fe94a348a30dc2463caf186_th.jpeg" alt="image"><br>事务消息-先扣款</p>
<p>存在的问题跟上面类似：如果扣款成功，发送消息失败，就会出现Bob扣钱了，但是Smith账户未加钱。</p>
<p>可能大家会有很多的方法来解决这个问题，比如：直接将发消息放到Bob扣款的事务中去，如果发送失败，抛出异常，事务回滚。这样的处理方式也符合“恰好”不需要解决的原则。在<a href="https://blog.csdn.net/yinni11/article/details/81122093中的非事务消息中间件就是采用的这种方法" target="_blank" rel="noopener">https://blog.csdn.net/yinni11/article/details/81122093中的非事务消息中间件就是采用的这种方法</a></p>
<p>这里需要说明一下：如果使用Spring来管理事物的话，大可以将发送消息的逻辑放到本地事物中去，发送消息失败抛出异常，Spring捕捉到异常后就会回滚此事物，以此来保证本地事物与发送消息的原子性。</p>
<p>RocketMQ支持事务消息，下面来看看RocketMQ是怎样来实现的。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/ed14eabe547e42588bf6e8606a64553f_th.jpeg" alt="image"><br>RocketMQ实现发送事务消息</p>
<p>RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。</p>
<p>细心的你可能又发现问题了，如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认，Bob的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<p>那我们来看下RocketMQ源码，是如何处理事务消息的。客户端发送事务消息的部分（完整代码请查看：rocketmq-example工程下的com.alibaba.rocketmq.example.transaction.TransactionProducer）：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/d42a1f2bba2648058450df7154f3bcad_th.jpeg" alt="image"><br>接着查看sendMessageInTransaction方法的源码，总共分为3个阶段：发送Prepared消息、执行本地事务、发送确认消息。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20837a4e8bd64356b211f857c6e2d290_th.png" alt="image"><br>endTransaction方法会将请求发往broker(mq server)去更新事务消息的最终状态：</p>
<ul>
<li>根据sendResult找到Prepared消息 ，sendResult包含事务消息的ID</li>
<li>根据localTransaction更新消息的最终状态</li>
</ul>
<p>如果endTransaction方法执行失败，数据没有发送到broker，导致事务消息的 状态更新失败，broker会有回查线程定时（默认1分钟）扫描每个存储事务状态的表格文件，如果是已经提交或者回滚的消息直接跳过，如果是prepared状态则会向Producer发起CheckTransaction请求，Producer会调用DefaultMQProducerImpl.checkTransactionState()方法来处理broker的定时回调请求，而checkTransactionState会调用我们的事务设置的决断方法来决定是回滚事务还是继续执行，最后调用endTransactionOneway让broker来更新消息的最终状态。</p>
<p>再回到转账的例子，如果Bob的账户的余额已经减少，且消息已经发送成功，Smith端开始消费这条消息，这个时候就会出现消费失败和消费超时两个问题，解决超时问题的思路就是一直重试，直到消费端消费消息成功，整个过程中有可能会出现消息重复的问题，按照前面的思路解决即可。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/e111cda6fc964e0389da7fbd42175928_th.jpeg" alt="image"><br>消费事务消息</p>
<p>这样基本上可以解决消费端超时问题，但是如果消费失败怎么办？阿里提供给我们的解决方法是：人工解决。大家可以考虑一下，按照事务的流程，因为某种原因Smith加款失败，那么需要回滚整个流程。如果消息系统要实现这个回滚流程的话，系统复杂度将大大提升，且很容易出现Bug，估计出现Bug的概率会比消费失败的概率大很多。这也是RocketMQ目前暂时没有解决这个问题的原因，在设计实现消息系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，这也是大家在解决疑难问题时需要多多思考的地方。</p>
<p>20160321补充：在3.2.6版本中移除了事务消息的实现，所以此版本不支持事务消息，具体情况请参考rocketmq的issues：</p>
<h4 id="Producer如何发送消息"><a href="#Producer如何发送消息" class="headerlink" title="Producer如何发送消息"></a>Producer如何发送消息</h4><p>Producer轮询某topic下的所有队列的方式来实现发送方的负载均衡，如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/88780089598541bbbcc602da9d7494a8_th.png" alt="image"></p>
<p>producer发送消息负载均衡</p>
<p>首先分析一下RocketMQ的客户端发送消息的源码：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2d9ab52fe1e94d0a99bc8523bd8ca1a1_th.jpeg" alt="image"><br>在整个应用生命周期内，生产者需要调用一次start方法来初始化，初始化主要完成的任务有：</p>
<ol>
<li>如果没有指定namesrv地址，将会自动寻址</li>
<li>启动定时任务：更新namesrv地址、从namsrv更新topic路由信息、清理已经挂掉的broker、向所有broker发送心跳…</li>
<li>启动负载均衡的服务</li>
</ol>
<p>初始化完成后，开始发送消息，发送消息的主要代码如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/313fdaa1964640f193da2fce673773ae_th.png" alt="image"></p>
<p>代码中需要关注的两个方法tryToFindTopicPublishInfo和selectOneMessageQueue。前面说过在producer初始化时，会启动定时任务获取路由信息并更新到本地缓存，所以tryToFindTopicPublishInfo会首先从缓存中获取topic路由信息，如果没有获取到，则会自己去namesrv获取路由信息。selectOneMessageQueue方法通过轮询的方式，返回一个队列，以达到负载均衡的目的。</p>
<p>如果Producer发送消息失败，会自动重试，重试的策略：</p>
<ol>
<li>重试次数 &lt; retryTimesWhenSendFailed（可配置）</li>
<li>总的耗时（包含重试n次的耗时） &lt; sendMsgTimeout（发送消息时传入的参数）</li>
<li>同时满足上面两个条件后，Producer会选择另外一个队列发送消息</li>
</ol>
<h4 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h4><p>RocketMQ的消息存储是由consume queue和commit log配合完成的。</p>
<h5 id="Consume-Queue"><a href="#Consume-Queue" class="headerlink" title="Consume Queue"></a>Consume Queue</h5><p>consume queue是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commit log上的位置。</p>
<p>我们可以在配置中指定consumequeue与commitlog存储的目录</p>
<p>每个topic下的每个queue都有一个对应的consumequeue文件，比如：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/b9d346319a074ab781f72c5e0a1ae8f5.png" alt="image"></p>
<p>Consume Queue文件组织，如图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/f7c9a71cce0545358507496a03806ba0.png" alt="image"></p>
<p>Consume Queue文件组织示意图</p>
<ol>
<li>根据topic和queueId来组织文件，图中TopicA有两个队列0,1，那么TopicA和QueueId=0组成一个ConsumeQueue，TopicA和QueueId=1组成另一个ConsumeQueue。</li>
<li>按照消费端的GroupName来分组重试队列，如果消费端消费失败，消息将被发往重试队列中，比如图中的%RETRY%ConsumerGroupA。</li>
<li>按照消费端的GroupName来分组死信队列，如果消费端消费失败，并重试指定次数后，仍然失败，则发往死信队列，比如图中的%DLQ%ConsumerGroupA。</li>
</ol>
<p>死信队列（Dead Letter Queue）一般用于存放由于某种原因无法传递的消息，比如处理失败或者已经过期的消息。</p>
<p>Consume Queue中存储单元是一个20字节定长的二进制数据，顺序写顺序读，如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/f5690b5d29304b048e2079bda73cd48f.png" alt="image"></p>
<p>consumequeue文件存储单元格式</p>
<ol>
<li>CommitLog Offset是指这条消息在Commit Log文件中的实际偏移量</li>
<li>Size存储中消息的大小</li>
<li>Message Tag HashCode存储消息的Tag的哈希值：主要用于订阅时消息过滤（订阅时如果指定了Tag，会根据HashCode来快速查找到订阅的消息）</li>
</ol>
<h5 id="Commit-Log"><a href="#Commit-Log" class="headerlink" title="Commit Log"></a>Commit Log</h5><p>CommitLog：消息存放的物理文件，每台broker上的commitlog被本机所有的queue共享，不做任何区分。</p>
<p>文件的默认位置如下，仍然可通过配置文件修改：</p>
<p><code>${user.home} store${commitlog}${fileName}</code></p>
<p>CommitLog的消息存储单元长度不固定，文件顺序写，随机读。消息的存储结构如下表所示，按照编号顺序以及编号对应的内容依次存储。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/93fecfed6a8b4ee99a60482514ae3b26_th.jpeg" alt="image"></p>
<p>Commit Log存储单元结构图</p>
<h5 id="消息存储实现"><a href="#消息存储实现" class="headerlink" title="消息存储实现"></a>消息存储实现</h5><p>消息存储实现，比较复杂，也值得大家深入了解，后面会单独成文来分析(目前正在收集素材)，这小节只以代码说明一下具体的流程。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/918cf67691cd4ad395f0f5e90f2a1da7_th.jpeg" alt="image"></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/a3be14c9234c49f29ce2447ed61df899_th.png" alt="image"></p>
<h5 id="消息的索引文件"><a href="#消息的索引文件" class="headerlink" title="消息的索引文件"></a>消息的索引文件</h5><p>如果一个消息包含key值的话，会使用IndexFile存储消息索引，文件的内容结构如图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/7be0f86310834ed89c999fd1aa8d024f_th.png" alt="image"></p>
<p>消息索引</p>
<p>索引文件主要用于根据key来查询消息的，流程主要是：</p>
<ol>
<li>根据查询的 key 的 hashcode%slotNum 得到具体的槽的位置(slotNum 是一个索引文件里面包含的最大槽的数目，例如图中所示 slotNum=5000000)</li>
<li>根据 slotValue(slot 位置对应的值)查找到索引项列表的最后一项(倒序排列,slotValue 总是指向最新的一个索引项)</li>
<li>遍历索引项列表返回查询时间范围内的结果集(默认一次最大返回的 32 条记录)</li>
</ol>
<h4 id="消息订阅"><a href="#消息订阅" class="headerlink" title="消息订阅"></a>消息订阅</h4><p>RocketMQ消息订阅有两种模式，一种是Push模式，即MQServer主动向消费端推送；另外一种是Pull模式，即消费端在需要时，主动到MQServer拉取。但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式。</p>
<p>首先看下消费端的负载均衡：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/19384b17d8a344ca83294c58f28c6bfd_th.png" alt="image"><br>消费端负载均衡</p>
<p>消费端会通过RebalanceService线程，10秒钟做一次基于topic下的所有队列负载：</p>
<ol>
<li>遍历Consumer下的所有topic，然后根据topic订阅所有的消息</li>
<li>获取同一topic和Consumer Group下的所有Consumer</li>
<li>然后根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费端配置等</li>
</ol>
<p>如同上图所示：如果有 5 个队列，2 个 consumer，那么第一个 Consumer 消费 3 个队列，第二 consumer 消费 2 个队列。这里采用的就是平均分配策略，它类似于分页的过程，TOPIC下面的所有queue就是记录，Consumer的个数就相当于总的页数，那么每页有多少条记录，就类似于某个Consumer会消费哪些队列。</p>
<p>通过这样的策略来达到大体上的平均消费，这样的设计也可以很方便的水平扩展Consumer来提高消费能力。</p>
<p>消费端的Push模式是通过长轮询的模式来实现的，就如同下图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/a551bcd8b42c40b4a92545f3aab0f781.png" alt="image"></p>
<p>Push模式示意图</p>
<p>Consumer端每隔一段时间主动向broker发送拉消息请求，broker在收到Pull请求后，如果有消息就立即返回数据，Consumer端收到返回的消息后，再回调消费者设置的Listener方法。如果broker在收到Pull请求时，消息队列里没有数据，broker端会阻塞请求直到有数据传递或超时才返回。</p>
<p>当然，Consumer端是通过一个线程将阻塞队列<code>LinkedBlockingQueue&lt;PullRequest&gt;</code>中的PullRequest发送到broker拉取消息，以防止Consumer一致被阻塞。而Broker端，在接收到Consumer的PullRequest时，如果发现没有消息，就会把PullRequest扔到ConcurrentHashMap中缓存起来。broker在启动时，会启动一个线程不停的从ConcurrentHashMap取出PullRequest检查，直到有数据返回。</p>
<h4 id="RocketMQ的其他特性"><a href="#RocketMQ的其他特性" class="headerlink" title="RocketMQ的其他特性"></a>RocketMQ的其他特性</h4><p>前面的6个特性都是基本上都是点到为止，想要深入了解，还需要大家多多查看源码，多多在实际中运用。当然除了已经提到的特性外，RocketMQ还支持：</p>
<ul>
<li>定时消息</li>
<li>消息的刷盘策略</li>
<li>主动同步策略：同步双写、异步复制</li>
<li>海量消息堆积能力</li>
<li>高效通信</li>
<li>…….</li>
</ul>
<p>其中涉及到的很多设计思路和解决方法都值得我们深入研究：</p>
<ul>
<li>消息的存储设计：既要满足海量消息的堆积能力，又要满足极快的查询效率，还要保证写入的效率。</li>
<li>高效的通信组件设计：高吞吐量，毫秒级的消息投递能力都离不开高效的通信。</li>
<li>…….</li>
</ul>
<p>RocketMQ最佳实践</p>
<p>一、Producer最佳实践</p>
<ul>
<li>一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。</li>
<li>每个消息在业务层面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。</li>
<li>消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。</li>
<li>对于消息不可丢失应用，务必要有消息重发机制。例如：消息发送失败，存储到数据库，能有定时程序尝试重发或者人工触发重发。</li>
<li>某些应用如果不关注消息是否发送成功，请直接使用sendOneWay方法发送消息。</li>
</ul>
<p>二、Consumer最佳实践</p>
<ul>
<li>消费过程要做到幂等（即消费端去重）</li>
<li>尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。</li>
<li>优化每条消息消费过程</li>
</ul>
<p>三、其他配置</p>
<p>线上应该关闭autoCreateTopicEnable，即在配置文件中将其设置为false。</p>
<p>RocketMQ在发送消息时，会首先获取路由信息。如果是新的消息，由于MQServer上面还没有创建对应的Topic，这个时候，如果上面的配置打开的话，会返回默认TOPIC的（RocketMQ会在每台broker上面创建名为TBW102的TOPIC）路由信息，然后Producer会选择一台Broker发送消息，选中的broker在存储消息时，发现消息的topic还没有创建，就会自动创建topic。后果就是：以后所有该TOPIC的消息，都将发送到这台broker上，达不到负载均衡的目的。</p>
<p>所以基于目前RocketMQ的设计，建议关闭自动创建TOPIC的功能，然后根据消息量的大小，手动创建TOPIC。</p>
<p>RocketMQ设计相关</p>
<p>RocketMQ的设计假定：</p>
<ul>
<li>每台PC机器都可能宕机不可服务</li>
<li>任意集群都有可能处理能力不足</li>
<li>最坏的情况一定会发生</li>
<li>内网环境需要低延迟来提供最佳用户体验</li>
</ul>
<p>RocketMQ的关键设计：</p>
<ul>
<li>分布式集群化</li>
<li>强数据安全</li>
<li>海量数据堆积</li>
<li>毫秒级投递延迟（推拉模式）</li>
</ul>
<p>这是RocketMQ在设计时的假定前提以及需要到达的效果。我想这些假定适用于所有的系统设计。随着我们系统的服务的增多，每位开发者都要注意自己的程序是否存在单点故障，如果挂了应该怎么恢复、能不能很好的水平扩展、对外的接口是否足够高效、自己管理的数据是否足够安全…… 多多规范自己的设计，才能开发出高效健壮的程序。</p>
<h3 id="Kafka-如何保证消息顺序消费、在consumer-group-中新增一个consumer-会提高消费消息的速度吗、那如果我想提高消息消费的速度，我要怎么办？"><a href="#Kafka-如何保证消息顺序消费、在consumer-group-中新增一个consumer-会提高消费消息的速度吗、那如果我想提高消息消费的速度，我要怎么办？" class="headerlink" title="Kafka 如何保证消息顺序消费、在consumer group 中新增一个consumer  会提高消费消息的速度吗、那如果我想提高消息消费的速度，我要怎么办？"></a>Kafka 如何保证消息顺序消费、在consumer group 中新增一个consumer  会提高消费消息的速度吗、那如果我想提高消息消费的速度，我要怎么办？</h3><p>Kafka是一种分布式的，基于发布/订阅的消息系统。主要设计目标如下：</p>
<ul>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，并保证即使对TB级以上数据也能保证常数时间的访问性能</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输</li>
<li>支持Kafka Server间的消息分区，及分布式消息消费，同时保证每个partition内的消息顺序传输</li>
<li>同时支持离线数据处理和实时数据处理</li>
</ul>
<h4 id="为什么要用Message-Queue"><a href="#为什么要用Message-Queue" class="headerlink" title="为什么要用Message Queue"></a>为什么要用Message Queue</h4><ul>
<li>解耦 <ul>
<li>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息队列在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束</li>
</ul>
</li>
<li>冗余 <ul>
<li>有时在处理数据的时候处理过程会失败。除非数据被持久化，否则将永远丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在被许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理过程明确的指出该消息已经被处理完毕，确保你的数据被安全的保存直到你使用完毕。</li>
</ul>
</li>
<li>扩展性 <ul>
<li>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的；只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</li>
</ul>
</li>
<li>灵活性 &amp; 峰值处理能力 <ul>
<li>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住增长的访问压力，而不是因为超出负荷的请求而完全崩溃。</li>
</ul>
</li>
<li>可恢复性 <ul>
<li>当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。而这种允许重试或者延后处理请求的能力通常是造就一个略感不便的用户和一个沮丧透顶的用户之间的区别。</li>
</ul>
</li>
<li>送达保证 <ul>
<li>消息队列提供的冗余机制保证了消息能被实际的处理，只要一个进程读取了该队列即可。在此基础上，IronMQ提供了一个”只送达一次”保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。这之所以成为可能，是因为获取一个消息只是”预定”了这个消息，暂时把它移出了队列。除非客户端明确的表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后可再次被处理。</li>
</ul>
</li>
<li>顺序保证 <ul>
<li>在许多情况下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。IronMO保证消息浆糊通过FIFO（先进先出）的顺序来处理，因此消息在队列中的位置就是从队列中检索他们的位置。</li>
</ul>
</li>
<li>缓冲 <ul>
<li>在任何重要的系统中，都会有需要不同的处理时间的元素。例如,加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行—写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。</li>
</ul>
</li>
<li>理解数据流 <ul>
<li>在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是个巨大的挑战。消息系列通过消息被处理的频率，来方便的辅助确定那些表现不佳的处理过程或领域，这些地方的数据流都不够优化。</li>
</ul>
</li>
<li>异步通信 <ul>
<li>很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列中放入多少消息就放多少，然后在你乐意的时候再去处理它们。</li>
</ul>
</li>
</ul>
<h4 id="常用Message-Queue对比"><a href="#常用Message-Queue对比" class="headerlink" title="常用Message Queue对比"></a>常用Message Queue对比</h4><ul>
<li>RabbitMQ <ul>
<li>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</li>
</ul>
</li>
<li>Redis <ul>
<li>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</li>
</ul>
</li>
<li>ZeroMQ <ul>
<li>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演了这个服务角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果down机，数据将会丢失。其中，Twitter的Storm中默认使用ZeroMQ作为数据流的传输。</li>
</ul>
</li>
<li>ActiveMQ <ul>
<li>ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</li>
</ul>
</li>
<li>Kafka/Jafka <ul>
<li>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式Publish/Subscribe消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现复杂均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制来统一了在线和离线的消息处理，这一点也是本课题所研究系统所看重的。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</li>
</ul>
</li>
</ul>
<h4 id="Kafka解析"><a href="#Kafka解析" class="headerlink" title="Kafka解析"></a>Kafka解析</h4><p>Terminology</p>
<ul>
<li>Broker <ul>
<li>Kafka集群包含一个或多个服务器，这种服务器被称为broker</li>
</ul>
</li>
<li>Topic <ul>
<li>每条发布到Kafka集群的消息都有一个类别，这个类别被称为topic。（物理上不同topic的消息分开存储，逻辑上一个topic的消息虽然保存于一个或多个broker上但用户只需指定消息的topic即可生产或消费数据而不必关心数据存于何处）</li>
</ul>
</li>
<li>Partition <ul>
<li>parition是物理上的概念，每个topic包含一个或多个partition，创建topic时可指定parition数量。每个partition对应于一个文件夹，该文件夹下存储该partition的数据和索引文件</li>
</ul>
</li>
<li>Producer <ul>
<li>负责发布消息到Kafka broker</li>
</ul>
</li>
<li>Consumer <ul>
<li>消费消息。每个consumer属于一个特定的consuer group（可为每个consumer指定group name，若不指定group name则属于默认的group）。使用consumer high level API时，同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息。</li>
</ul>
</li>
</ul>
<h4 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-1.jpg" alt="image"></p>
<p>如上图所示，一个典型的kafka集群中包含若干producer（可以是web前端产生的page view，或者是服务器日志，系统CPU、memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干consumer group，以及一个Zookeeper 集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在consumer group发生变化时进行rebalance。producer使用push模式将消息发布到broker，consumer使用pull模式从broker订阅并消费消息。</p>
<h5 id="Push-vs-Pull"><a href="#Push-vs-Pull" class="headerlink" title="Push vs. Pull"></a>Push vs. Pull</h5><p>作为一个messaging system，Kafka遵循了传统的方式，选择由producer向broker push消息并由consumer从broker pull消息。一些logging-centric system，比如Facebook的 Scribe 和Cloudera的 Flume ,采用非常不同的push模式。事实上，push模式和pull模式各有优劣。</p>
<p>push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</p>
<h5 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h5><p>Topic在逻辑上可以被认为是一个在的queue，每条消费都必须指定它的topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以水平扩展，物理上把topic分成一个或多个partition，每个partition在物理上对应一个文件夹，该文件夹下存储这个partition的所有消息和索引文件。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-2.jpg" alt="image"></p>
<p>每个日志文件都是“log entries”序列，每一个 log entry 包含一个4字节整型数（值为N），其后跟N个字节的消息体。每条消息都有一个当前partition下唯一的64字节的offset，它指明了这条消息的起始位置。磁盘上存储的消费格式如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message <span class="built_in">length</span> ： <span class="number">4</span> <span class="keyword">bytes</span> (<span class="built_in">value</span>: <span class="number">1</span>+<span class="number">4</span>+n)</span><br><span class="line"></span><br><span class="line">“magic” <span class="built_in">value</span> ： <span class="number">1</span> <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">crc ： <span class="number">4</span> <span class="keyword">bytes</span></span><br><span class="line"></span><br><span class="line">payload ： n <span class="keyword">bytes</span></span><br></pre></td></tr></table></figure>
<p>这个“log entries”并非由一个文件构成，而是分成多个segment，每个segment名为该segment第一条消息的offset和“.kafka”组成。另外会有一个索引文件，它标明了每个segment下包含的 log entry 的offset范围，如下图所示。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-3.jpg" alt="image"></p>
<p>因为每条消息都被append到该partition中，是顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-4.jpg" alt="image"></p>
<p>每一条消息被发送到broker时，会根据paritition规则选择被存储到哪一个partition。如果partition规则设置的合理，所有消息可以均匀分布到不同的partition里，这样就实现了水平扩展。（如果一个topic对应一个文件，那这个文件所在的机器I/O将会成为这个topic的性能瓶颈，而partition解决了这个问题）。在创建topic时可以在<code>$KAFKA_HOME/config/server.properties</code> 中指定这个partition的数量(如下所示)，当然也可以在topic创建之后去修改parition数量。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#The default number of log partitions per topic. More partitions allow greater</span></span><br><span class="line"><span class="comment">#parallelism for consumption, but this will also result in more files across</span></span><br><span class="line"><span class="comment">#the brokers.</span></span><br><span class="line">num.<span class="attribute">partitions</span>=3</span><br></pre></td></tr></table></figure>
<p>在发送一条消息时，可以指定这条消息的key，producer根据这个key和partition机制来判断将这条消息发送到哪个parition。paritition机制可以通过指定<code>producer的paritition. class</code>这一参数来指定，该class必须实现 <code>kafka.producer.Partitioner</code> 接口。本例中如果key可以被解析为整数则将对应的整数与partition总数取余，该消息会被发送到该数对应的partition。（每个parition都会有个序号）<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kafka.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> kafka.utils.VerifiableProperties;</span><br><span class="line"><span class="keyword">public</span> class JasonPartitioner&lt;T&gt; implements Partitioner &#123;</span><br><span class="line">  <span class="keyword">public</span> JasonPartitioner(VerifiableProperties verifiableProperties) &#123;&#125;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> partition(<span class="keyword">Object</span> <span class="built_in">key</span>, <span class="built_in">int</span> numPartitions) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">int</span> partitionNum = Integer.parseInt((<span class="keyword">String</span>) <span class="built_in">key</span>);</span><br><span class="line">      <span class="keyword">return</span> Math.<span class="built_in">abs</span>(Integer.parseInt((<span class="keyword">String</span>) <span class="built_in">key</span>) % numPartitions);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> Math.<span class="built_in">abs</span>(<span class="built_in">key</span>.hashCode() % numPartitions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将上例中的class作为partition.class，并通过如下代码发送20条消息（key分别为0，1，2，3）至topic2（包含4个partition）。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> sendMessage() <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">　　<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">　　      List messageList = <span class="keyword">new</span> ArrayList&lt;KeyedMessage&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;&gt;();</span><br><span class="line">　　      <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++）&#123;</span><br><span class="line">　　          messageList.<span class="built_in">add</span>(<span class="keyword">new</span> KeyedMessage&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;(<span class="string">"topic2"</span>, j+<span class="string">""</span>, <span class="string">"The "</span> + i + <span class="string">" message for key "</span> + j));</span><br><span class="line">　　      &#125;</span><br><span class="line">　　      producer.send(messageList);</span><br><span class="line">    &#125;</span><br><span class="line">　　producer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则key相同的消息会被发送并存储到同一个partition里，而且key的序号正好和partition序号相同。（partition序号从0开始，本例中的key也正好从0开始）。如下图所示。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-5.jpg" alt="image"></p>
<p>对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略去删除旧数据。一是基于时间，二是基于partition文件大小。例如可以通过配置<code>$KAFKA_HOME/config/server.properties</code> ，让Kafka删除一周前的数据，也可通过配置让Kafka在partition文件超过1GB时删除旧数据，如下所示。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#####Log Retention Policy###</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">##</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#he following configurations control the disposal of log segments. The policy can</span></span><br><span class="line"><span class="comment">#be set to delete segments after a period of time, or after a given size has accumulated.</span></span><br><span class="line"><span class="comment">#A segment will be deleted whenever *either* of these criteria are met. Deletion always happens</span></span><br><span class="line"><span class="comment">#from the end of the log.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#The minimum age of a log file to be eligible for deletion</span></span><br><span class="line">log.retention.hours=<span class="number">168</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#A size-based retention policy for logs. Segments are pruned from the log as long as the remaininsegments don't drop below log.retention.bytes.</span></span><br><span class="line"><span class="comment">#log.retention.bytes=1073741824</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></span><br><span class="line">log.segment.bytes=<span class="number">1073741824</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#The interval at which log segments are checked to see if they can be deleted according</span></span><br><span class="line"><span class="comment">#to the retention policies</span></span><br><span class="line">log.retention.check.interval.ms=<span class="number">300000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#By default the log cleaner is disabled and the log retention policy will default to </span></span><br><span class="line"><span class="comment">#just delete segments after their retention expires.</span></span><br><span class="line"><span class="comment">#If log.cleaner.enable=true is set the cleaner will be enabled and individual logs </span></span><br><span class="line"><span class="comment">#can then be marked for log compaction.</span></span><br><span class="line">log.cleaner.enable=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>这里要注意，因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除文件与Kafka性能无关，选择怎样的删除策略只与磁盘以及具体的需求有关。另外，Kafka会为每一个consumer group保留一些metadata信息—当前消费的消息的position，也即offset。这个offset由consumer控制。正常情况下consumer会在消费完一条消息后线性增加这个offset。当然，consumer也可将offset设成一个较小的值，重新消费一些消息。因为offet由consumer控制，所以Kafka broker是无状态的，它不需要标记哪些消息被哪些consumer过，不需要通过broker去保证同一个consumer group只有一个consumer能消费某一条消息，因此也就不需要锁机制，这也为Kafka的高吞吐率提供了有力保障。</p>
<h5 id="Replication-amp-Leader-election"><a href="#Replication-amp-Leader-election" class="headerlink" title="Replication &amp; Leader election"></a>Replication &amp; Leader election</h5><p>Kafka从0.8开始提供partition级别的replication，replication的数量可在<code>$KAFKA_HOME/config/server.properties</code>中配置。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default<span class="selector-class">.replication</span><span class="selector-class">.factor</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>该 Replication与leader election配合提供了自动的failover机制。replication对Kafka的吞吐率是有一定影响的，但极大的增强了可用性。默认情况下，Kafka的replication数量为1。 每个partition都有一个唯一的leader，所有的读写操作都在leader上完成，leader批量从leader上pull数据。一般情况下partition的数量大于等于broker的数量，并且所有partition的leader均匀分布在broker上。follower上的日志和其leader上的完全一样。</p>
<p>和大部分分布式系统一样，Kakfa处理失败需要明确定义一个broker是否alive。对于Kafka而言，Kafka存活包含两个条件，一是它必须维护与Zookeeper的session(这个通过Zookeeper的heartbeat机制来实现)。二是follower必须能够及时将leader的writing复制过来，不能“落后太多”。</p>
<p>leader会track“in sync”的node list。如果一个follower宕机，或者落后太多，leader将把它从”in sync” list中移除。这里所描述的“落后太多”指follower复制的消息落后于leader后的条数超过预定值，该值可在 <code>$KAFKA_HOME/config/server.properties</code> 中配置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#If a replica falls more than this many messages behind the leader, the leader will remove the follower from ISR and treat it as dead</span></span><br><span class="line">replica.lag.max.<span class="attribute">messages</span>=4000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#If a follower hasn't sent any fetch requests for this window of time, the leader will remove the follower from ISR (in-sync replicas) and treat it as dead</span></span><br><span class="line">replica.lag.time.max.<span class="attribute">ms</span>=10000</span><br></pre></td></tr></table></figure></p>
<p>需要说明的是，Kafka只解决”fail/recover”，不处理“Byzantine”（“拜占庭”）问题。</p>
<p>一条消息只有被“in sync” list里的所有follower都从leader复制过去才会被认为已提交。这样就避免了部分数据被写进了leader，还没来得及被任何follower复制就宕机了，而造成数据丢失（consumer无法消费这些数据）。而对于producer而言，它可以选择是否等待消息commit，这可以通过<code>request.required.acks</code> 来设置。这种机制确保了只要“in sync” list有一个或以上的flollower，一条被commit的消息就不会丢失。</p>
<p>这里的复制机制即不是同步复制，也不是单纯的异步复制。事实上，同步复制要求“活着的”follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率（高吞吐率是Kafka非常重要的一个特性）。而异步复制方式下，follower异步的从leader复制数据，数据只要被leader写入log就被认为已经commit，这种情况下如果follwer都落后于leader，而leader突然宕机，则会丢失数据。而Kafka的这种使用“in sync” list的方式则很好的均衡了确保数据不丢失以及吞吐率。follower可以批量的从leader复制数据，这样极大的提高复制性能（批量写磁盘），极大减少了follower与leader的差距（前文有说到，只要follower落后leader不太远，则被认为在“in sync” list里）。</p>
<p>上文说明了Kafka是如何做replication的，另外一个很重要的问题是当leader宕机了，怎样在follower中选举出新的leader。因为follower可能落后许多或者crash了，所以必须确保选择“最新”的follower作为新的leader。一个基本的原则就是，如果leader不在了，新的leader必须拥有原来的leader commit的所有消息。这就需要作一个折衷，如果leader在标明一条消息被commit前等待更多的follower确认，那在它die之后就有更多的follower可以作为新的leader，但这也会造成吞吐率的下降。</p>
<p>一种非常常用的选举leader的方式是“majority 灵秀”（“少数服从多数”），但Kafka并未采用这种方式。这种模式下，如果我们有2f+1个replica（包含leader和follower），那在commit之前必须保证有f+1个replica复制完消息，为了保证正确选出新的leader，fail的replica不能超过f个。因为在剩下的任意f+1个replica里，至少有一个replica包含有最新的所有消息。这种方式有个很大的优势，系统的latency只取决于最快的几台server，也就是说，如果replication factor是3，那latency就取决于最快的那个follower而非最慢那个。majority vote也有一些劣势，为了保证leader election的正常进行，它所能容忍的fail的follower个数比较少。如果要容忍1个follower挂掉，必须要有3个以上的replica，如果要容忍2个follower挂掉，必须要有5个以上的replica。也就是说，在生产环境下为了保证较高的容错程度，必须要有大量的replica，而大量的replica又会在大数据量下导致性能的急剧下降。这就是这种算法更多用在 Zookeeper 这种共享集群配置的系统中而很少在需要存储大量数据的系统中使用的原因。例如HDFS的HA feature是基于 majority-vote-based journal ，但是它的数据存储并没有使用这种expensive的方式。</p>
<p>实际上，leader election算法非常多，比如Zookeper的 Zab , Raft 和 Viewstamped Replication 。而Kafka所使用的leader election算法更像微软的 PacificA 算法。</p>
<p>Kafka在Zookeeper中动态维护了一个ISR（in-sync replicas） set，这个set里的所有replica都跟上了leader，只有ISR里的成员才有被选为leader的可能。在这种模式下，对于f+1个replica，一个Kafka topic能在保证不丢失已经ommit的消息的前提下容忍f个replica的失败。在大多数使用场景中，这种模式是非常有利的。事实上，为了容忍f个replica的失败，majority vote和ISR在commit前需要等待的replica数量是一样的，但是ISR需要的总的replica的个数几乎是majority vote的一半。</p>
<p>虽然majority vote与ISR相比有不需等待最慢的server这一优势，但是Kafka作者认为Kafka可以通过producer选择是否被commit阻塞来改善这一问题，并且节省下来的replica和磁盘使得ISR模式仍然值得。</p>
<p>上文提到，在ISR中至少有一个follower时，Kafka可以确保已经commit的数据不丢失，但如果某一个partition的所有replica都挂了，就无法保证数据不丢失了。这种情况下有两种可行的方案：</p>
<ul>
<li>等待ISR中的任一个replica“活”过来，并且选它作为leader</li>
<li>选择第一个“活”过来的replica（不一定是ISR中的）作为leader</li>
</ul>
<p>这就需要在可用性和一致性当中作出一个简单的平衡。如果一定要等待ISR中的replica“活”过来，那不可用的时间就可能会相对较长。而且如果ISR中的所有replica都无法“活”过来了，或者数据都丢失了，这个partition将永远不可用。选择第一个“活”过来的replica作为leader，而这个replica不是ISR中的replica，那即使它并不保证已经包含了所有已commit的消息，它也会成为leader而作为consumer的数据源（前文有说明，所有读写都由leader完成）。Kafka0.8.*使用了第二种方式。根据Kafka的文档，在以后的版本中，Kafka支持用户通过配置选择这两种方式中的一种，从而根据不同的使用场景选择高可用性还是强一致性。</p>
<p>上文说明了一个parition的replication过程，然尔Kafka集群需要管理成百上千个partition，Kafka通过round-robin的方式来平衡partition从而避免大量partition集中在了少数几个节点上。同时Kafka也需要平衡leader的分布，尽可能的让所有partition的leader均匀分布在不同broker上。另一方面，优化leadership election的过程也是很重要的，毕竟这段时间相应的partition处于不可用状态。一种简单的实现是暂停宕机的broker上的所有partition，并为之选举leader。实际上，Kafka选举一个broker作为controller，这个controller通过watch Zookeeper检测所有的broker failure，并负责为所有受影响的parition选举leader，再将相应的leader调整命令发送至受影响的broker，过程如下图所示。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-6.jpg" alt="image"></p>
<p>这样做的好处是，可以批量的通知leadership的变化，从而使得选举过程成本更低，尤其对大量的partition而言。如果controller失败了，幸存的所有broker都会尝试在Zookeeper中创建/controller-&gt;{this broker id}，如果创建成功（只可能有一个创建成功），则该broker会成为controller，若创建不成功，则该broker会等待新controller的命令。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-7.jpg" alt="image"></p>
<h5 id="Consumer-group"><a href="#Consumer-group" class="headerlink" title="Consumer group"></a>Consumer group</h5><p>（本节所有描述都是基于consumer hight level API而非low level API）。</p>
<p>每一个consumer实例都属于一个consumer group，每一条消息只会被同一个consumer group里的一个consumer实例消费。（不同consumer group可以同时消费同一条消息）</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-8.jpg" alt="image"></p>
<p>很多传统的message queue都会在消息被消费完后将消息删除，一方面避免重复消费，另一方面可以保证queue的长度比较少，提高效率。而如上文所将，Kafka并不删除已消费的消息，为了实现传统message queue消息只被消费一次的语义，Kafka保证保证同一个consumer group里只有一个consumer会消费一条消息。与传统message queue不同的是，Kafka还允许不同consumer group同时消费同一条消息，这一特性可以为消息的多元化处理提供了支持。实际上，Kafka的设计理念之一就是同时提供离线处理和实时处理。根据这一特性，可以使用Storm这种实时流处理系统对消息进行实时在线处理，同时使用Hadoop这种批处理系统进行离线处理，还可以同时将数据实时备份到另一个数据中心，只需要保证这三个操作所使用的consumer在不同的consumer group即可。下图展示了Kafka在Linkedin的一种简化部署。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-9.jpg" alt="image"></p>
<p>为了更清晰展示Kafka consumer group的特性，笔者作了一项测试。创建一个topic (名为topic1)，创建一个属于group1的consumer实例，并创建三个属于group2的consumer实例，然后通过producer向topic1发送key分别为1，2，3r的消息。结果发现属于group1的consumer收到了所有的这三条消息，同时group2中的3个consumer分别收到了key为1，2，3的消息。如下图所示。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-10.jpg" alt="image"></p>
<h5 id="Consumer-Rebalance"><a href="#Consumer-Rebalance" class="headerlink" title="Consumer Rebalance"></a>Consumer Rebalance</h5><p>（本节所讲述内容均基于Kafka consumer high level API）</p>
<p>Kafka保证同一consumer group中只有一个consumer会消息某条消息，实际上，Kafka保证的是稳定状态下每一个consumer实例只会消费某一个或多个特定partition的数据，而某个partition的数据只会被某一个特定的consumer实例所消费。这样设计的劣势是无法让同一个consumer group里的consumer均匀消费数据，优势是每个consumer不用都跟大量的broker通信，减少通信开销，同时也降低了分配难度，实现也更简单。另外，因为同一个partition里的数据是有序的，这种设计可以保证每个partition里的数据也是有序被消费。</p>
<p>如果某consumer group中consumer数量少于partition数量，则至少有一个consumer会消费多个partition的数据，如果consumer的数量与partition数量相同，则正好一个consumer消费一个partition的数据，而如果consumer的数量多于partition的数量时，会有部分consumer无法消费该topic下任何一条消息。</p>
<p>如下例所示，如果topic1有0，1，2共三个partition，当group1只有一个consumer(名为consumer1)时，该 consumer可消费这3个partition的所有数据。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-11.jpg" alt="image"></p>
<p>增加一个consumer(consumer2)后，其中一个consumer（consumer1）可消费2个partition的数据，另外一个consumer(consumer2)可消费另外一个partition的数据。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-12.jpg" alt="image"></p>
<p>再增加一个consumer(consumer3)后，每个consumer可消费一个partition的数据。consumer1消费partition0，consumer2消费partition1，consumer3消费partition2<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-13.jpg" alt="image"></p>
<p>再增加一个consumer（consumer4）后，其中3个consumer可分别消费一个partition的数据，另外一个consumer（consumer4）不能消费topic1任何数据。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-14.jpg" alt="image"></p>
<p>此时关闭consumer1，剩下的consumer可分别消费一个partition的数据。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-15.jpg" alt="image"></p>
<p>接着关闭consumer2，剩下的consumer3可消费2个partition，consumer4可消费1个partition。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-16.jpg" alt="image"></p>
<p>再关闭consumer3，剩下的consumer4可同时消费topic1的3个partition。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-17.jpg" alt="image"></p>
<p>consumer rebalance算法如下：</p>
<ul>
<li>Sort PT (all partitions in topic T)</li>
<li>Sort CG(all consumers in consumer group G)</li>
<li>Let i be the index position of Ci in CG and let N=size(PT)/size(CG)</li>
<li>Remove current entries owned by Ci from the partition owner registry</li>
<li>Assign partitions from i N to (i+1) N-1 to consumer Ci</li>
<li>Add newly assigned partitions to the partition owner registry</li>
</ul>
<p>目前consumer rebalance的控制策略是由每一个consumer通过Zookeeper完成的。具体的控制方式如下：</p>
<ul>
<li>Register itself in the consumer id registry under its group.</li>
<li>Register a watch on changes under the consumer id registry.</li>
<li>Register a watch on changes under the broker id registry.</li>
<li>If the consumer creates a message stream using a topic filter, it also registers a watch on changes under the broker topic registry.</li>
<li>Force itself to rebalance within in its consumer group.</li>
</ul>
<p>在这种策略下，每一个consumer或者broker的增加或者减少都会触发consumer rebalance。因为每个consumer只负责调整自己所消费的partition，为了保证整个consumer group的一致性，所以当一个consumer触发了rebalance时，该consumer group内的其它所有consumer也应该同时触发rebalance。</p>
<p>目前（2015-01-19）最新版（0.8.2）Kafka采用的是上述方式。但该方式有不利的方面：</p>
<ul>
<li>Herd effect <ul>
<li>任何broker或者consumer的增减都会触发所有的consumer的rebalance</li>
</ul>
</li>
<li>Split Brain <ul>
<li>每个consumer分别单独通过Zookeeper判断哪些partition down了，那么不同consumer从Zookeeper“看”到的view就可能不一样，这就会造成错误的reblance尝试。而且有可能所有的consumer都认为rebalance已经完成了，但实际上可能并非如此。</li>
</ul>
</li>
</ul>
<p>根据Kafka官方文档，Kafka作者正在考虑在还未发布的 0.9.x版本中使用中心协调器(coordinator) 。大体思想是选举出一个broker作为coordinator，由它watch Zookeeper，从而判断是否有partition或者consumer的增减，然后生成rebalance命令，并检查是否这些rebalance在所有相关的consumer中被执行成功，如果不成功则重试，若成功则认为此次rebalance成功（这个过程跟replication controller非常类似，所以我很奇怪为什么当初设计replication controller时没有使用类似方式来解决consumer rebalance的问题）。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-18.jpg" alt="image"></p>
<h5 id="消息Deliver-guarantee"><a href="#消息Deliver-guarantee" class="headerlink" title="消息Deliver guarantee"></a>消息Deliver guarantee</h5><p>通过上文介绍，想必读者已经明天了producer和consumer是如何工作的，以及Kafka是如何做replication的，接下来要讨论的是Kafka如何确保消息在producer和consumer之间传输。有这么几种可能的delivery guarantee：</p>
<ul>
<li>At most once 消息可能会丢，但绝不会重复传输</li>
<li>At least one 消息绝不会丢，但可能会重复传输</li>
<li>Exactly once 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。</li>
<li>Kafka的delivery guarantee semantic非常直接。当producer向broker发送消息时，一旦这条消息被commit，因数replication的存在，它就不会丢。但是如果producer发送数据给broker后，遇到的网络问题而造成通信中断，那producer就无法判断该条消息是否已经commit。这一点有点像向一个自动生成primary key的数据库表中插入数据。虽然Kafka无法确定网络故障期间发生了什么，但是producer可以生成一种类似于primary key的东西，发生故障时幂等性的retry多次，这样就做到了Exactly one 。截止到目前(Kafka 0.8.2版本，2015-01-25)，这一feature还并未实现，有希望在Kafka未来的版本中实现。（所以目前默认情况下一条消息从producer和broker是确保了 At least once ，但可通过设置producer异步发送实现 At most once ）。</li>
<li>接下来讨论的是消息从broker到consumer的delivery guarantee semantic。（仅针对Kafka consumer high level API）。consumer在从broker读取消息后，可以选择commit，该操作会在Zookeeper中存下该consumer在该partition下读取的消息的offset。该consumer下一次再读该partition时会从下一条开始读取。如未commit，下一次读取的开始位置会跟上一次commit之后的开始位置相同。当然可以将consumer设置为autocommit，即consumer一旦读到数据立即自动commit。如果只讨论这一读取消息的过程，那Kafka是确保了 Exactly once 。但实际上实际使用中consumer并非读取完数据就结束了，而是要进行进一步处理，而数据处理与commit的顺序在很大程度上决定了消息从broker和consumer的delivery guarantee semantic。</li>
<li>读完消息先commit再处理消息。这种模式下，如果consumer在commit后还没来得及处理消息就crash了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于 At most once</li>
<li>读完消息先处理再commit。这种模式下，如果处理完了消息在commit之前consumer crash了，下次重新开始工作时还会处理刚刚未commit的消息，实际上该消息已经被处理过了。这就对应于 At least once 。在很多情况使用场景下，消息都有一个primary key，所以消息的处理往往具有幂等性，即多次处理这一条消息跟只处理一次是等效的，那就可以认为是 Exactly once 。（人个感觉这种说法有些牵强，毕竟它不是Kafka本身提供的机制，而且primary key本身不保证操作的幂等性。而且实际上我们说delivery guarantee semantic是讨论被处理多少次，而非处理结果怎样，因为处理方式多种多样，我们的系统不应该把处理过程的特性—如是否幂等性，当成Kafka本身的feature）</li>
<li>如果一定要做到 Exactly once ，就需要协调offset和实际操作的输出。精典的做法是引入两阶段提交。如果能让offset和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，consumer拿到数据后可能把数据放到HDFS，如果把最新的offset和数据本身一起写到HDFS，那就可以保证数据的输出和offset的更新要么都完成，要么都不完成，间接实现 Exactly once 。（目前就high level API而言，offset是存于Zookeeper中的，无法存于HDFS，而low level API的offset是由自己去维护的，可以将之存于HDFS中） </li>
<li>总之，Kafka默认保证 At least once ，并且允许通过设置producer异步提交来实现 At most once 。而 Exactly once 要求与目标存储系统协作，幸运的是Kafka提供的offset可以使用这种方式非常直接非常容易。</li>
</ul>
<h5 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h5><p>纸上得来终觉浅，绝知些事要躬行。笔者希望能亲自测一下Kafka的性能，而非从网上找一些测试数据。所以笔者曾在0.8发布前两个月做过详细的Kafka0.8性能测试，不过很可惜测试报告不慎丢失。所幸在网上找到了Kafka的创始人之一的 Jay Kreps的bechmark 。以下描述皆基于该benchmark。（该benchmark基于Kafka0.8.1）</p>
<h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><h5 id="producer吞吐率"><a href="#producer吞吐率" class="headerlink" title="producer吞吐率"></a>producer吞吐率</h5><p>该项测试只测producer的吞吐率，也就是数据只被持久化，没有consumer读数据。</p>
<h5 id="1个producer线程，无replication"><a href="#1个producer线程，无replication" class="headerlink" title="1个producer线程，无replication"></a>1个producer线程，无replication</h5><p>在这一测试中，创建了一个包含6个partition且没有replication的topic。然后通过一个线程尽可能快的生成50 million条比较短（payload100字节长）的消息。测试结果是821,557 records/second （ 78.3MB/second ）。</p>
<p>之所以使用短消息，是因为对于消息系统来说这种使用场景更难。因为如果使用MB/second来表征吞吐率，那发送长消息无疑能使得测试结果更好。</p>
<p>整个测试中，都是用每秒钟delivery的消息的数量乘以payload的长度来计算MB/second的，没有把消息的元信息算在内，所以实际的网络使用量会比这个大。对于本测试来说，每次还需传输额外的22个字节，包括一个可选的key，消息长度描述，CRC等。另外，还包含一些请求相关的overhead，比如topic，partition，acknowledgement等。这就导致我们比较难判断是否已经达到网卡极限，但是把这些overhead都算在吞吐率里面应该更合理一些。因此，我们已经基本达到了网卡的极限。</p>
<p>初步观察此结果会认为它比人们所预期的要高很多，尤其当考虑到Kafka要把数据持久化到磁盘当中。实际上，如果使用随机访问数据系统，比如RDBMS，或者key-velue store，可预期的最高访问频率大概是5000到50000个请求每秒，这和一个好的RPC层所能接受的远程请求量差不多。而该测试中远超于此的原因有两个。</p>
<ul>
<li>Kafka确保写磁盘的过程是线性磁盘I/O，测试中使用的6块廉价磁盘线性I/O的最大吞吐量是822MB/second，这已经远大于1Gb网卡所能带来的吞吐量了。许多消息系统把数据持久化到磁盘当成是一个开销很大的事情，这是因为他们对磁盘的操作都不是线性I/O。</li>
<li>在每一个阶段，Kafka都尽量使用批量处理。如果想了解批处理在I/O操作中的重要性，可以参考David Patterson的” Latency Lags Bandwidth “</li>
</ul>
<h5 id="1个producer线程，3个异步replication"><a href="#1个producer线程，3个异步replication" class="headerlink" title="1个producer线程，3个异步replication"></a>1个producer线程，3个异步replication</h5><p>该项测试与上一测试基本一样，唯一的区别是每个partition有3个replica（所以网络传输的和写入磁盘的总的数据量增加了3倍）。每一个broker即要写作为leader的partition，也要读（从leader读数据）写（将数据写到磁盘）作为follower的partition。测试结果为 786,980 records/second （ 75.1MB/second ）。</p>
<p>该项测试中replication是异步的，也就是说broker收到数据并写入本地磁盘后就acknowledge producer，而不必等所有replica都完成replication。也就是说，如果leader crash了，可能会丢掉一些最新的还未备份的数据。但这也会让message acknowledgement延迟更少，实时性更好。</p>
<p>这项测试说明，replication可以很快。整个集群的写能力可能会由于3倍的replication而只有原来的三分之一，但是对于每一个producer来说吞吐率依然足够好。</p>
<h5 id="1个producer线程，3个同步replication"><a href="#1个producer线程，3个同步replication" class="headerlink" title="1个producer线程，3个同步replication"></a>1个producer线程，3个同步replication</h5><p>该项测试与上一测试的唯一区别是replication是同步的，每条消息只有在被 in sync 集合里的所有replica都复制过去后才会被置为committed（此时broker会向producer发送acknowledgement）。在这种模式下，Kafka可以保证即使leader crash了，也不会有数据丢失。测试结果为 421,823 records/second （ 40.2MB/second）。</p>
<p>Kafka同步复制与异步复制并没有本质的不同。leader会始终track follower replica从而监控它们是否还alive，只有所有 in sync 集合里的replica都acknowledge的消息才可能被consumer所消费。而对follower的等待影响了吞吐率。可以通过增大batch size来改善这种情况，但为了避免特定的优化而影响测试结果的可比性，本次测试并没有做这种调整。</p>
<h5 id="3个producer-3个异步replication"><a href="#3个producer-3个异步replication" class="headerlink" title="3个producer,3个异步replication"></a>3个producer,3个异步replication</h5><p>该测试相当于把上文中的1个producer,复制到了3台不同的机器上（在1台机器上跑多个实例对吞吐率的增加不会有太大帮忙，因为网卡已经基本饱和了），这3个producer同时发送数据。整个集群的吞吐率为 2,024,032 records/second （ 193,0MB/second）。</p>
<h5 id="Producer-Throughput-Vs-Stored-Data"><a href="#Producer-Throughput-Vs-Stored-Data" class="headerlink" title="Producer Throughput Vs. Stored Data"></a>Producer Throughput Vs. Stored Data</h5><p>消息系统的一个潜在的危险是当数据能都存于内存时性能很好，但当数据量太大无法完全存于内存中时（然后很多消息系统都会删除已经被消费的数据，但当消费速度比生产速度慢时，仍会造成数据的堆积），数据会被转移到磁盘，从而使得吞吐率下降，这又反过来造成系统无法及时接收数据。这样就非常糟糕，而实际上很多情景下使用queue的目的就是解决数据消费速度和生产速度不一致的问题。</p>
<p>但Kafka不存在这一问题，因为Kafka始终以O（1）的时间复杂度将数据持久化到磁盘，所以其吞吐率不受磁盘上所存储的数据量的影响。为了验证这一特性，做了一个长时间的大数据量的测试，下图是吞吐率与数据量大小的关系图。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-19.jpg" alt="image"></p>
<p>上图中有一些variance的存在，并可以明显看到，吞吐率并不受磁盘上所存数据量大小的影响。实际上从上图可以看到，当磁盘数据量达到1TB时，吞吐率和磁盘数据只有几百MB时没有明显区别。</p>
<p>这个variance是由Linux I/O管理造成的，它会把数据缓存起来再批量flush。上图的测试结果是在生产环境中对Kafka集群做了些tuning后得到的，这些tuning方法可参考 这里 。</p>
<h5 id="consumer吞吐率"><a href="#consumer吞吐率" class="headerlink" title="consumer吞吐率"></a>consumer吞吐率</h5><p>需要注意的是，replication factor并不会影响consumer的吞吐率测试，因为consumer只会从每个partition的leader读数据，而与replicaiton factor无关。同样，consumer吞吐率也与同步复制还是异步复制无关。</p>
<p><strong>1个consumer</strong></p>
<p>该测试从有6个partition，3个replication的topic消费50 million的消息。测试结果为940,521 records/second （ 89.7MB/second ）。</p>
<p>可以看到，Kafkar的consumer是非常高效的。它直接从broker的文件系统里读取文件块。Kafka使用 sendfile API 来直接通过操作系统直接传输，而不用把数据拷贝到用户空间。该项测试实际上从log的起始处开始读数据，所以它做了真实的I/O。在生产环境下，consumer可以直接读取producer刚刚写下的数据（它可能还在缓存中）。实际上，如果在生产环境下跑 I/O stat ，你可以看到基本上没有物理“读”。也就是说生产环境下consumer的吞吐率会比该项测试中的要高。</p>
<p><strong>3个consumer</strong></p>
<p>将上面的consumer复制到3台不同的机器上，并且并行运行它们（从同一个topic上消费数据）。测试结果为 2,615,968 records/second （ 249.5MB/second ）。</p>
<p>正如所预期的那样，consumer的吞吐率几乎线性增涨。</p>
<h5 id="Producer-and-Consumer"><a href="#Producer-and-Consumer" class="headerlink" title="Producer and Consumer"></a>Producer and Consumer</h5><p>上面的测试只是把producer和consumer分开测试，而该项测试同时运行producer和consumer，这更接近使用场景。实际上目前的replication系统中follower就相当于consumer在工作。</p>
<p>该项测试，在具有6个partition和3个replica的topic上同时使用1个producer和1个consumer，并且使用异步复制。测试结果为 795,064 records/second （75.8MB/second ）。</p>
<p>可以看到，该项测试结果与单独测试1个producer时的结果几乎一致。所以说consumer非常轻量级。</p>
<h5 id="消息长度对吞吐率的影响"><a href="#消息长度对吞吐率的影响" class="headerlink" title="消息长度对吞吐率的影响"></a>消息长度对吞吐率的影响</h5><p>上面的所有测试都基于短消息（payload 100字节），而正如上文所说，短消息对Kafka来说是更难处理的使用方式，可以预期，随着消息长度的增大，records/second会减小，但MB/second会有所提高。下图是records/second与消息长度的关系图。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-20.jpg" alt="image"></p>
<p>正如我们所预期的那样，随着消息长度的增加，每秒钟所能发送的消息的数量逐渐减小。但是如果看每秒钟发送的消息的总大小，它会随着消息长度的增加而增加，如下图所示。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0924-21.jpg" alt="image"></p>
<p>从上图可以看出，当消息长度为10字节时，因为要频繁入队，花了太多时间获取锁，CPU成了瓶颈，并不能充分利用带宽。但从100字节开始，我们可以看到带宽的使用逐渐趋于饱和（虽然MB/second还是会随着消息长度的增加而增加，但增加的幅度也越来越小）。</p>
<h5 id="端到端的Latency"><a href="#端到端的Latency" class="headerlink" title="端到端的Latency"></a>端到端的Latency</h5><p>上文中讨论了吞吐率，那消息传输的latency如何呢？也就是说消息从producer到consumer需要多少时间呢？该项测试创建1个producer和1个consumer并反复计时。结果是， 2 ms (median), 3ms (99th percentile, 14ms (99.9th percentile) 。</p>
<p>（这里并没有说明topic有多少个partition，也没有说明有多少个replica，replication是同步还是异步。实际上这会极大影响producer发送的消息被commit的latency，而只有committed的消息才能被consumer所消费，所以它会最终影响端到端的latency）</p>
<h4 id="Kafka-如何保证消息顺序消费"><a href="#Kafka-如何保证消息顺序消费" class="headerlink" title="Kafka 如何保证消息顺序消费"></a>Kafka 如何保证消息顺序消费</h4><p>两种方案：</p>
<p>方案一，kafka topic 只设置一个partition分区  </p>
<p>方案二，producer将消息发送到指定partition分区</p>
<p>解析：</p>
<p>方案一：kafka默认保证同一个partition分区内的消息是有序的，则可以设置topic只使用一个分区，这样消息就是全局有序，缺点是只能被consumer group里的一个消费者消费，降低了性能，不适用高并发的情况</p>
<p>方案二：既然kafka默认保证同一个partition分区内的消息是有序的，则producer可以在发送消息时可以指定需要保证顺序的几条消息发送到同一个分区，这样消费者消费时，消息就是有序。</p>
<p>producer发送消息时具体到topic的哪一个partition分区，提供了三种方式</p>
<p>1）指定分区</p>
<p>2）不指定分区，有指定key 则根据key的hash值与分区数进行运算后确定发送到哪个partition分区</p>
<p>3）不指定分区，不指定key，则轮询各分区发送</p>
<h4 id="提高消费者速度"><a href="#提高消费者速度" class="headerlink" title="提高消费者速度"></a>提高消费者速度</h4><p>一般来说有几类</p>
<p>1.增加分区（题上不让）</p>
<p>2.关闭autocommit（偏移量手工提交可以按需减少分区偏移量的更新，有利于提升消费速度）</p>
<p>3.增加单次拉取消息的大小（大量消息的场景下可减少拉取消息的次数）</p>
<p>比较另类的：</p>
<p>1.如果不考虑数据一致性，可以将key值平均一下，这样每个分区的消息大小都差不多，有利于负载均衡</p>
<p>2.如果没有开启压缩，最好开启压缩（需要重启集群），可大大提高通信效率，有得消费速度提升</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>JUC有研究没有，讲一讲？</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/06/18/面试分享(四).项目相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/面试分享(四).项目相关/" itemprop="url">面试分享(四).项目相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T18:33:00+08:00">
                2019-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/18/面试分享(四).项目相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/06/18/面试分享(四).项目相关/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h1><h2 id="聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。"><a href="#聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。" class="headerlink" title="聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。"></a>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。</h2><h2 id="你个人有什么优势"><a href="#你个人有什么优势" class="headerlink" title="你个人有什么优势"></a>你个人有什么优势</h2><h2 id="讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细"><a href="#讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细" class="headerlink" title="讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细"></a>讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细</h2><h2 id="线上有没有遇到其他问题，如何处理的"><a href="#线上有没有遇到其他问题，如何处理的" class="headerlink" title="线上有没有遇到其他问题，如何处理的"></a>线上有没有遇到其他问题，如何处理的</h2><h2 id="说一个你了解最多的框架，说出你的理解"><a href="#说一个你了解最多的框架，说出你的理解" class="headerlink" title="说一个你了解最多的框架，说出你的理解"></a>说一个你了解最多的框架，说出你的理解</h2><h2 id="项目中监控报警机制如何做的，说说你的了解"><a href="#项目中监控报警机制如何做的，说说你的了解" class="headerlink" title="项目中监控报警机制如何做的，说说你的了解"></a>项目中监控报警机制如何做的，说说你的了解</h2><h2 id="服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题"><a href="#服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题" class="headerlink" title="服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题"></a>服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题</h2><h2 id="防止服务器雪崩"><a href="#防止服务器雪崩" class="headerlink" title="防止服务器雪崩"></a>防止服务器雪崩</h2><p>服务雪崩效应是一种因 服务提供者 的不可用导致 服务调用者 的不可用,并将不可用 逐渐放大 的过程.如果所示:<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/4178518469-578b40005071a_articlex.png" alt="image"></p>
<p>上图中, A为服务提供者, B为A的服务调用者, C和D是B的服务调用者. 当A的不可用,引起B的不可用,并将不可用逐渐放大C和D时, 服务雪崩就形成了.</p>
<h3 id="服务雪崩效应形成的原因"><a href="#服务雪崩效应形成的原因" class="headerlink" title="服务雪崩效应形成的原因"></a>服务雪崩效应形成的原因</h3><p>我把服务雪崩的参与者简化为 服务提供者 和 服务调用者, 并将服务雪崩产生的过程分为以下三个阶段来分析形成的原因:</p>
<ol>
<li>服务提供者不可用</li>
<li>重试加大流量</li>
<li>服务调用者不可用</li>
</ol>
<p>服务雪崩的每个阶段都可能由不同的原因造成, 比如造成 服务不可用 的原因有:</p>
<ul>
<li>硬件故障</li>
<li>程序Bug</li>
<li>缓存击穿</li>
<li>用户大量请求</li>
</ul>
<p>硬件故障可能为硬件损坏造成的服务器主机宕机, 网络硬件故障造成的服务提供者的不可访问.<br>缓存击穿一般发生在缓存应用重启, 所有缓存被清空时,以及短时间内大量缓存失效时. 大量的缓存不命中, 使请求直击后端,造成服务提供者超负荷运行,引起服务不可用.<br>在秒杀和大促开始前,如果准备不充分,用户发起大量请求也会造成服务提供者的不可用.</p>
<p>而形成 重试加大流量 的原因有:</p>
<ul>
<li>用户重试</li>
<li>代码逻辑重试</li>
</ul>
<p>在服务提供者不可用后, 用户由于忍受不了界面上长时间的等待,而不断刷新页面甚至提交表单.<br>服务调用端的会存在大量服务异常后的重试逻辑.<br>这些重试都会进一步加大请求流量.</p>
<p>最后, 服务调用者不可用 产生的主要原因是:</p>
<ul>
<li>同步等待造成的资源耗尽</li>
</ul>
<p>当服务调用者使用 同步调用 时, 会产生大量的等待线程占用系统资源. 一旦线程资源被耗尽,服务调用者提供的服务也将处于不可用状态, 于是服务雪崩效应产生了.</p>
<h3 id="服务雪崩的应对策略"><a href="#服务雪崩的应对策略" class="headerlink" title="服务雪崩的应对策略"></a>服务雪崩的应对策略</h3><p>针对造成服务雪崩的不同原因, 可以使用不同的应对策略:</p>
<ul>
<li>流量控制</li>
<li>改进缓存模式</li>
<li>服务自动扩容</li>
<li>服务调用者降级服务</li>
</ul>
<p>流量控制 的具体措施包括:</p>
<ul>
<li>网关限流</li>
<li>用户交互限流</li>
<li>关闭重试</li>
</ul>
<p>因为Nginx的高性能, 目前一线互联网公司大量采用Nginx+Lua的网关进行流量控制, 由此而来的OpenResty也越来越热门.</p>
<p>用户交互限流的具体措施有:</p>
<ul>
<li>采用加载动画,提高用户的忍耐等待时间.</li>
<li>提交按钮添加强制等待时间机制.</li>
</ul>
<p>改进缓存模式 的措施包括:</p>
<ul>
<li>缓存预加载</li>
<li>同步改为异步刷新</li>
</ul>
<p>服务自动扩容 的措施主要有:</p>
<ul>
<li>AWS的auto scaling</li>
</ul>
<p>服务调用者降级服务 的措施包括:<br>资源隔离</p>
<ul>
<li>对依赖服务进行分类</li>
<li>不可用服务的调用快速失败</li>
<li>资源隔离主要是对调用服务的线程池进行隔离.</li>
</ul>
<p>我们根据具体业务,将依赖服务分为: 强依赖和若依赖. 强依赖服务不可用会导致当前业务中止,而弱依赖服务的不可用不会导致当前业务的中止.</p>
<p>不可用服务的调用快速失败一般通过 超时机制, 熔断器 和熔断后的 降级方法 来实现.</p>
<h2 id="缓存穿透，缓存击穿，缓存雪崩解决方案分析"><a href="#缓存穿透，缓存击穿，缓存雪崩解决方案分析" class="headerlink" title="缓存穿透，缓存击穿，缓存雪崩解决方案分析"></a>缓存穿透，缓存击穿，缓存雪崩解决方案分析</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="使用互斥锁-mutex-key"><a href="#使用互斥锁-mutex-key" class="headerlink" title="使用互斥锁(mutex key)"></a>使用互斥锁(mutex key)</h5><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p>
<p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间，所以这里给出两种版本代码参考：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//2.6.1前单机版本锁</span></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;  </span><br><span class="line">   <span class="keyword">String</span> value = redis.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </span><br><span class="line">        value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">        redis.<span class="built_in">set</span>(<span class="built_in">key</span>, value);  </span><br><span class="line">        redis.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);  </span><br><span class="line">        <span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最新版本代码：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">get</span>(<span class="built_in">key</span>) &#123;</span><br><span class="line">      <span class="keyword">String</span> value = redis.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">		  <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">               value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">                      redis.<span class="built_in">set</span>(<span class="built_in">key</span>, value, expire_secs);</span><br><span class="line">                      redis.del(key_mutex);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">                      sleep(<span class="number">50</span>);</span><br><span class="line">                      <span class="built_in">get</span>(<span class="built_in">key</span>);  <span class="comment">//重试</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> value;      </span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>memcache代码<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (memcache.<span class="built_in">get</span>(<span class="built_in">key</span>) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">    <span class="keyword">if</span> (memcache.<span class="built_in">add</span>(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </span><br><span class="line">        value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">        memcache.<span class="built_in">set</span>(<span class="built_in">key</span>, value);  </span><br><span class="line">        memcache.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        sleep(<span class="number">50</span>);  </span><br><span class="line">        retry();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="“提前”使用互斥锁-mutex-key"><a href="#“提前”使用互斥锁-mutex-key" class="headerlink" title="“提前”使用互斥锁(mutex key)"></a>“提前”使用互斥锁(mutex key)</h5><p>在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。伪代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">v = memcache.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line"><span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (memcache.<span class="built_in">add</span>(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </span><br><span class="line">        value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">        memcache.<span class="built_in">set</span>(<span class="built_in">key</span>, value);  </span><br><span class="line">        memcache.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        sleep(<span class="number">50</span>);  </span><br><span class="line">        retry();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (v.timeout &lt;= now()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (memcache.<span class="built_in">add</span>(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </span><br><span class="line">            <span class="comment">// extend the timeout for other threads  </span></span><br><span class="line">            v.timeout += <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>;  </span><br><span class="line">            memcache.<span class="built_in">set</span>(<span class="built_in">key</span>, v, KEY_TIMEOUT * <span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// load the latest value from db  </span></span><br><span class="line">            v = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">            v.timeout = KEY_TIMEOUT;  </span><br><span class="line">            memcache.<span class="built_in">set</span>(<span class="built_in">key</span>, value, KEY_TIMEOUT * <span class="number">2</span>);  </span><br><span class="line">            memcache.delete(key_mutex);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            sleep(<span class="number">50</span>);  </span><br><span class="line">            retry();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="“永远不过期”"><a href="#“永远不过期”" class="headerlink" title="“永远不过期”"></a>“永远不过期”</h5><p>这里的“永远不过期”包含两层意思：</p>
<p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p>
<p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p>
<p>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">get</span>(<span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">key</span>) &#123;  </span><br><span class="line">        V v = redis.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">        <span class="keyword">String</span> value = v.getValue();  </span><br><span class="line">        <span class="keyword">long</span> timeout = v.getTimeout();  </span><br><span class="line">        <span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;  </span><br><span class="line">            <span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;  </span><br><span class="line">                    <span class="keyword">String</span> keyMutex = <span class="string">"mutex:"</span> + <span class="built_in">key</span>;  </span><br><span class="line">                    <span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">                        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">                        redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);  </span><br><span class="line">                        <span class="keyword">String</span> dbValue = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">                        redis.<span class="built_in">set</span>(<span class="built_in">key</span>, dbValue);  </span><br><span class="line">                        redis.delete(keyMutex);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="资源保护"><a href="#资源保护" class="headerlink" title="资源保护"></a>资源保护</h5><p>采用netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。</p>
<p>四种解决方案：没有最佳只有最合适</p>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单分布式互斥锁（mutex key）</td>
<td>1. 思路简单2. 保证一致性</td>
<td>1. 代码复杂度增大2. 存在死锁的风险3. 存在线程池阻塞的风险</td>
</tr>
<tr>
<td>“提前”使用互斥锁</td>
<td>保证一致性</td>
<td>同上  </td>
</tr>
<tr>
<td>不过期(本文)</td>
<td>异步构建缓存，不会阻塞线程池</td>
<td>1.不保证一致性。2. 代码复杂度增大(每个value都要维护一个timekey)。3. 占用一定的内存空间(每个value都要维护一个timekey)。 </td>
</tr>
<tr>
<td>资源隔离组件hystrix(本文)</td>
<td>1.hystrix技术成熟，有效保证后端。2. hystrix监控强大。</td>
<td>部分访问存在降级策略。</td>
</tr>
</tbody>
</table>
<h2 id="怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？"><a href="#怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？" class="headerlink" title="怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？"></a>怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？</h2><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1428026-20180627155226400-2110957179.png" alt="image"><br>优点</p>
<p>1:提升开发交流，每个服务足够内聚，足够小，代码容易理解；</p>
<p>2:服务独立测试、部署、升级、发布；</p>
<p>3:按需定制的DFX，资源利用率，每个服务可以各自进行x扩展和z扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；每个服务按4:需要选择HA的模式，选择接受服务的实例个数；</p>
<p>5:容易扩大开发团队，可以针对每个服务（service）组件开发团队；</p>
<p>6:提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；</p>
<p>7:新技术的应用，系统不会被长期限制在某个技术栈上；</p>
<p>缺点</p>
<p>没有银弹，微服务提高了系统的复杂度；开发人员要处理分布式系统的复杂性；服务之间的分布式通信问题；服务的注册与发现问题；服务之间的分布式事务问题；数据隔离再来的报表处理问题；服务之间的分布式一致性问题；服务管理的复杂性，服务的编排；不同服务实例的管理。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1428026-20180627155304978-2139783031.png" alt="image"></p>
<p>Chris Richardson提出的微服务的三维扩展模型：</p>
<p>X轴，服务实例水平扩展，保证可靠性与性能；</p>
<p>Y轴，功能的扩展，服务单一职责，功能独立；</p>
<p>Z轴，数据分区，数据独立，可靠性保证；</p>
<h3 id="拆分例子"><a href="#拆分例子" class="headerlink" title="拆分例子"></a>拆分例子</h3><h4 id="姿势一"><a href="#姿势一" class="headerlink" title="姿势一"></a>姿势一</h4><p>新浪微博微服务专家胡忠想从纵横两个维度来划分，简单粗暴：</p>
<p>1.1 纵向拆分</p>
<p>　　从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</p>
<p>1.2 横向拆分</p>
<p>　　从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p>
<p>　　纵向以业务为基准，关系铁的在一起；横向功能独立的在一起。我想如果拆分这么简单，你有底气拆，敢拆吗？所以我们又继续比对一下其他专家的言论。<br>　　<img src="https://minios.strongsickcat.com/dinghuang-blog-picture/127185-20190513142607150-1816607466.png" alt="image"></p>
<h4 id="姿势二"><a href="#姿势二" class="headerlink" title="姿势二"></a>姿势二</h4><p>阿里的小伙伴从综合的维度来看，部分维度和上面会有重合。</p>
<p>2.1 服务拆分要迎合业务的需要</p>
<p>　　充分考虑业务独立性和专业性，避免以团队来定义服务边界，从而出现“土匪”抢地盘，影响团队信任。</p>
<p>　　这个维度和上面的类似，但是强调的是业务和团队成员的各自独立性，对上面是一种很好的补充。</p>
<p>2.2 拆分后的维护成本要低于拆分前</p>
<p>　　这里的维护成本包括：人力、物力、时间。</p>
<p>　　这里的成本对大部分中小团队来说都是必须要考虑的重要环节，如果投入和收益不能成正比，或者超出领导的预算或者市场窗口，那么先进的技术就是绊脚石，千万不要迷恋技术，所谓工程师思维千万要不得。</p>
<p>2.3 拆分不仅仅是架构的调整，组织结构上也要做响应的适应性优化</p>
<p>　　确保拆分后的服务由相对独立的团队负责维护。</p>
<p>　　这句话怎么理解呢？传统的团队划分是按照产品部、前端、后端横向划分，微服务化以后的团队可能就会是吃一张披萨饼的人数，产品、前端、后端被归类到服务里面，以服务为中心来分配人数。</p>
<p>2.4 拆分最有价值的结果是提高了系统的可扩展性</p>
<p>　　把具有不同扩展性要求的服务拆分出来，分别进行部署，降低成本，提高效率。比如全文搜索服务。</p>
<p>　　这点和上面的按功能独立性来拆分有点类似，功能独立其实就是面向可扩展性。</p>
<p>2.5 考虑软件发布频率</p>
<p>　　比如把20%经常变动的部分进行抽离，80%不经常变动的单独部署和管理。说白了就是按照8/2原则进行拆分。这个拆分的好处很明显，可以尽可能的减少发布产生的后遗症，比如用户体验、服务相互干扰等。</p>
<p>　　但是这里有一个问题，假如20%的服务分属于不同的业务层面，那该怎么办？所以这里的拆分应该有个优先级，在拆分相互冲突的时候应该要优先考虑权重比较高的那个。<br>　　<img src="https://minios.strongsickcat.com/dinghuang-blog-picture/127185-20190513142644719-478728417.png" alt="image">
　　</p>
<h4 id="姿势三"><a href="#姿势三" class="headerlink" title="姿势三"></a>姿势三</h4><p>资深技术专家李运华在他的架构书中给出的拆分：</p>
<p>3.1 基于业务逻辑</p>
<p>　　将系统中的业务按照职责范围进行识别，职责相同的划分为一个单独的服务。这种业务优先的方式在前面两种姿势当中都出现过，可见是最基本，最重要的划分方式（没有之一）。</p>
<p>3.2 基于稳定性</p>
<p>　　将系统中的业务模块按照稳定性进行排序。稳定的、不经常修改的划分一块；将不稳定的，经常修改的划分为一个独立服务。比如日志服务、监控服务都是相对稳定的服务，可以归到一起。这个很类似上面提到的2/8原则，80%的业务是稳定的。</p>
<p>　　至此你会发现服务的拆分真的没有绝对的标准，只有合理才是标准。</p>
<p>3.3 基于可靠性</p>
<p>　　同样，将系统中的业务模块按照可靠性进行排序。对可靠性要求比较高的核心模块归在一起，对可靠性要求不高的非核心模块归在一块。</p>
<p>　　这种拆分的高明可以很好的规避因为一颗老鼠屎坏了一锅粥的单体弊端，同时将来要做高可用方案也能很好的节省机器或带宽的成本。</p>
<p>3.4 基于高性能</p>
<p>　　同上，将系统中的业务模块按照对性能的要求进行优先级排序。把对性能要求较高的模块独立成一个服务，对性能要求不高的放在一起。比如全文搜索，商品查询和分类，秒杀就属于高性能的核心模块。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/127185-20190513142705705-752555217.png" alt="image"></p>
<h2 id="如何理解网关，网关带来的好处和坏处，如何解决"><a href="#如何理解网关，网关带来的好处和坏处，如何解决" class="headerlink" title="如何理解网关，网关带来的好处和坏处，如何解决"></a>如何理解网关，网关带来的好处和坏处，如何解决</h2><p>API网关我的分析中会用到以下三种场景。</p>
<ul>
<li>Open API。企业需要将自身数据、能力等作为开发平台向外开放，通常会以rest的方式向外提供，最好的例子就是淘宝开放平台、腾讯公司的QQ开放平台、微信开放平台。 Open API开放平台必然涉及到客户应用的接入、API权限的管理、调用次数管理等，必然会有一个统一的入口进行管理，这正是API网关可以发挥作用的时候。</li>
<li>微服务网关。微服务的概念最早在2012年提出，在Martin Fowler的大力推广下，微服务在2014年后得到了大力发展。 在微服务架构中，有一个组件可以说是必不可少的，那就是微服务网关，微服务网关处理了负载均衡，缓存，路由，访问控制，服务代理，监控，日志等。API网关在微服务架构中正是以微服务网关的身份存在。</li>
<li>API服务管理平台。上述的微服务架构对企业来说有可能实施上是困难的，企业有很多遗留系统，要全部抽取为微服务器改动太大，对企业来说成本太高。但是由于不同系统间存在大量的API服务互相调用，因此需要对系统间服务调用进行管理，清晰地看到各系统调用关系，对系统间调用进行监控等。 API网关可以解决这些问题，我们可以认为如果没有大规模的实施微服务架构，那么对企业来说微服务网关就是企业的API服务管理平台。</li>
</ul>
<p>一个企业随着信息系统复杂度的提高，必然出现外部合作伙伴应用、企业自身的公网应用、企业内网应用等，在架构上应该将这三种应用区别开，三种应用的安排级别、访问方式也不一样。 因此在我的设计中将这三种应用分别用不同的网关进行API管理，分别是：API网关（OpenAPI合伙伙伴应用）、API网关（内部应用）、API网关（内部公网应用）。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104153322409-925270442.png" alt="image"></p>
<p>对于OpenAPI使用的API网关来说，一般合作伙伴要以应用的形式接入到OpenAPI平台，合作伙伴需要到 OpenAPI平台申请应用。 因此在OpenAPI网关之外，需要有一个面向合作伙伴的使用的平台用于合作伙伴，这就要求OpenAPI网关需要提供API给这个用户平台进行访问。 如下架构:</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104153600440-801781810.jpg" alt="image"></p>
<p>对于内网的API网关，在起到的作用上来说可以认为是微服务网关，也可以认为是内网的API服务治理平台。 当企业将所有的应用使用微服务的架构管理起来，那么API网关就起到了微服务网关的作用。 而当企业只是将系统与系统之间的调用使用rest api的方式进行访问时使用API网关对调用进行管理，那么API网关起到的就是API服务治理的作用。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104153752409-751696404.jpg" alt="image"><br>对于公司内部公网应用（如APP、公司的网站），如果管理上比较细致，在架构上是可能由独立的API网关来处理这部分内部公网应用，如果想比较简单的处理，也可以是使用面向合作伙伴的API网关。 如果使用独立的API网关，有以下的好处：</p>
<ul>
<li>面向合作伙伴和面向公司主体业务的优先级不一样，不同的API网关可以做到业务影响的隔离。</li>
<li>内部API使用的管理流程和面向合作伙伴的管理流程可能不一样。</li>
<li>内部的API在功能扩展等方面的需求一般会大于OpenAPI对于功能的要求。<br>基于以上的分析，如果公司有能力，那么还是建议分开使用合作伙伴OPEN API网关和内部公网应用网关</li>
</ul>
<h3 id="API网关有哪些竞争方案"><a href="#API网关有哪些竞争方案" class="headerlink" title="API网关有哪些竞争方案"></a>API网关有哪些竞争方案</h3><p>1、对于Open API平台的API网关，我分析只能选择API网关作为解决方案，业界没有发现比较好的可以用来作为Open API平台的入口的其他方案。</p>
<p>2、对于作为微服务网关的API网关，业界的选择可以选择的解决方案比较多，也取决于微服务器的实现方案，有一些微服务架构的实现方案是不需要微服务网关的。</p>
<ul>
<li>Service Mesh，这是新兴的基于无API网关的架构，通过在客户端上的代理完成屏蔽网络层的访问，这样达到对应用层最小的改动，当前Service Mesh的产品还正在开发中，并没有非常成熟可直接应用的产品。 发展最迅速的产品是Istio。 建议大家密切关注相关产品的研发、业务使用进展。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104154202112-182791105.png" alt="image"></li>
<li>基于duboo架构，在这个架构中通常是不需要网关的，是由客户端直接访问服务提供方，由注册中心向客户端返回服务方的地址。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104154443503-595466474.jpg" alt="image"></li>
</ul>
<h3 id="API网关解决方案"><a href="#API网关解决方案" class="headerlink" title="API网关解决方案"></a>API网关解决方案</h3><p>私有云开源解决方案如下：</p>
<ul>
<li>Kong kong是基于Nginx+Lua进行二次开发的方案， <a href="https://konghq.com/" target="_blank" rel="noopener">https://konghq.com/</a></li>
<li>Netflix Zuul，zuul是spring cloud的一个推荐组件，<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></li>
<li>orange,这个开源程序是国人开发的， <a href="http://orange.sumory.com/" target="_blank" rel="noopener">http://orange.sumory.com/</a></li>
</ul>
<p>公有云解决方案：</p>
<ul>
<li>Amazon API Gateway，<a href="https://aws.amazon.com/cn/api-gateway/" target="_blank" rel="noopener">https://aws.amazon.com/cn/api-gateway/</a></li>
<li>阿里云API网关，<a href="https://www.aliyun.com/product/apigateway/" target="_blank" rel="noopener">https://www.aliyun.com/product/apigateway/</a></li>
<li>腾讯云API网关， <a href="https://cloud.tencent.com/product/apigateway" target="_blank" rel="noopener">https://cloud.tencent.com/product/apigateway</a></li>
</ul>
<p>自开发解决方案：</p>
<ul>
<li>基于Nginx+Lua+ OpenResty的方案，可以看到Kong,orange都是基于这个方案</li>
<li>基于Netty、非阻塞IO模型。 通过网上搜索可以看到国内的宜人贷等一些公司是基于这种方案，是一种成熟的方案。</li>
<li>基于Node.js的方案。 这种方案是应用了Node.js天生的非阻塞的特性。</li>
<li>基于java Servlet的方案。 zuul基于的就是这种方案，这种方案的效率不高，这也是zuul总是被诟病的原因。</li>
</ul>
<h3 id="怎么选择API网关"><a href="#怎么选择API网关" class="headerlink" title="怎么选择API网关"></a>怎么选择API网关</h3><p>如果是要选择一款已有的API网关，那么需要从以下几个方面去考虑。</p>
<p>1、性能与可用性<br>如果一旦采用了API网关，那么API网关就会作为企业应用核心，因此性能和可用性是必须要求的。</p>
<p>从性能上来说，需要让网关增加的时间消耗越短越好，个人觉得需要10ms以下。 系统需要采用非阻塞的IO，如epoll，NIO等。网关和各种依赖的交互也需要是非阻塞的，这样才能保证整体系统的高可用性，如：Node.js的响应式编程和基于java体现的RxJava和Future。<br>网关必须支持集群部署，任务一台服务器的crash都应该不影响整体系统的可用性。</p>
<p>多套网关应该支持同一管理平台和同一监控中心。 如： 一个企业的OpenAPI网关和内部应用的多个系统群的不同的微服务网关可以在同一监控中心进行监控。</p>
<p>2、可扩展性、可维护性</p>
<p>一款产品总有不能满足生产需求的地方，因此需求思考产品在如何进行二次开发和维护，是否方便公司团队接手维护产品。</p>
<p>3、需求匹配度</p>
<p>需要评估各API网关在需求上是否能满足，如： 如果是OpenAPI平台需要使用API网关，那么需要看API网关在合作伙伴应用接入、合作伙伴门户集成、访问次数限额等OpenAPI核心需求上去思考产品是否能满足要求。 如果是微服务网关，那么要从微服务的运维、监控、管理等方面去思考产品是否足够强大。</p>
<p>4、是否开源？公司是否有自开发的能力？</p>
<p>现有的开源产品如kong，zuul，orange都有基础的API网关的核心功能，这些开源产品大多离很好的使用有一定的距离，如：没有提供管理功能的UI界面、监控功能弱小，不支持OpenAPI平台，没有公司运营与运维的功能等。 当然开源产品能获取源代码，如果公司有比较强的研发能力，能hold住这些开源产品，经过二次开发kong、zuul应该还是适应一些公司，不过需求注意以下一些点：</p>
<p>kong是基于ngnix+lua的，从公司的角度比较难于找到能去维护这种架构产品的人。 需求评估当前公司是否有这个能力去维护这个产品。</p>
<p>zuul因为架构的原因在高并发的情况下性能不高，同时需要去基于研究整合开源的适配zuul的监控和管理系统。<br>orange由于没有被大量使用，同时是国内个人在开源，在可持续性和社区资源上不够丰富，出了问题后可能不容易找到人问。<br>另外kong提供企业版本的API网关，当然也是基于ngnix+lua的，企业版本可以购买他们的技术支持、培训等服务、以及拥有界面的管理、监控等功能。</p>
<p>5、公有云还是私有云</p>
<p>现在的亚马逊、阿里、腾讯云都在提供基础公有云的API网关，当然这些网关的基础功能肯定是没有问题，但是二次开发，扩展功能、监控功能可能就不能满足部分用户的定制需求了。另外很多企业因为自身信息安全的原因，不能使用外网公有网的API网关服务，这样就只有选择私有云的方案了。<br>在需求上如果基于公有云的API网关只能做到由内部人员为外网人员申请应用，无法做到定制的合作伙伴门户，这也不适合于部分企业的需求。<br>如果作为微服务网关，大多数情况下是希望网关服务器和服务提供方服务器是要在内网的，在这里情况下也只有私有云的API网关才能满足需求。</p>
<p>综合上面的分析，基础公有云的API网关只有满足一部分简单客户的需求，对于很多企业来说私有云的API网关才是正确的选择。</p>
<h2 id="项目中如何保证接口的幂等操作"><a href="#项目中如何保证接口的幂等操作" class="headerlink" title="项目中如何保证接口的幂等操作"></a>项目中如何保证接口的幂等操作</h2><ul>
<li>调用者给消息一个唯一请求ID标识。ID标识一个工作单元，这个工作单元只应执行一次，工作单元ID可以是Schema的一部分，也可以是一个定制的SOAP Header，服务的Contract 可以说明这个唯一请求ID标识是必须的</li>
<li>接收者在执行一个工作单元必须先检验该工作单元是否已经执行过。检查是否执行的逻辑通常是根据唯一请求ID ，在服务端查询请求是否有记录，是否有对应的响应信息，如果有，直接把响应信息查询后返回；如果没有，那么就当做新请求去处理</li>
</ul>
<h2 id="遇到过线上服务器CPU飙高的情况没有，如何处理的？"><a href="#遇到过线上服务器CPU飙高的情况没有，如何处理的？" class="headerlink" title="遇到过线上服务器CPU飙高的情况没有，如何处理的？"></a>遇到过线上服务器CPU飙高的情况没有，如何处理的？</h2><ul>
<li><p>登录服务器，执行top命令，查看CPU占用情况（top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器，通过以上命令，我们可以看到，进程ID为1893的Java进程的CPU占用率达到了181%，基本可以定位到是我们的Java应用导致整个服务器的CPU占用率飙升）</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$top</span></span><br><span class="line">PID<span class="built_in"> USER </span>     PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">1893 admin     20   0 7127m 2.6g  38m S 181.7 32.6  10:20.26 java</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java是单进程多线程的，那么，我们接下来看看PID=1893的这个Java进程中的各个线程的CPU使用情况，同样是用top命令,通过top -Hp 1893命令，我们可以发现，当前1893这个进程中，ID为4519的线程占用CPU最高。</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$top</span> -Hp 1893</span><br><span class="line">PID<span class="built_in"> USER </span>     PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">4519 admin     20   0 7127m 2.6g  38m R 18.6 32.6   0:40.11 java</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过top命令，我们目前已经定位到导致CPU使用率较高的具体线程， 那么我么接下来就定位下到底是哪一行代码存在问题。首先，我们需要把4519这个线程转成16进制</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">printf</span> %x 4519</span></span><br><span class="line">11a7</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，通过jstack命令，查看栈信息(通过以上代码，我们可以清楚的看到，BeanValidator.java的第30行是有可能存在问题的)：</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$sudo -u admin  jstack <span class="number">1893</span> |grep -A <span class="number">200</span> <span class="number">11</span>a7</span><br><span class="line"><span class="string">"HSFBizProcessor-DEFAULT-8-thread-5"</span> <span class="comment">#500 daemon prio=10 os_prio=0 tid=0x00007f632314a800 nid=0x11a2 runnable [0x000000005442a000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">  <span class="keyword">at</span> sun.misc.URLClassPath$Loader.findResource(URLClassPath.java:<span class="number">684</span>)</span><br><span class="line">  <span class="keyword">at</span> sun.misc.URLClassPath.findResource(URLClassPath.java:<span class="number">188</span>)</span><br><span class="line">  <span class="keyword">at</span> java.net.URLClassLoader$<span class="number">2.</span><span class="built_in">run</span>(URLClassLoader.java:<span class="number">569</span>)</span><br><span class="line">  <span class="keyword">at</span> java.net.URLClassLoader$<span class="number">2.</span><span class="built_in">run</span>(URLClassLoader.java:<span class="number">567</span>)</span><br><span class="line">  <span class="keyword">at</span> java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">  <span class="keyword">at</span> java.net.URLClassLoader.findResource(URLClassLoader.java:<span class="number">566</span>)</span><br><span class="line">  <span class="keyword">at</span> java.lang.ClassLoader.getResource(ClassLoader.java:<span class="number">1093</span>)</span><br><span class="line">  <span class="keyword">at</span> java.net.URLClassLoader.getResourceAsStream(URLClassLoader.java:<span class="number">232</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.xml.ValidationXmlParser.getInputStreamForPath(ValidationXmlParser.java:<span class="number">248</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.xml.ValidationXmlParser.getValidationConfig(ValidationXmlParser.java:<span class="number">191</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.xml.ValidationXmlParser.parseValidationXml(ValidationXmlParser.java:<span class="number">65</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.engine.ConfigurationImpl.parseValidationXml(ConfigurationImpl.java:<span class="number">287</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.engine.ConfigurationImpl.buildValidatorFactory(ConfigurationImpl.java:<span class="number">174</span>)</span><br><span class="line">  <span class="keyword">at</span> javax.validation.Validation.buildDefaultValidatorFactory(Validation.java:<span class="number">111</span>)</span><br><span class="line">  <span class="keyword">at</span> com.test.common.util.BeanValidator.validate(BeanValidator.java:<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>线上问题排查还可以使用Alibaba开源的工具Arthas进行排查，以上问题，可以使用一下命令定位<code>thread -n 3</code>。</p>
</li>
</ul>
<h2 id="如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？"><a href="#如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？" class="headerlink" title="如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？"></a>如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？</h2><ul>
<li>stack栈：是自动分配变量，以及函数调用的时候所使用的一些空间。地址是由高向低减少的。由编译器自动分配内存空间，代码结束，自动释放内存空间。它的内部结构是一个容器式，只有一个进口，并且也作为出口。这就是导致，先进来的数据在“容器”底部，后进来的数据在“容器顶部”，出栈的时候，就应验了“后进先出，先进后出”的这句话。</li>
<li>对于栈来说，理论上线性表的操作特性它都具备，可由于它的特殊性，所以针对它的操作上会有些变化。特别是插入和删除操作，我们改名为push和pop，进栈和出栈。</li>
<li>主要用途：函数调用和返回，数字转字符，表达式求值，走迷宫等等。只要数据的保存满足先进后出的原理，都优先考虑使用栈，所以栈是计算机中不可缺的机制。</li>
<li>建立Stack数组时需要为每一个Stack元素初始化一个对象<h2 id="分布式锁的实现、对比Redis分布式锁-amp-ZK分布式锁"><a href="#分布式锁的实现、对比Redis分布式锁-amp-ZK分布式锁" class="headerlink" title="分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁"></a>分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁</h2></li>
<li>redis分布式锁<ul>
<li>简单算法：是redis官方支持的分布式锁算法。这个分布式锁有3个重要的考量点，互斥（只能有一个客户端获取锁），不能死锁，容错（大部分redis节点或者这个锁就可以加可以释放），第一个最普通的实现方式，如果就是在redis里创建一个key算加锁。SET my:lock 随机值 NX PX 30000，这个命令就ok，这个的NX的意思就是只有key不存在的时候才会设置成功，PX 30000的意思是30秒后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。为啥要用随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除key的话会有问题，所以得用随机值加上面的lua脚本来释放锁。但是这样是肯定不行的。因为如果是普通的redis单实例，那就是单点故障。或者是redis普通主从，那redis主从异步复制，如果主节点挂了，key还没同步到从节点，此时从节点切换为主节点，别人就会拿到锁。<ul>
<li>RedLock算法：这个场景是假设有一个redis cluster，有5个redis master实例。然后执行如下步骤获取一把锁<pre><code>1. 获取当前时间戳，单位是毫秒；
2. 跟上面类似，轮流尝试在每个master节点上创建锁，过期时间较短，一般就几十毫秒；
3. 尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点（n / 2 +1）；
4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；
5. 要是锁建立失败了，那么就依次删除这个锁；
6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>zk分布式锁<ul>
<li>zk分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新枷锁。</li>
</ul>
</li>
<li>redis分布式锁和zk分布式锁的对比：redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能；zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。另外一点就是，如果是redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁；而zk的话，因为创建的是临时znode，只要客户端挂了，znode就没了，此时就自动释放锁。redis分布式锁大家每发现好麻烦吗？遍历上锁，计算时间等等。zk的分布式锁语义清晰实现简单。所以先不分析太多的东西，就说这两点，我个人实践认为zk的分布式锁比redis的分布式锁牢靠、而且模型简单易用。</li>
</ul>
<h2 id="项目中系统监控怎么做的"><a href="#项目中系统监控怎么做的" class="headerlink" title="项目中系统监控怎么做的"></a>项目中系统监控怎么做的</h2><ul>
<li>集中式日志系统<ul>
<li>Elasticsearch</li>
<li>Logstash</li>
<li>Kibana</li>
<li>Beats</li>
</ul>
</li>
<li>集中式度量系统<ul>
<li>Prometheus</li>
<li>Cat</li>
</ul>
</li>
<li>分布式追踪系统<ul>
<li>Zipkin</li>
<li>Pinpoint</li>
<li>Skywalking</li>
<li>Jaeger</li>
</ul>
</li>
</ul>
<h2 id="如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量"><a href="#如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量" class="headerlink" title="如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量"></a>如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量</h2><ul>
<li>正数位（占1比特）+时间戳（占41比特）+机械id（占5比特）+数据中心（占5比特）+自增值（占12比特），总共64比特组成的一个Long类型。</li>
<li>时间戳（占41个比特）：毫秒数，大约可以使使用69年</li>
<li>机械id（占5个比特）：即2的5次方等于32个机器</li>
<li>数据中心id（占5个比特）：即2的5次方等于32个数据中心</li>
<li>自增值（占12比特）：2的12次方等于4096。也就是说每毫秒最多可以生成4096个id，如果cpu生产id的速度大于每毫秒4096个，那么需要使线程进行等待到下一毫秒，重新计数获取自增值。</li>
<li>好处<ul>
<li>生成的id是一个数字的Long类型</li>
<li>无需链接数据库或者redis，超高性能</li>
</ul>
</li>
<li>弊端<ul>
<li>每毫秒只能生成4096个id。随着cpu不断的进步，每毫秒4096个id将不能满足。可以不用担心，即便cpu性能超过了这个值，那么只需等待到下一个毫秒</li>
<li>只能使用69年</li>
<li>每毫秒重新计数，空闲时间会浪费很多id空间</li>
<li>系统时间不可回退，回退将会导致id重复。另：系统时间可以前进，不受影响</li>
</ul>
</li>
</ul>
<h2 id="如何设计一个秒杀系统？"><a href="#如何设计一个秒杀系统？" class="headerlink" title="如何设计一个秒杀系统？"></a>如何设计一个秒杀系统？</h2><ul>
<li>同样是高并发场景，三类业务的架构挑战不一样<ul>
<li>QQ类业务，用户主要读写自己的数据，访问基本带有uid属性，数据访问锁冲突较小</li>
<li>微博类业务，用户的feed主页由别人发布的消息构成，数据读写有一定锁冲突</li>
<li>12306类业务，并发量很高，几乎所有的读写锁冲突都集中在少量数据上，难度最大</li>
</ul>
</li>
<li>将请求尽量拦截在系统上游，而不要让锁冲突落到数据库。传统秒杀系统之所以挂，是因为请求都压到了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，访问流量大，下单成功的有效流量小。一趟火车2000张票，200w个人同时来买，没有人能买成功，请求有效率为0。画外音：此时系统的效率，还不如线下售票窗口。</li>
<li>充分利用缓存,秒杀买票，这是一个典型的读多写少的业务场景：<ul>
<li>车次查询，读，量大</li>
<li>余票查询，读，量大</li>
<li>下单和支付，写，量小<br>一趟火车2000张票，200w个人同时来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。</li>
</ul>
</li>
<li>秒杀业务，常见的系统分层架构</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG242.png" alt="image"></p>
<ul>
<li><p>秒杀业务，可以使用典型的服务化分层架构</p>
<ul>
<li>端（浏览器/APP），最上层，面向用户<ul>
<li>JS层面，可以限制用户在x秒之内只能提交一次请求，从而降低系统负载。</li>
<li>APP层面，可以做类似的事情，虽然用户疯狂的在摇微信抢红包，但其实x秒才向后端发起一次请求。</li>
<li>不过，端上的拦截只能挡住普通用户（99%的用户是普通用户），程序员firebug一抓包，写个for循环直接调用后端http接口，js拦截根本不起作用，这下怎么办？</li>
</ul>
</li>
<li>站点层，访问后端数据，拼装html/json返回，如何抗住程序员写for循环调用http接口，首先要确定用户的唯一标识，对于频繁访问的用户予以拦截。<ul>
<li>购票类业务都需要登录，用uid就能标识用户，在站点层，对同一个uid的请求进行计数和限速，例如：一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。</li>
<li>一个uid，5s只透过一个请求，其余的请求怎么办，缓存，页面缓存，5秒内到达站点层的其他请求，均返回上次返回的页面。</li>
<li>OK，通过计数、限速、页面缓存拦住了99%的普通程序员，但仍有些高端程序员，例如黑客，控制了10w个肉鸡，手里有10w个uid，同时发请求，这下怎么办</li>
</ul>
</li>
<li><p>服务层的请求拦截</p>
<ul>
<li><p>服务层非常清楚业务的库存，非常清楚数据库的抗压能力，可以根据这两者进行削峰限速。例如，业务服务很清楚的知道，一列火车只有2000张车票，此时透传10w个请求去数据库，是没有意义的。用什么削峰？请求队，对于写请求，做请求队列，每次只透传有限的写请求去数据层（下订单，支付这样的写业务）。只有2000张火车票，即使10w个请求过来，也只透传2000个去访问数据库：</p>
<ul>
<li>如果前一批请求均成功，再放下一批</li>
<li><p>如果前一批请求库存已经不足，则后续请求全部返回“已售罄”</p>
<p>对于读请求，怎么优化？<br>cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。<br>如此削峰限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99%的请求被拦住了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库层,<br>经过前三层的优化：</p>
<ul>
<li>浏览器拦截了80%请求</li>
<li>站点层拦截了99%请求，并做了页面缓存</li>
<li><p>服务层根据业务库存，以及数据库抗压能力，做了写请求队列与数据缓存</p>
<p>你会发现，每次透到数据库层的请求都是可控的。<br>db基本就没什么压力了，闲庭信步。此时，透2000个到数据库，全部成功，请求有效率100%。</p>
</li>
</ul>
</li>
<li>按照上面的优化方案，其实压力最大的反而是站点层，假设真实有效的请求数是每秒100w，这部分的压力怎么处理？<ul>
<li>站点层水平扩展，通过加机器扩容，一台抗5000，200台搞定；</li>
<li>服务降级，抛弃请求，例如抛弃50%；</li>
<li>原则是要保护系统，不能让所有用户都失败。</li>
</ul>
</li>
<li>站点层限速，是个每个uid的请求计数放到redis里么？吞吐量很大情况下，高并发访问redis，网络带宽会不会成为瓶颈？<ul>
<li>同一个uid计数与限速，如果担心访问redis带宽成为瓶颈，可以这么优化<ul>
<li>计数直接放在内存，这样就省去了网络请求；</li>
<li>在nginx层做7层均衡，让一个uid的请求落到同一个机器上；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>除了系统上的优化，产品与业务还能够做一些折衷，降低架构难度。<ul>
<li>业务折衷一,一般来说，下单和支付放在同一个流程里，能够提高转化率。对于秒杀场景，产品上，下单流程和支付流程异步，放在两个环节里，能够降低数据库写压力。以12306为例，下单成功后，系统占住库存，45分钟之内支付即可。</li>
<li>业务折衷二,一般来说，所有用户规则相同，体验会更好。对于秒杀场景，产品上，不同地域分时售票，虽然不是所有用户规则相同，但能够极大降低系统压力。北京9:00开始售票，上海9:30开始售票，广州XX开始售票，能够分担系统压力。</li>
<li>业务折衷三,秒杀场景，由于短时间内并发较大，系统返回较慢，用户心情十分焦急，可能会频繁点击按钮，对系统造成压力。产品上可以优化为，一旦点击，不管系统是否返回，按钮立刻置灰，不给用户机会频繁点击。</li>
<li>业务折衷四,一般来说，显示具体的库存数量，能够加强用户体验。对于秒杀场景，产品上，只显示有/无车票，而不是显示具体票数目，能够降低缓存淘汰率。<br>画外音：显示库存会淘汰N次，显示有无只会淘汰1次。更多的，用户关注是否有票，而不是票有几张。</li>
</ul>
</li>
<li>总结,对于秒杀系统，除了产品和业务上的折衷，架构设计上主要有两大优化方向<ul>
<li>尽量将请求拦截在系统上游；</li>
<li>读多写少用缓存；</li>
</ul>
</li>
</ul>
<h2 id="如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？"><a href="#如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？" class="headerlink" title="如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？"></a>如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？</h2><ul>
<li>Cache住所有查询，两层cache：除了使用ckv做全量缓存，还在数据访问层dao中增加本机内存cache做二级缓存，cache住所有读请求。查询失败或者查询不存在时，降级内存cache；内存cache查询失败或记录不存在时降级DB。DB本身不做读写分离。</li>
<li>DB写同步cache，容忍少量不一致。DB写操作完成后，dao中同步内存cache，业务服务层同步ckv，失败由异步队列补偿，定时的ckv与DB备机对账，保证最终数据一致。</li>
</ul>
<h2 id="服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？"><a href="#服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？" class="headerlink" title="服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？"></a>服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？</h2><p>欢迎补充。。。。。</p>
<h2 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h2><p>一致性哈希（Consistent hashing）算法是由 MIT 的Karger 等人与1997年在一篇学术论文（《Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web》）中提出来的，用于解决分布式缓存数据分布问题。在传统的哈希算法下，每条缓存数据落在那个节点是通过哈希算法和服务器节点数量计算出来的，一旦服务器节点数量发生增加或者介绍，哈希值需要重新计算，此时几乎所有的数据和服务器节点的对应关系也会随之发生变化，进而会造成绝大多数缓存的失效。一致性哈希算法通过环形结构和虚拟节点的概念，确保了在缓存服务器节点数量发生变化时大部分数据保持原地不动，从而大幅提高了缓存的有效性。下面我们通过例子来解释一致性哈希的原理。</p>
<p>比如有 n 个节点，对于缓存 数据（k，v）具体存在哪个节点往往 hash(k) % n 来计算处理，举一个例子如下表所示，一共有个3个节点，hash函数采用 md5 。</p>
<table>
<thead>
<tr>
<th>缓存key</th>
<th>hash(k) % n</th>
<th>服务器节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_nick_rommel</td>
<td>1</td>
<td>192.168.56.101</td>
</tr>
<tr>
<td>user_nick_pandy</td>
<td>0</td>
<td>192.168.56.100</td>
</tr>
<tr>
<td>user_nick_sam</td>
<td>2</td>
<td>192.168.56.102</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Md5 的计算结果一般是一串32位的16进制字符串，做取模运算时原始数字较长，实际使用时，可以只截取最后4位或者8位使用，因为hash函数具有随机性，当数据量足球大时，截取部分数据也能保证数据的均匀分布。比如 md5(‘user_nick_rommel’)，对应字符串为 29e4fd2a0f05bd63343ae2276ca5038e，取最后4位 038e 转成10进制整数在进行取模运算，038e 对应的10进制数为 910，取模计算得 1 (9102 % 3 = 1)。</p>
</blockquote>
<p> 如果此时对缓存服务器进行扩容，添加一个新节点如 192.168.56.103，那么按照上面的计算方式，n 变为4， 得到的结果如下：</p>
<table>
<thead>
<tr>
<th>缓存key</th>
<th>hash(k) % n</th>
<th>服务器节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_nick_rommel</td>
<td>2</td>
<td>192.168.56.102</td>
</tr>
<tr>
<td>user_nick_pandy</td>
<td>2</td>
<td>192.168.56.102</td>
</tr>
<tr>
<td>user_nick_sam</td>
<td>3</td>
<td>192.168.56.103</td>
</tr>
</tbody>
</table>
<p>从结果中可见，缓存对应关系完全发生改变，比如 user_nick_rommel 这个可以，添加节点钱可以从 192.168.56.101 中读到，添加节点后却读不到了，。一般缓存失效时应用程序都会重新从后端服务加载数据（比如数据库），以这种这种方式分配缓存，当缓节点数量发生改变时，会造成大面积的缓存失效，这回造成后端服务瞬间压力上升，压力过大会造成服务不可以用，如果服务出于关键节点，甚至还会引发雪崩效应（TODO）。</p>
<p>在实际应用中，缓存节点由于故障挂掉，或者空间不足而进行扩容，缓存节点的增减是比较常见的事情，但上面传统方式会使服务的不可靠，下面看下一致性哈希是如何解决这个问题的。</p>
<p>在一致性哈希算法中，首先将哈希空间映射到一个虚拟的环上，环上的数值分从 0 到 2^32-1（哈希值的范围），如下图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/D2CFEC7D-5ACB-49C3-B67F-12BA52254454.png" alt="image"></p>
<blockquote>
<p>在一致性哈希算法刚提出来的时候，32位系统还是主流，2^32-1 相当于最大Integer，现在的应用服务器普遍都是64位系统，在使用使用一致性哈希算法时可以根据实际情况适当变通，比如将哈希值空间放大到 2^64-1。</p>
</blockquote>
<p> 然后使用同样的哈希算法将缓存服务节点（通常通过服务器IP+端口作为节点的key）和数据键映射到环上的位置。再决定数据落在那台服务器上时，使用一致的方向（比如顺时针方向）沿环查找，遇到的第一个有效服务器就是缓存保存的地方，如图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/7D4C84D6-8843-42FC-AAB4-C5D5EA308C1B.png" alt="image"></p>
<p>当有新的服务器节点加入时，按照同样的哈希算法将新节点映射到环上的某处位置，和新节点相邻的数据逆时针节点会进行迁移，其他节点保持不变。如下图，当新加入一台新服务器 192.168.56.104 时，user_nick_pandy 这条缓存数据的请求根据算法会落在192.168.56.104 这台及其上，其他节点不受任何影响。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/A026DF6E-060A-4295-83CB-FC4A7D229A03.png" alt="image"></p>
<p>另外，由于哈希计算的记过通常都比较随机，如果缓存服务器比较少的话，可能会出现数据分配冷热不均的问题，如下图所示，大部分数据都会存储在 node3 节点上。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/26145228-2DA8-4168-BBE9-DA99F4BD0016.png" alt="image"></p>
<p>为了解决这个问题，我们引入虚拟节点的概念，在实体服务器不增加的情况下，用多个虚拟节点替代原来的单个实体节点，一台服务服务器在环上就对应多个位置，这样可以让数据存储更加均匀，各服务器的负载页更加平衡，如图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9B7CB81A-434E-4C33-B65E-3821C19E3B70.png" alt="image"></p>
<p>使用 Java 代码实现一致性哈希的例子如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.SortedMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class ConsistentHashingTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真实缓存地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span>[] cacheServers = &#123; <span class="string">"192.168.56.101:11211"</span>, <span class="string">"192.168.56.102:11211"</span>, <span class="string">"192.168.56.103:11211"</span> &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存虚拟节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Long, <span class="keyword">String</span>&gt; nodes = <span class="keyword">new</span> TreeMap&lt;Long, <span class="keyword">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个虚拟节点的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">int</span> VIRTUAL_NODE_NUM = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConsistentHashingTest()&#123;</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">String</span> eachServer : cacheServers) &#123;</span><br><span class="line">           <span class="keyword">this</span>.addNode(eachServer);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建虚拟节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> addNode(<span class="keyword">String</span> nodeKey) &#123;</span><br><span class="line">       <span class="comment">//为每一个实体节点创建3个虚拟节点</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_NUM; i++) &#123;</span><br><span class="line">           <span class="keyword">long</span> eachHashCode = <span class="keyword">this</span>.hash(nodeKey + <span class="string">":"</span> + i);</span><br><span class="line">           nodes.put(eachHashCode, nodeKey);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hash 函数 可以使用 md5, sha-1, sha-256 等</span></span><br><span class="line">    <span class="comment">// 虽然 md5, sha-1 哈希算法在签名领域已经不再安全，但运算速度比较快，在非安全领域是可以使用的。</span></span><br><span class="line">    <span class="comment">// DigestUtils 是来自于 apache 中的 org.apache.commons.codec.digest 中的工具类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> hash(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">       Stringmd5key = DigestUtils.md5Hex(<span class="built_in">key</span>);</span><br><span class="line">       <span class="keyword">return</span> Long.parseLong(md5key.substring(<span class="number">0</span>, <span class="number">15</span>), <span class="number">16</span>) % ((<span class="keyword">long</span>) Math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照同一个方向寻找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getRealServer(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">       <span class="keyword">long</span> hashCode = <span class="keyword">this</span>.hash(<span class="built_in">key</span>);</span><br><span class="line">       SortedMap&lt;Long,<span class="keyword">String</span>&gt; tailMap =</span><br><span class="line">              nodes.tailMap(hashCode);</span><br><span class="line">       <span class="keyword">long</span> serverKey = tailMap.isEmpty() ? nodes.firstKey() : tailMap.firstKey(); </span><br><span class="line">       <span class="keyword">return</span> nodes.<span class="built_in">get</span>(serverKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">       ConsistentHashingTestt = <span class="keyword">new</span> ConsistentHashingTest();</span><br><span class="line">       System.out.<span class="built_in">println</span>(t.getRealServer(<span class="string">"my-cache-key"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，前文提到的（TODO 章节）Guava Cache 框架支持一致性哈希，实例代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体缓存服务器</span></span><br><span class="line"><span class="keyword">String</span>[]cacheServers = &#123; <span class="string">"192.168.56.101:11211"</span>, <span class="string">"192.168.56.102:11211"</span>, <span class="string">"192.168.56.103:11211"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存数据的key</span></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">key</span> = <span class="string">"my-test-cache-key"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算缓存 key 对应的 hash 值，这里使用 MurmurHash 算法，MurmurHash 是一种高性能低碰撞的算法。此外，还支持  md5、sha1/sha256/sha512、orc32、adler32 等哈希算法。 </span></span><br><span class="line">HashCode hashCode = Hashing.murmur3_32().newHasher().putString(<span class="built_in">key</span>, Charsets.UTF_8).hash();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一致性哈希方式计算，缓存key对应的服务器主机是那一台，bucket 的范围在 0 ~ cacheServers.length -1</span></span><br><span class="line"><span class="built_in">int</span> bucket = Hashing.consistentHash(hashCode, cacheServers.length);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/D2CFEC7D-5ACB-49C3-B67F-12BA52254454.png" alt="image"></p>
<h2 id="多路复用的几种方式以及区别？"><a href="#多路复用的几种方式以及区别？" class="headerlink" title="多路复用的几种方式以及区别？"></a>多路复用的几种方式以及区别？</h2><ul>
<li>select的优缺点<ul>
<li>优点<ul>
<li>select的可移植性好，在某些unix下不支持poll。</li>
<li>select对超时值提供了很好的精度，精确到微秒，而poll式毫秒。</li>
</ul>
</li>
<li>缺点<ul>
<li>单个进程可监视的fd数量被限制，默认是1024。</li>
<li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
<li>对fd进行扫描时是线性扫描，fd剧增后，IO效率降低，每次调用都对fd进行线性扫描遍历，随着fd的增加会造成遍历速度慢的问题。</li>
<li>select函数超时参数在返回时也是未定义的，考虑到可移植性，每次超时之后进入下一个select之前都要重新设置超时参数。</li>
</ul>
</li>
</ul>
</li>
<li>poll的优缺点<ul>
<li>优点<ul>
<li>不要求计算最大文件描述符+1的大小。</li>
<li>应付大数量的文件描述符时比select要快。</li>
<li>没有最大连接数的限制是基于链表存储的。</li>
</ul>
</li>
<li>缺点<ul>
<li>大量的fd数组被整体复制于内核态和用户态之间，而不管这样的复制是不是有意义。</li>
<li>同select相同的是调用结束后需要轮询来获取就绪描述符。</li>
</ul>
</li>
</ul>
</li>
<li><p>epoll的优缺点（epoll详解）</p>
<ul>
<li><p>支持一个进程打开大数目的socket描述符(FD)</p>
<p>  select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显 然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>
</li>
<li><p>IO效率不随FD数目增加而线性下降</p>
<p>  传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行 操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。</p>
</li>
<li><p>epoll工作的两种模式</p>
<p>  EPOLL事件分发系统可以运转在两种模式下：边缘触发Edge Triggered (ET)、水平触发Level Triggered (LT)。<br>  LT 是缺省的工作方式：同时支持block和no-block socket；在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。<br>  ET是高速工作方式：它只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述 符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知。<br>  对于LT模式<code>epoll_wait</code>清空就绪链表之后会检查该文件描述符是哪一种模式，如果为LT模式，且必须该节点确实有事件未处理，那么就会把该节点重新放入到刚刚删除掉的且刚准备好的就绪链表，<code>epoll_wait</code>马上返回。而ET模式不会检查，只会调用一次，只通知就绪通知一次 。 </p>
</li>
<li>epoll函数底层实现过程<br>  首先<code>epoll_create</code>创建一个epoll文件描述符，底层同时创建一个红黑树，和一个就绪链表；红黑树存储所监控的文件描述符的节点数据，就绪链表存储就绪的文件描述符的节点数据；<code>epoll_ctl</code>将会添加新的描述符，首先判断是红黑树上是否有此文件描述符节点，如果有，则立即返回。如果没有， 则在树干上插入新的节点，并且告知内核注册回调函数。当接收到某个文件描述符过来数据时，那么内核将该节点插入到就绪链表里面。<code>epoll_wait</code>将会接收到消息，并且将数据拷贝到用户空间，清空链表。对于LT模式<code>epoll_ctl</code>清空就绪链表之后会检查该文件描述符是哪一种模式，如果为LT模式，且必须该节点确实有事件未处理，那么就会把该节点重新放入到刚刚删除掉的且刚准备好的就绪链表，<code>epoll_wait</code>马上返回。ET模式不会检查，只会调用一次</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/06/01/面试分享(三).数据库相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/面试分享(三).数据库相关/" itemprop="url">面试分享(三).数据库相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T18:33:00+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/01/面试分享(三).数据库相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/06/01/面试分享(三).数据库相关/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><h2 id="读过MyBatis源码没有？"><a href="#读过MyBatis源码没有？" class="headerlink" title="读过MyBatis源码没有？"></a>读过MyBatis源码没有？</h2><p><a href="https://www.cnblogs.com/zhjh256/p/8512392.html" target="_blank" rel="noopener">可以参考本文</a></p>
<h2 id="聊一聊对分库分表的理解"><a href="#聊一聊对分库分表的理解" class="headerlink" title="聊一聊对分库分表的理解"></a>聊一聊对分库分表的理解</h2><h3 id="大众点评设计案例"><a href="#大众点评设计案例" class="headerlink" title="大众点评设计案例"></a>大众点评设计案例</h3><p>原大众点评的订单单表早就已经突破两百G，由于查询维度较多，即使加了两个从库，优化索引，仍然存在很多查询不理想的情况。去年大量抢购活动的开展，使数据库达到瓶颈，应用只能通过限速、异步队列等对其进行保护；业务需求层出不穷，原有的订单模型很难满足业务需求，但是基于原订单表的DDL又非常吃力，无法达到业务要求。随着这些问题越来越突出，订单数据库的切分就愈发急迫了。这次切分，我们的目标是未来十年内不需要担心订单容量的问题。先对订单库进行垂直切分，将原有的订单库分为基础订单库、订单流程库等。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1b24c0df.png" alt="image"><br>垂直切分缓解了原来单集群的压力，但是在抢购时依然捉襟见肘。原有的订单模型已经无法满足业务需求，于是我们设计了一套新的统一订单模型，为同时满足C端用户、B端商户、客服、运营等的需求，我们分别通过用户ID和商户ID进行切分，并通过PUMA（我们内部开发的MySQL binlog实时解析服务）同步到一个运营库。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/8aff3f22.png" alt="image"></p>
<ul>
<li>切分策略<ul>
<li>查询切分：将ID和库的Mapping关系记录在一个单独的库中。优点：ID和库的Mapping算法可以随意更改。缺点：引入额外的单点。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/ddb1ceb8.png" alt="image"></li>
<li>范围切分：比如按照时间区间或ID区间来切分。优点：单表大小可控，天然水平扩展。缺点：无法解决集中写入瓶颈的问题。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/f80cafa2.png" alt="image"></li>
<li>Hash切分：一般采用Mod来切分，下面着重讲一下Mod的策略。数据水平切分后我们希望是一劳永逸或者是易于水平扩展的，所以推荐采用mod 2^n这种一致性Hash。以统一订单库为例，我们分库分表的方案是32*32的，即通过UserId后四位mod 32分到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024张表。线上部署情况为8个集群(主从)，每个集群4个库。为什么说这种方式是易于水平扩展的呢？我们分析如下两个场景。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/52610d6d.png" alt="image"><ul>
<li>场景一：数据库性能达到瓶颈<ul>
<li>方法一：按照现有规则不变，可以直接扩展到32个数据库集群。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/b301cb95.png" alt="image"></li>
<li>方法二：如果32个集群也无法满足需求，那么将分库分表规则调整为(32<em>2^n)</em>(32⁄2^n)，可以达到最多1024个集群。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c573941e.png" alt="image"></li>
</ul>
</li>
<li>场景二：单表容量达到瓶颈（或者1024已经无法满足你）<br>  方法：假如单表都已突破200G，200<em>1024=200T（按照现有的订单模型算了算，大概一万千亿订单，相信这一天，嗯，指日可待！），没关系，32     </em>(32 <em>2^n)，这时分库规则不变，单库里的表再进行裂变，当然，在目前订单这种规则下（用userId后四位 mod）还是有极限的，因为只有四位，所以最多拆8192个表，至于为什么只取后四位，后面会有篇幅讲到。另外一个维度是通过ShopID进行切分，规则8 </em>8和UserID比较类似，就不再赘述，需要注意的是Shop库我们仅存储了订单主表，用来满足Shop维度的查询。<br>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/494ebd9e.png" alt="image"></li>
</ul>
</li>
</ul>
</li>
<li><p>唯一ID方案：这个方案也很多，主流的有那么几种:</p>
<ul>
<li>利用数据库自增ID：优点：最简单。 缺点：单点风险、单机性能瓶颈。</li>
<li>利用数据库集群并设置相应的步长（Flickr方案）：优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</li>
<li>Twitter Snowflake：优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</li>
<li>一大波GUID、Random算法：优点：简单。 缺点：生成ID较长，有重复几率。</li>
<li><p>我们的方案：为了减少运营成本并减少额外的风险我们排除了所有需要独立集群的方案，采用了带有业务属性的方案： &gt; 时间戳+用户标识码+随机数有下面几个好处：</p>
<ul>
<li>方便、成本低。</li>
<li>基本无重复的可能。</li>
<li>自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。</li>
<li>可排序，因为时间戳在最前面。</li>
</ul>
<p>当然也有一些缺点，比如长度稍长，性能要比int/bigint的稍差等。</p>
</li>
</ul>
</li>
<li>其他问题<ul>
<li>事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</li>
<li>复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在</li>
<li>在线库查询，或者可以通过其他方法转换到切分的维度来实现。</li>
</ul>
</li>
<li><p>数据迁移</p>
<p>  数据库拆分一般是业务发展到一定规模后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗就是个大问题，为此，我们经历了以下几个阶段。</p>
<ul>
<li>第一阶段<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2ae1ba98.png" alt="image"><ul>
<li>数据库双写（事务成功以老模型为准），查询走老模型。</li>
<li>每日job数据对账（通过DW），并将差异补平。</li>
<li>通过job导历史数据。</li>
</ul>
</li>
<li>第二阶段<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0a93304e.png" alt="image"><ul>
<li>历史数据导入完毕并且数据对账无误。</li>
<li>依然是数据库双写，但是事务成功与否以新模型为准，在线查询切新模型。</li>
<li>每日job数据对账，将差异补平。</li>
</ul>
</li>
<li>第三阶段<br>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/a8d54b30.png" alt="image"><ul>
<li>老模型不再同步写入，仅当订单有终态时才会异步补上。</li>
<li>此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。</li>
</ul>
</li>
</ul>
</li>
<li>总结<br>并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。</li>
</ul>
<h3 id="亿级数据下的分库分表方案"><a href="#亿级数据下的分库分表方案" class="headerlink" title="亿级数据下的分库分表方案"></a>亿级数据下的分库分表方案</h3><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。这个方案也不错，它对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作（只是这时候性能一般）。不过它的缺点很明显：很多的资源都受到单机的限制，例如连接数，网络吞吐等。如何进行分区，在实际应用中是一个非常关键的要素之一。在我们的项目中，以客户信息为例，客户数据量5000万加，项目背景要求保存客户的银行卡绑定关系，客户的证件绑定关系，以及客户绑定的业务信息。此业务背景下，该如何设计数据库呢。项目一期的时候，我们建立了一张客户业务绑定关系表，里面冗余了每一位客户绑定的业务信息。基本结构大致如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1086caaj20fa06m761.jpg" alt=""><br>查询时，对银行卡做索引，业务编号做索引，证件号做索引。随着需求大增多，这张表的索引会达到10个以上。而且客户解约再签约，里面会保存两条数据，只是绑定的状态不同。假设我们有5千万的客户，5个业务类型，每位客户平均2张卡，那么这张表的数据量将会达到惊人的5亿，事实上我们系统用户量还没有过百万时就已经不行了。mysql数据库中的数据是以文件的形势存在磁盘上的，默认放在/mysql/data下面（可以通过my.cnf中的datadir来查看）， 一张表主要对应着三个文件，一个是frm存放表结构的，一个是myd存放表数据的，一个是myi存表索引的。这三个文件都非常的庞大，尤其是.myd文件，快5个G了。 下面进行第一次分区优化 ，Mysql支持的分区方式有四种：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e11m0q1wj20fa066tbt.jpg" alt=""><br>在我们的项目中，range分区和list分区没有使用场景，如果基于绑定编号做range或者list分区，绑定编号没有实际的业务含义，无法通过它进行查询，因此，我们就剩下 HASH 分区和 KEY 分区了， HASH 分区仅支持int类型列的分区，且是其中的一列。看看我们的库表结构，发现没有哪一列是int类型的，如何做分区呢？可以增加一列，绑定时间列，将此列设置为int类型，然后按照绑定时间进行分区，将每一天绑定的用户分到同一个区里面去。这次优化之后，我们的插入快了许多，但是查询依然很慢，为什么，因为在做查询的时候，我们也只是根据银行卡或者证件号进行查询，并没有根据时间查询，相当于每次查询，mysql都会将所有的分区表查询一遍。</p>
<p>然后进行第二次方案优化，既然hash分区和key分区要求其中的一列必须是int类型的，那么创造出一个int类型的列出来分区是否可以。分析发现，银行卡的那串数字有秘密。银行卡一般是16位到19位不等的数字串，我们取其中的某一位拿出来作为表分区是否可行呢，通过分析发现，在这串数字中，其中确实有一位是0到9随机生成的，不同的卡串长度，这一位不同，绝不是最后一位，最后位数字一般都是校验位，不具有随机性。我们新设计的方案，基于银行卡号+随机位进行KEY分区，每次查询的时候，通过计算截取出这位随机位数字，再加上卡号，联合查询，达到了分区查询的目的，需要说明的是，分区后，建立的索引，也必须是分区列，否则的话，Mysql还是会在所有的分区表中查询数据。那么通过银行卡号查询绑定关系的问题解决了，那么证件号呢，如何通过证件号来查询绑定关系。前面已经讲过，做索引一定是要在分区健上进行，否则会引起全表扫描。我们再创建了一张新表，保存客户的证件号绑定关系，每位客户的证件号都是唯一的，新的证件号绑定关系表里，证件号作为了主键，那么如何来计算这个分区健呢，客户的证件信息比较庞杂，有身份证号，港澳台通行证，机动车驾驶证等等，如何在无序的证件号里找到分区健。为了解决这个问题，我们将证件号绑定关系表一分为二，其中的一张表专用于保存身份证类型的证件号，另一张表则保存其他证件类型的证件号，在身份证类型的证件绑定关系表中，我们将身份证号中的月数拆分出来作为了分区健，将同一个月出生的客户证件号保存在同一个区，这样分成了12个区，其他证件类型的证件号，数据量不超过10万，就没有必要进行分区了。这样每次查询时，首先通过证件类型确定要去查询哪张表，再计算分区健进行查询。</p>
<p>作了分区设计之后，保存2000万用户数据的时候，银行卡表的数据保存文件就分成了10个小文件，证件表的数据保存文件分成了12个小文件，解决了这两个查询的问题，还剩下一个问题就是，业务编号呢，怎么办，一个客户有多个签约业务，如何进行保存，这时候，采用分区的方案就不太合适了，它需要用到分表的方案。</p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>如何进行分库分表，目前互联网上有许多的版本，比较知名的一些方案：</p>
<ul>
<li>阿里的TDDL，DRDS和cobar</li>
<li>京东金融的sharding-jdbc</li>
<li>民间组织的MyCAT</li>
<li>360的Atlas</li>
<li>美团的zebra</li>
<li>其他比如网易，58，京东等公司都有自研的中间件。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f0ubx3knj20oc0fd45s.jpg" alt=""></p>
<p>百花齐放的景象。但是这么多的分库分表中间件方案，归总起来，就两类： client模式和proxy模式 。</p>
<ul>
<li>client模式<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1osp6e3j20fa0c2ta5.jpg" alt=""></li>
<li>和proxy模式<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1v26i8nj20fa0gxmyt.jpg" alt=""></li>
</ul>
<p>无论是client模式，还是proxy模式，几个核心的步骤是一样的：SQL解析，重写，路由，执行，结果归并。个人比较倾向于采用client模式，它架构简单，性能损耗也比较小，运维成本低。如果在项目中引入mycat或者cobar，他们的单机模式无法保证可靠性，一旦宕机则服务就变得不可用，你又不得不引入HAProxy来实现它的高可用集群部署方案， 为了解决HAProxy的高可用问题，又需要采用Keepalived来实现。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e2eu3bjvj20fa0gy0zk.jpg" alt=""></p>
<p>我们在项目中放弃了这个方案，采用了shardingjdbc的方式。回到刚才的业务问题，如何对业务类型进行分库分表。分库分表第一步也是最重要的一步，即sharding column的选取，sharding column选择的好坏将直接决定整个分库分表方案最终是否成功。而sharding column的选取跟业务强相关。在我们的项目场景中，sharding column无疑最好的选择是业务编号。通过业务编号，将客户不同的绑定签约业务保存到不同的表里面去，查询时，根据业务编号路由到相应的表中进行查询，达到进一步优化sql的目的。</p>
<p>前面我们讲到了基于客户签约绑定业务场景的数据库优化，下面我们再聊一聊，对于海量数据的保存方案。</p>
<h5 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h5><h6 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h6><p>也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p>
<h6 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h6><p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezns2ifaj20bf08kgml.jpg" alt=""></p>
<p>优点</p>
<p>数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于 Web 和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破 IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。</p>
<p>缺点</p>
<ul>
<li>跨库 join 的问题</li>
<li>跨库事务（分布式事务）的问题</li>
</ul>
<p>解决方式</p>
<ul>
<li>全局表<ul>
<li>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库 join 查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</li>
</ul>
</li>
<li>字段冗余<ul>
<li>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免 join 查询。</li>
</ul>
</li>
<li>数据同步<ul>
<li>定时 A 库中的 tab_a 表和 B 库中 tbl_b 有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。例如ETL工具。</li>
</ul>
</li>
<li>系统层组装<ul>
<li>在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。</li>
</ul>
</li>
</ul>
<p>对于每分钟要处理近1000万的流水，每天流水近1亿的量，如何高效的写入和查询，是一项比较大的挑战。还是老办法，分库分表分区，读写分离，只不过这一次，我们先分表，再分库，最后分区。我们将消息流水按照不同的业务类型进行分表，相同业务的消息流水进入同一张表，分表完成之后，再进行分库。我们将流水相关的数据单独保存到一个库里面去，这些数据，写入要求高，查询和更新到要求低，将它们和那些更新频繁的数据区分开。分库之后，再进行分区。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e30hgeqaj20fa06c75g.jpg" alt=""></p>
<p>这是基于业务垂直度进行的分库操作，垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库，以达到系统资源的饱和利用率。这样的分库方案结合应用的微服务治理，每个微服务系统使用独立的一个数据库。将不同模块的数据分库存储，模块间不能进行相互关联查询，如果有，要么通过数据冗余解决，要么通过应用代码进行二次加工进行解决。若不能杜绝跨库关联查询，则将小表到数据冗余到大数据量大库里去。假如，流水大表中查询需要关联获得渠道信息，渠道信息在基础管理库里面，那么，要么在查询时，代码里二次查询基础管理库中的渠道信息表，要么将渠道信息表冗余到流水大表中。</p>
<p>将每天过亿的流水数据分离出去之后，流水库中单表的数据量还是太庞大，我们将单张流水表继续分区，按照一定的业务规则，（一般是查询索引列）将单表进行分区，一个表编程N个表，当然这些变化对应用层是无法感知的。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e5r0z2zoj20fa0lgjw2.jpg" alt=""></p>
<p>分区表的设置，一般是以查询索引列进行分区，例如，对于流水表A，查询需要根据手机号和批次号进行查询，所以我们在创建分区的时候，就选择以手机号和批次号进行分区，这样设置后，查询都会走索引，每次查询Mysql都会根据查询条件计算出来，数据会落在那个分区里面，直接到对应的分区表中检索即可，避免了全表扫描。</p>
<p>对于每天流水过亿的数据，当然是要做历史表进行数据迁移的工作了。客户要求流水数据需要保存半年的时间，有的关键流水需要保存一年。删数据是不可能的了，也跑不了路，虽然当时非常有想删数据跑路的冲动。其实即使是删数据也是不太可能的了，delete的拙劣表演先淘汰了，truncate也快不了多少，我们采用了一种比较巧妙方法，具体步骤如下：</p>
<ul>
<li>创建一个原表一模一样的临时表1 <code>create table test_a_serial_1 like test_a_serial</code>;</li>
<li>将原表命名为临时表2 <code>alter table test_a_serial rename test_a_serial_{date}</code>;</li>
<li>将临时表1改为原表 <code>alter table able test_a_serial_1 rename able test_a_serial</code>; 此时，当日流水表就是一张新的空表了，继续保存当日的流水，而临时表2则保存的是昨天的数据和部分今天的数据，临时表2到名字中的date时间是通过计算获得的昨日的日期；每天会产生一张带有昨日日期的临时表2，每个表内的数据大约是有1000万。</li>
<li>将当日表中的历史数据迁移到昨日流水表中去 这样的操作都是用的定时任务进行处理，定时任务触发一般会选择凌晨12点以后，这个操作即使是几秒内完成，也有可能会有几条数据落入到当日表中去。因此我们最后还需要将当日表内的历史流水数据插入到昨日表内； <code>insert into test_a_serial_{date}(cloumn1,cloumn2….) select(cloumn1,cloumn2….) from test_a_serial where LEFT(create_time,8) &gt; CONCAT(date); commit</code>;</li>
</ul>
<p>如此，便完成了流水数据的迁移；<br>根据业务需要，有些业务数据需要保存半年，超过半年的进行删除,在进行删除的时候，就可以根据表名中的_{date}筛选出大于半年的流水直接删表；</p>
<p>半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进实时计算统计行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。</p>
<p>半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。</p>
<p>以上便是我们面对大数据量的场景下，数据库层面做的相应的优化，一张每天一亿的表，经过拆分后，每个表分区内的数据在500万左右。</p>
<h6 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h6><ul>
<li><p>水平分表</p>
<p>  针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。</p>
<p>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezurxr0cj20bk07hwhl.jpg" alt=""></p>
<p>  某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。</p>
</li>
<li><p>水平分库分表</p>
<p>  将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
</li>
<li><p>水平分库分表切分规则</p>
<ul>
<li>RANGE<ul>
<li>从0到10000一个表，10001到20000一个表；</li>
</ul>
</li>
<li>HASH取模<ul>
<li>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。</li>
</ul>
</li>
<li>地理区域<ul>
<li>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</li>
</ul>
</li>
<li>时间<ul>
<li>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="MySQL主从同步与主主同步"><a href="#MySQL主从同步与主主同步" class="headerlink" title="MySQL主从同步与主主同步"></a>MySQL主从同步与主主同步</h2><h3 id="MySQL复制"><a href="#MySQL复制" class="headerlink" title="MySQL复制"></a>MySQL复制</h3><p> MySQL内建的复制功能是构建大型，高性能应用程序的基础。将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将mysql的某一台主机的数据复制到其它主机（slave）上，并重新执行一遍来实现。</p>
<p>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循坏，这些日志可以记录发送到从服务器的更新。当一个从服务器</p>
<p>连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知的更新。</p>
<p>需注意的是：</p>
<p>在进行mysql复制时，所有对复制中的表的更新必须在主服务器上进行。否则必须要小心，以避免用户对主服器上的表进行更新与对从服务器上的表所进行更新之间的冲突。</p>
<h4 id="mysql支持哪些复制"><a href="#mysql支持哪些复制" class="headerlink" title="mysql支持哪些复制"></a>mysql支持哪些复制</h4><p> a.基于语句的复制：在主服务器上执行的sql语句，在从服务器上执行同样的语句。mysql默认采用基于语句的复制，效率边角高。一旦发现没法精确复制时，会自动选着基于行的复制。</p>
<p>b.基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。从mysql 5.0开始支持</p>
<p>c.混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确复制时，就会采用基于行的复制。</p>
<h4 id="mysql复制解决的问题"><a href="#mysql复制解决的问题" class="headerlink" title="mysql复制解决的问题"></a>mysql复制解决的问题</h4><p>a.数据分布（data distribution）</p>
<p> b.负载平衡（load balancing）</p>
<p> c.数据备份（backup），保证数据安全</p>
<p> d.高可用性与容错行（high availability and failover）</p>
<p> e.实现读写分离，缓解数据库压力</p>
<h4 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h4><p>master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，</p>
<p>   如果发生改变，则开始一个I/O Thread请求master二进制事件，同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志</p>
<p>  中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/O Thread和SQL Thread将进入睡眠状态，等待下一次被唤醒。</p>
<p>注意几点：</p>
<p> 1–master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</p>
<p> 2–slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和 master数据保持一致了。</p>
<p> 3–Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</p>
<p> 4–Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</p>
<p> 5–master和slave两节点间时间需同步</p>
<p>Mysql复制的流程图如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/907596-20170106160057409-885292032.png" alt="image"></p>
<p>如上图所示：</p>
<p> Mysql复制过程的第一部分就是master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。</p>
<p>第二部分就是slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。</p>
<p>SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。</p>
<p>此外，在master中也有一个工作线程：和其它MySQL的连接一样，slave在master中打开一个连接也会使得master开始一个线程。复制过程有一个很重要的限制——复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。</p>
<h4 id="mysql复制的模式"><a href="#mysql复制的模式" class="headerlink" title="mysql复制的模式"></a>mysql复制的模式</h4><p>  1–主从复制：主库授权从库远程连接，读取binlog日志并更新到本地数据库的过程；主库写数据后，从库会自动同步过来（从库跟着主库变）；</p>
<p> 2–主主复制：主从相互授权连接，读取对方binlog日志并更新到本地数据库的过程；只要对方数据改变，自己就跟着改变；</p>
<h4 id="mysql主从复制优点"><a href="#mysql主从复制优点" class="headerlink" title="mysql主从复制优点"></a>mysql主从复制优点</h4><p> 1–在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）</p>
<p> 2–在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）</p>
<p> 3–当主服务器出现问题时，可以切换到从服务器。（提升性能）</p>
<h4 id="mysql主从复制工作流程细节"><a href="#mysql主从复制工作流程细节" class="headerlink" title="mysql主从复制工作流程细节"></a>mysql主从复制工作流程细节</h4><p>a. MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。MySQL复制基于主服务器在二进制日志中跟踪所有对数据库的更改(更新、删除等等)。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收主服务器上已经记录到其二进制日志的保存的更新。当一个从服务器连接主服务器时，它通知主服务器定位到从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，并在本机上执行相同的更新。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。</p>
<p> b. MySQL使用3个线程来执行复制功能，其中两个线程(Sql线程和IO线程)在从服务器，另外一个线程(IO线程)在主服务器。<br>当发出START SLAVE时，从服务器创建一个I/O线程，以连接主服务器并让它发送记录在其二进制日志中的语句。主服务器创建一个线程将二进制日志中的内容发送到从服务器。该线程可以即为主服务器上SHOW PROCESSLIST的输出中的Binlog Dump线程。从服务器I/O线程读取主服务器Binlog Dump线程发送的内容并将该数据拷贝到从服务器数据目录中的本地文件中，即中继日志。第3个线程是SQL线程，由从服务器创建，用于读取中继日志并执行日志中包含的更新。在从服务器上，读取和执行更新语句被分成两个独立的任务。当从服务器启动时，其I/O线程可以很快地从主服务器索取所有二进制日志内容，即使SQL线程执行更新的远远滞后。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主从数据完成同步的过程：</p>
<p>1）在Slave 服务器上执行sartslave命令开启主从复制开关，开始进行主从复制。</p>
<p>2）此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容</p>
<p>3）Master服务器接收到来自Slave服务器的IO线程的请求后，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在Master服务器端记录的IO线程。返回的信息中除了binlog中的下一个指定更新位置。</p>
<p>4）当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（Mysql-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容</p>
<p>5）Slave服务器端的SQL线程会实时检测本地Relay Log 中IO线程新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点</p>
<h4 id="主从复制条件"><a href="#主从复制条件" class="headerlink" title="主从复制条件"></a>主从复制条件</h4><p>1）开启Binlog功能</p>
<p>2）主库要建立账号</p>
<p>3）从库要配置<code>master.info</code>（CHANGE MASTER to…相当于配置密码文件和Master的相关信息）</p>
<p>4）start slave 开启复制功能</p>
<h5 id="需要了解的"><a href="#需要了解的" class="headerlink" title="需要了解的"></a>需要了解的</h5><p>1）3个线程，主库IO，从库IO和SQL及作用</p>
<p>2）<code>master.info</code>（从库）作用</p>
<p>3）<code>relay-log</code> 作用</p>
<p>4）异步复制</p>
<p>5）binlog作用（如果需要级联需要开启Binlog）</p>
<h5 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h5><p>1）主从复制是异步的逻辑的SQL语句级的复制</p>
<p>2）复制时，主库有一个I/O线程，从库有两个线程，I/O和SQL线程</p>
<p>3）实现主从复制的必要条件是主库要开启记录binlog功能</p>
<p>4）作为复制的所有Mysql节点的server-id都不能相同</p>
<p>5）binlog文件只记录对数据库有更改的SQL语句（来自主库内容的变更），不记录任何查询（select，show）语句</p>
<h5 id="彻底解除主从复制关系"><a href="#彻底解除主从复制关系" class="headerlink" title="彻底解除主从复制关系"></a>彻底解除主从复制关系</h5><p>1)stop slave;</p>
<p>2)reset slave; 或直接删除<code>master.info</code>和<code>relay-log.info</code>这两个文件；</p>
<p>3)修改<code>my.cnf</code>删除主从相关配置参数。</p>
<p>让slave不随MySQL自动启动</p>
<p>修改<code>my.cnf</code> 在[mysqld]中增加 <code>skip-slave-start</code> 选项。</p>
<p>做了MySQL主从复制以后，使用mysqldump对数据备份时，一定要注意按照如下方式：</p>
<p><code>mysqldump --master-data --single-transaction --user=username --password=password dbname&gt; dumpfilename</code></p>
<p>这样就可以保留 file 和 position 的信息，在新搭建一个slave的时候，还原完数据库， file 和 position 的信息也随之更新，接着再start slave 就可以很迅速</p>
<p>的完成增量同步！</p>
<p>需要限定同步哪些数据库，有3个思路：</p>
<p>1）在执行grant授权的时候就限定数据库；</p>
<p>2）在主服务器上限定<code>binlog_do_db</code> = 数据库名；</p>
<p>3）主服务器上不限定数据库，在从服务器上限定<code>replicate-do-db</code> = 数据库名；</p>
<p>如果想实现 主-从（主）-从 这样的链条式结构，需要设置：</p>
<p><code>log-slave-updates</code>   只有加上它，从前一台机器上同步过来的数据才能同步到下一台机器。</p>
<p>当然，二进制日志也是必须开启的：</p>
<p><code>log-bin=/opt/mysql/binlogs/bin-log</code></p>
<p><code>log-bin-index=/opt/mysql/binlogs/bin-log.index</code></p>
<p>还可以设置一个log保存周期：</p>
<p><code>expire_logs_days=14</code></p>
<h3 id="下面记录下mysql主从／主主同步环境的实施过程"><a href="#下面记录下mysql主从／主主同步环境的实施过程" class="headerlink" title="下面记录下mysql主从／主主同步环境的实施过程"></a>下面记录下mysql主从／主主同步环境的实施过程</h3><h4 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">centos</span> 7<span class="selector-class">.4</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">master</span>：192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.103</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">slave</span>： 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.104</span></span><br></pre></td></tr></table></figure>
<p>注意下面几点：</p>
<p>1）要保证同步服务期间之间的网络联通。即能相互ping通，能使用对方授权信息连接到对方数据库（防火墙开放3306端口）。</p>
<p>2）关闭selinux。</p>
<p>3）同步前，双方数据库中需要同步的数据要保持一致。这样，同步环境实现后，再次更新的数据就会如期同步了。</p>
<h4 id="主从复制实现过程"><a href="#主从复制实现过程" class="headerlink" title="主从复制实现过程"></a>主从复制实现过程</h4><p>(1)设置master数据库的<code>my.cnf</code>文件（<code>my.cnf</code> 查找顺序 <code>/etc/my.cnf ---&gt; $basedir/my.cnf</code>,在[mysqld]配置区域添加下面内容）</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim /etc/my.cnf</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">   [mysqld] </span><br><span class="line"><span class="attribute">server-id</span>=1        #数据库唯一ID，主从的标识号绝对不能重复。</span><br><span class="line"><span class="attribute">log-bin</span>=mysql-bin    #开启bin-log，并指定文件目录和文件名前缀</span><br><span class="line"><span class="attribute">binlog-do-db</span>=liting　  #需要同步liting数据库。如果是多个同步库，就以此格式另写几行即可。如果不指明对某个具体库同步，就去掉此行，表示同步所有库（除了ignore忽略的库）。</span><br><span class="line"><span class="attribute">binlog-ignore-db</span>=mysql  #不同步mysql系统数据库。如果是多个不同步库，就以此格式另写几行；也可以在一行，中间逗号隔开。</span><br><span class="line">sync_binlog = 1      ＃确保binlog日志写入后与硬盘同步</span><br><span class="line">binlog_checksum = none  ＃跳过现有的采用checksum的事件，mysql5.6.5以后的版本中<span class="attribute">binlog_checksum</span>=crc32,而低版本都是binlog_checksum=none</span><br><span class="line">binlog_format = mixed   ＃bin-log日志文件格式，设置为MIXED可以防止主键重复。</span><br></pre></td></tr></table></figure>
<p> 温馨提示：在主服务器上最重要的二进制日志设置是<code>sync_binlog</code>，这使得mysql在每次提交事务的时候把二进制日志的内容同步到磁盘上，即使服务器崩溃也会把事件写入日志中。<br><code>sync_binlog</code>这个参数是对于MySQL系统来说是至关重要的，他不仅影响到Binlog对MySQL所带来的性能损耗，而且还影响到MySQL中数据的完整性。对于”sync_binlog”参数的各种设置的说明如下：<br><code>sync_binlog</code>=0，当事务提交之后，MySQL不做fsync之类的磁盘同步指令刷新<code>binlog_cache</code>中的信息到磁盘，而让Filesystem自行决定什么时候来做同步，或者cache满了之后才同步到磁盘。<br><code>sync_binlog</code>=n，当每进行n次事务提交之后，MySQL将进行一次fsync之类的磁盘同步指令来将<code>binlog_cache</code>中的数据强制写入磁盘。</p>
<p>在MySQL中系统默认的设置是<code>sync_binlog</code>=0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在<code>binlog_cache</code>中的所有binlog信息都会被丢失。而当设置为“1”的时候，是最安全但是性能损耗最大的设置。因为当设置为1的时候，即使系统Crash，也最多丢失<code>binlog_cache</code>中未完成的一个事务，对实际数据没有任何实质性影响。</p>
<p><strong>从以往经验和相关测试来看，对于高并发事务的系统来说，“<code>sync_binlog</code>”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</strong></p>
<p>(2)导出master数据库多余slave数据库中的数据，然后导入到slave数据库中。保证双方在同步环境实现前的数据一致。[新建环境可忽略次步骤]</p>
<p>导出数据库之前先锁定数据库<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush tables with <span class="keyword">read</span> lock;    <span class="comment">#数据库只读锁定命令，防止导出数据库的时候有数据写入。unlock tables命令解除锁定</span></span><br><span class="line">    </span><br><span class="line">导出<span class="literal">master</span>数据库中需要同步的库(<span class="literal">master</span>数据库的root用户登陆密码：<span class="number">123456</span>)</span><br><span class="line">[root@<span class="keyword">master</span> <span class="title">~]#mysqldump</span> -uroot liting -p123456 &gt;/opt/liting.sql</span><br><span class="line">[root@<span class="keyword">master</span> <span class="title">~]#rsync</span>  -e <span class="string">"ssh -p22"</span> -avpgolr /opt/liting.sql <span class="number">192.168</span>.<span class="number">0.104</span>:/opt/   ＃将导出的sql文件上传到<span class="literal">slave</span>机器上</span><br></pre></td></tr></table></figure></p>
<p>(3)在master上设置数据同步权限<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant replication slave,replication client on *.* to repl@'<span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span>' identified by <span class="string">"repl123"</span>;  #只允许<span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span>使用repl，且密码为<span class="string">"repl123"</span>连接主库做数据同步</span><br><span class="line"> Query OK, <span class="number">0</span> rows affected (<span class="number">0.02</span> sec)                                    #若要所有网段则设置repl@'%' ；部分网段：repl@'<span class="number">192.168</span><span class="number">.0</span>.%'</span><br><span class="line"> mysql&gt; flush privileges;</span><br><span class="line"> Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>温馨提示：<br>权限查看方式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show grants;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show grants <span class="keyword">for</span> repl@<span class="string">'192.168.0.104'</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>(4)查看主服务器master状态(注意File与Position项，从服务器需要这两项参数)<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| File       | Position | Binlog<span class="emphasis">_Do_</span>DB | Binlog<span class="emphasis">_Ignore_</span>DB | Executed<span class="emphasis">_Gtid_</span>Set |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| mysql-bin.000007 | 120    |  liting   |     mysql   |          |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>下面是slave数据库上的操作</p>
<p>(1)设置slave数据库的my.cnf配置文件<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@master ~]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line">.......</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="attr">server-id=2</span>   <span class="comment">#设置从服务器id，必须于主服务器不同</span></span><br><span class="line"><span class="attr">log-bin=mysql-bin</span>   <span class="comment">#启动MySQ二进制日志系统</span></span><br><span class="line"><span class="attr">replicate-do-db=liting</span>  <span class="comment">#需要同步的数据库名。如果不指明同步哪些库，就去掉这行，表示所有库的同步（除了ignore忽略的库）。</span></span><br><span class="line"><span class="attr">replicate-ignore-db=mysql</span>  <span class="comment">#不同步test数据库</span></span><br><span class="line"><span class="attr">slave-skip-errors</span> = all   <span class="comment">#跳过所有的错误，继续执行复制操作</span></span><br></pre></td></tr></table></figure></p>
<p>温馨提示：<br>当只针对某些库的某张表进行同步时，如下，只同步liting库的haha表和test库的heihei表：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicate-<span class="keyword">do</span>-<span class="keyword">db</span> = liting</span><br><span class="line">replicate-wild-<span class="keyword">do</span>-<span class="keyword">table</span> = liting.haha       <span class="comment">//当只同步几个或少数表时，可以这样设置。注意这要跟上面的库指定配合使用；</span></span><br><span class="line">replicate-<span class="keyword">do</span>-<span class="keyword">db</span> = <span class="keyword">test</span></span><br><span class="line">replicate-wild-<span class="keyword">do</span>-<span class="keyword">table</span> = <span class="keyword">test</span>.heihei      <span class="comment">//如果同步的库的表比较多时，就不能这样一一指定了，就把这个选项配置去掉，直接根据指定的库进行同步。</span></span><br></pre></td></tr></table></figure></p>
<p>(2)在slave数据库中导入从master传过来的数据。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE DATABASE liting CHARACTER SET utf8 COLLATE utf8_general_ci;   <span class="comment">#先创建一个liting空库，否则下面导入数据时会报错说此库不存在。</span></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use liting;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">source</span> /opt/liting.sql;   ＃导入master中多余的数据。</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p>
<p>(3）配置主从同步指令<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">stop</span> <span class="string">slave;</span>   <span class="string">＃执行同步前，要先关闭slave</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">change</span> <span class="string">master</span> <span class="string">to</span> <span class="string">master_host='192.168.0.103',master_user='repl',master_password='repl123',master_log_file='mysql-bin.000007',master_log_pos=120;</span></span><br><span class="line">    </span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">start</span> <span class="string">slave;</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">show</span> <span class="string">slave</span> <span class="string">status</span> <span class="string">\G;</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">        Slave_IO_State:</span> <span class="string">Waiting</span> <span class="string">for</span> <span class="string">master</span> <span class="string">to</span> <span class="string">send</span> <span class="string">event</span></span><br><span class="line"><span class="attr">         Master_Host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span></span><br><span class="line"><span class="attr">         Master_User:</span> <span class="string">repl</span></span><br><span class="line"><span class="attr">         Master_Port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">        Connect_Retry:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">       Master_Log_File:</span> <span class="string">mysql-bin.000007</span></span><br><span class="line"><span class="attr">     Read_Master_Log_Pos:</span> <span class="number">120</span></span><br><span class="line"><span class="attr">       Relay_Log_File:</span> <span class="string">mysql-relay-bin.000002</span></span><br><span class="line"><span class="attr">       Relay_Log_Pos:</span> <span class="number">279</span></span><br><span class="line"><span class="attr">   Relay_Master_Log_File:</span> <span class="string">mysql-bin.000007</span></span><br><span class="line"><span class="attr">     Slave_IO_Running:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">     Slave_SQL_Running:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">      Replicate_Do_DB:</span> <span class="string">liting</span></span><br><span class="line"><span class="attr">    Replicate_Ignore_DB:</span> <span class="string">mysql</span></span><br><span class="line">     <span class="string">.............</span></span><br><span class="line"><span class="attr">   Seconds_Behind_Master:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>如上，当IO和SQL线程的状态均为Yes，则表示主从已实现同步了！</p>
<p>下面测试下Mysql主从同步的效果<br>在master主数据库上写入新数据<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use liting;    </span><br><span class="line">mysql&gt;<span class="keyword">create</span> table <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> haha (id int(<span class="number">10</span>) <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT,name varchar(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> huanqiu.haha <span class="keyword">values</span>(<span class="number">100</span>,<span class="string">"anhui"</span>);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>然后在slave数据库上查看，发现master上新写入的数据已经同步过来了<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from liting.haha;</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">| id   | name    |</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">| 100 | anhui   |</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>至此，主从同步环境已经实现！</p>
<p>注意：<br>Mysql主从环境部署一段时间后，发现主从不同步时，如何进行数据同步至一致？<br>有以下两种做法：<br>1）参考：<a href="http://www.cnblogs.com/kevingrace/p/6261111.html" target="_blank" rel="noopener">mysql主从同步(2)-问题梳理</a> 中的第（4）步的第二种方法<br>2）参考：<a href="http://www.cnblogs.com/kevingrace/p/6261091.html" target="_blank" rel="noopener">mysql主从同步(3)-percona-toolkit工具</a>（数据一致性监测、延迟监控）使用梳理</p>
<h3 id="主主复制实现过程"><a href="#主主复制实现过程" class="headerlink" title="主主复制实现过程"></a>主主复制实现过程</h3><p>根据上面的主从环境部署，master和slave已经实现同步，即在master上写入新数据，自动同步到slave。而从库只能读不能写，一旦从库有写入数据，就会造成主从数据不一致！<br>下面就说下Mysql主主复制环境，在slave上更新数据时，master也能自动同步过来。</p>
<p>温馨提示：</p>
<p>在做主主同步前，提醒下需要特别注意的一个问题：</p>
<p>主主复制和主从复制有一些区别，因为多主中都可以对服务器有写权限，所以设计到自增长重复问题，例如：</p>
<p>出现的问题（多主自增长ID重复）</p>
<p>1）首先在A和B两个库上创建test表结构;</p>
<p>2）停掉A，在B上对数据表test(存在自增长属性的ID字段)执行插入操作，返回插入ID为1;</p>
<p>3）然后停掉B，在A上对数据表test(存在自增长属性的ID字段)执行插入操作，返回的插入ID也是1;</p>
<p>4）然后 同时启动A,B，就会出现主键ID重复</p>
<p>解决方法：</p>
<p>只要保证两台服务器上的数据库里插入的自增长数据不同就可以了<br>如：A插入奇数ID，B插入偶数ID，当然如果服务器多的话，还可以自定义算法，只要不同就可以了<br>在下面例子中，在两台主主服务器上加入参数，以实现奇偶插入！<br>记住:在做主主同步时需要设置自增长的两个相关配置，如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_increment_offset     表示自增长字段从那个数开始，取值范围是<span class="number">1</span> .. <span class="number">65535</span>。这个就是序号。如果有n台mysql机器，则从第一台开始分为设<span class="number">1</span>，<span class="number">2.</span>..n</span><br><span class="line">auto_increment_increment    表示自增长字段每次递增的量，其默认值是<span class="number">1</span>，取值范围是<span class="number">1</span> .. <span class="number">65535</span>。如果有n台mysql机器，这个值就设置为n。</span><br></pre></td></tr></table></figure></p>
<p>在主主同步配置时，需要将两台服务器的：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_increment_increment     增长量都配置为<span class="number">2</span></span><br><span class="line">auto_increment_offset        分别配置为<span class="number">1</span>和<span class="number">2</span>。这是序号，第一台从<span class="number">1</span>开始，第二台就是<span class="number">2</span>，以此类推.....</span><br></pre></td></tr></table></figure></p>
<p>这样才可以避免两台服务器同时做更新时自增长字段的值之间发生冲突。（针对的是有自增长属性的字段）</p>
<h4 id="主主同步实现操作过程"><a href="#主主同步实现操作过程" class="headerlink" title="主主同步实现操作过程"></a>主主同步实现操作过程</h4><p>1）在master上的my.cnf配置：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">1</span>        </span><br><span class="line"><span class="attr">log-bin</span> = mysql-bin  </span><br><span class="line"><span class="attr">binlog-ignore-db</span> = mysql,information_schema</span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">binlog_checksum</span> = none</span><br><span class="line"><span class="attr">binlog_format</span> = mixed</span><br><span class="line"><span class="attr">auto-increment-increment</span> = <span class="number">2</span>    </span><br><span class="line"><span class="attr">auto-increment-offset</span> = <span class="number">1</span>   </span><br><span class="line"><span class="attr">slave-skip-errors</span> = all     </span><br><span class="line">[root@master ~]<span class="comment"># /etc/init.d/mysql restart</span></span><br><span class="line">Shutting down MySQL. SUCCESS!</span><br><span class="line">Starting MySQL.. SUCCESS!</span><br></pre></td></tr></table></figure></p>
<p>数据同步授权（iptables防火墙开启3306端口，要确保对方机器能使用下面权限连接到本机mysql）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mysql</span>&gt; <span class="selector-tag">grant</span> <span class="selector-tag">replication</span> <span class="selector-tag">slave</span>,<span class="selector-tag">replication</span> <span class="selector-tag">client</span> <span class="selector-tag">on</span> *.* <span class="selector-tag">to</span> <span class="selector-tag">repl</span>@'<span class="keyword">192</span>.<span class="keyword">168</span>.<span class="keyword">0</span>.<span class="keyword">104</span>' identified by <span class="string">"repl123"</span>;</span><br><span class="line"><span class="selector-tag">mysql</span>&gt; <span class="selector-tag">flush</span> <span class="selector-tag">privileges</span>;</span><br></pre></td></tr></table></figure></p>
<p>最好将库锁住，仅仅允许读，以保证数据一致性；待主主同步环境部署后再解锁；锁住后，就不能往表里写数据，但是重启mysql服务后就会自动解锁！<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;    //注意该参数设置后，如果自己同步对方数据，同步前一定要记得先解锁！</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="code"> </span></span><br><span class="line">mysql&gt; show master status;</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| File       | Position | Binlog<span class="emphasis">_Do_</span>DB | Binlog<span class="emphasis">_Ignore_</span>DB | Executed<span class="emphasis">_Gtid_</span>Set |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| mysql-bin.000001 |   158 |        |         |          |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>2）slave数据库上<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@slave ~]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">2</span>       </span><br><span class="line"><span class="attr">log-bin</span> = mysql-bin  </span><br><span class="line"><span class="attr">binlog-ignore-db</span> = mysql,information_schema</span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">binlog_checksum</span> = none</span><br><span class="line"><span class="attr">binlog_format</span> = mixed</span><br><span class="line"><span class="attr">auto-increment-increment</span> = <span class="number">2</span>    </span><br><span class="line"><span class="attr">auto-increment-offset</span> = <span class="number">2</span>   </span><br><span class="line"><span class="attr">slave-skip-errors</span> = all</span><br><span class="line"> </span><br><span class="line">[root@slave ~]<span class="comment"># /etc/init.d/mysql restart</span></span><br><span class="line">Shutting down MySQL. SUCCESS!</span><br><span class="line">Starting MySQL.. SUCCESS!</span><br></pre></td></tr></table></figure></p>
<p>数据同步授权（iptables防火墙开启3306端口，要确保对方机器能使用下面权限连接到本机mysql）<br>同理，slave也要授权给master机器远程同步数据的权限<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant replication slave ,replication client on <span class="strong">*.*</span> to repl@<span class="emphasis">'192.168.0.103'</span> identified by "repl123";  </span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"><span class="code"> </span></span><br><span class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| File       | Position | Binlog<span class="emphasis">_Do_</span>DB | Binlog<span class="emphasis">_Ignore_</span>DB | Executed<span class="emphasis">_Gtid_</span>Set |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| mysql-bin.000001 |   256 |       |          |          |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>3）执行主张同步操作</p>
<p>先在slave数据库上做同步master的设置。（确保slave上要同步的数据，提前在master上存在。最好双方数据保持一致）<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">unlock</span> <span class="string">tables;</span>     <span class="string">//先解锁，将对方数据同步到自己的数据库中</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">slave</span> <span class="string">stop；</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">change</span> <span class="string">master</span> <span class="string">to</span> <span class="string">master_host='192.168.0.103',master_user='repl',master_password='repl123',master_log_file='master-bin.000001',master_log_pos=158;</span></span><br><span class="line"> </span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">start</span> <span class="string">slave;</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">show</span> <span class="string">slave</span> <span class="string">status</span> <span class="string">\G;</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">             Slave_IO_State:</span> <span class="string">Waiting</span> <span class="string">for</span> <span class="string">master</span> <span class="string">to</span> <span class="string">send</span> <span class="string">event</span></span><br><span class="line"><span class="attr">              Master_Host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span></span><br><span class="line"><span class="attr">              Master_User:</span> <span class="string">repl</span></span><br><span class="line"><span class="attr">              Master_Port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">             Connect_Retry:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">            Master_Log_File:</span> <span class="string">mysql-bin.000001</span></span><br><span class="line"><span class="attr">          Read_Master_Log_Pos:</span> <span class="number">158</span></span><br><span class="line"><span class="attr">           nelay_Log_File:</span> <span class="string">mysql-relay-bin.000003</span></span><br><span class="line"><span class="attr">             Relay_Log_Pos:</span> <span class="number">750</span></span><br><span class="line"><span class="attr">        Relay_Master_Log_File:</span> <span class="string">mysql-bin.000001</span></span><br><span class="line"><span class="attr">            Slave_IO_Running:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">            Slave_SQL_Running:</span> <span class="literal">Yes</span></span><br><span class="line">            <span class="string">..................</span></span><br></pre></td></tr></table></figure></p>
<p>这样就实现了slave－&gt;master的同步环境。</p>
<p>再在master数据库上做同步slave的设置。（确保slave上要同步的数据，提前在master上存在。最好双方数据保持一致）<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; unlock tables;</span><br><span class="line">mysql&gt; slave stop；</span><br><span class="line">mysql&gt; change master <span class="keyword">to</span> <span class="attribute">master_host</span>=<span class="string">'192.168.0.104'</span>,master_user='repl',master_password='repl123',master_log_file='master-bin.000001',master_log_pos=256;</span><br><span class="line"> </span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">mysql&gt; show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Slave_IO_State: Waiting <span class="keyword">for</span> master <span class="keyword">to</span> send event</span><br><span class="line">             Master_Host: 192.168.0.103</span><br><span class="line">             Master_User: repl</span><br><span class="line">             Master_Port: 3306</span><br><span class="line">            Connect_Retry: 60</span><br><span class="line">           Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 256</span><br><span class="line">           Relay_Log_File: mysql-relay-bin.000003</span><br><span class="line">           Relay_Log_Pos: 750</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">            Slave_IO_Running: <span class="literal">Yes</span></span><br><span class="line">            Slave_SQL_Running: <span class="literal">Yes</span></span><br><span class="line">            <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure></p>
<p>这样就实现了master－&gt;slave的同步环境。至此，主主双向同步环境已经实现！</p>
<h4 id="最后测试下Mysql主主同步的效果"><a href="#最后测试下Mysql主主同步的效果" class="headerlink" title="最后测试下Mysql主主同步的效果"></a>最后测试下Mysql主主同步的效果</h4><p>在master上写入新数据<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from liting.haha;</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">| id   | name    |</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">| 100 | anhui   |</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br><span class="line"><span class="code"> </span></span><br><span class="line">mysql&gt; insert into huanqiu.haha values(10,"beijing");</span><br></pre></td></tr></table></figure></p>
<p>在slave数据库中查看，发现master新写入的数据已经同步过来了<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from liting.haha;</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">| id  | name    |</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">|  10| beijing  |</span><br><span class="line">| 100 | anhui   |</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>在slave上删除数据<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">delete</span> <span class="keyword">from</span> liting.haha <span class="keyword">where</span> id=<span class="number">100</span>;</span><br></pre></td></tr></table></figure></p>
<p>在master数据库中查看<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from liting.haha;</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">| id  | name    |</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">|  10 | beijing  |</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>以上，主主同步实现</p>
<h3 id="binlog，redo-log，undo-log区别"><a href="#binlog，redo-log，undo-log区别" class="headerlink" title="binlog，redo log，undo log区别"></a>binlog，redo log，undo log区别</h3><ol>
<li><p>binlog是MySQL Server层记录的日志， redo log是InnoDB存储引擎层的日志。 两者都是记录了某些操作的日志(不是所有)自然有些重复（但两者记录的格式不同）。</p>
</li>
<li><p>选择binlog日志作为replication我想主要原因是MySQL的特点就是支持多存储引擎，为了兼容绝大部分引擎来支持复制这个特性，那么自然要采用MySQL Server自己记录的日志而不是仅仅针对InnoDB的redo log，因为如果采用了InnoDB redo log复制，那么其他引擎也想复制，此时改怎么办呢？对吧</p>
</li>
</ol>
<p>binlog属于逻辑日志，是逻辑操作。innodb redo属于物理日志，是物理变更。<br>逻辑日志有个缺点是难以并行，而物理日志可以比较好的并行操作，所以redo复制还是有优势的，也许5.7能搞出来。</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>binlog日志用于记录所有更新且提交了数据或者已经潜在更新提交了数据（例如，没有匹配任何行的一个DELETE）的所有语句。语句以“事件”的形式保存，它描述数据更改。</p>
<p>binlog作用</p>
<p>1.恢复使能够最大可能地更新数据库，因为二进制日志包含备份后进行的所有更新。<br>2.在主复制服务器上记录所有将发送给从服务器的语句。 </p>
<p>binlog 主要参数</p>
<p><code>log_bin</code><br>设置此参数表示启用binlog功能，并指定路径名称</p>
<p><code>innodb_flush_log_at_trx_commit = N</code>：</p>
<p>N=0  – 每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；</p>
<p>N=1  – 每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；</p>
<p>N=2  – 每事务提交的时候，把事务日志数据从缓存区写到日志文件中；每隔一秒，刷新一次日志文件，但不一定刷新到磁盘上，而是取决于操作系统的调度；</p>
<p><code>sync_binlog =  N</code>：</p>
<p>N&gt;0  — 每向二进制日志文件写入N条SQL或N个事务后，则把二进制日志文件的数据刷新到磁盘上；</p>
<p>N=0  — 不主动刷新二进制日志文件的数据到磁盘上，而是由操作系统决定；</p>
<p>推荐配置组合：</p>
<p>N=1,1  — 适合数据安全性要求非常高，而且磁盘IO写能力足够支持业务，比如充值消费系统；</p>
<p>N=1,0  — 适合数据安全性要求高，磁盘IO写能力支持业务不富余，允许备库落后或无复制；</p>
<p>N=2,0或2,<code>m(0&lt;m&lt;100)</code> — 适合数据安全性有要求，允许丢失一点事务日志，复制架构的延迟也能接受；</p>
<p>N=0,0  — 磁盘IO写能力有限，无复制或允许复制延迟稍微长点能接受，例如：日志性登记业务；</p>
<h4 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h4><p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用UndoLog来实现多版本并发控制(简称：MVCC)。</p>
<h5 id="事务的原子性-Atomicity"><a href="#事务的原子性-Atomicity" class="headerlink" title="事务的原子性(Atomicity)"></a>事务的原子性(Atomicity)</h5><pre><code>- 事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。
</code></pre><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLo）。<br>然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用UndoLog中的备份将数据恢复到事务开始之前的状态。<br>除了可以保证事务的原子性，Undo Log也可以用来辅助完成事务的持久化。</p>
<h5 id="事务的持久性-Durability"><a href="#事务的持久性-Durability" class="headerlink" title="事务的持久性(Durability)"></a>事务的持久性(Durability)</h5><p>事务一旦完成，该事务对数据库所做的所有修改都会持久的保存到数据库中。为了保证持久性，数据库系统会将修改后的数据完全的记录到持久的存储上。</p>
<h5 id="用Undo-Log"><a href="#用Undo-Log" class="headerlink" title="用Undo Log"></a>用Undo Log</h5><p>实现原子性和持久化的事务的简化过程</p>
<p>假设有A、B两个数据，值分别为1,2。<br>A.事务开始.</p>
<p>B.记录A=1到undolog.</p>
<p>C.修改A=3.</p>
<p>D.记录B=2到undolog.</p>
<p>E.修改B=4.</p>
<p>F.将undolog写到磁盘。</p>
<p>G.将数据写到磁盘。</p>
<p>H.事务提交</p>
<p>这里有一个隐含的前提条件：‘数据都是先读到内存中，然后修改内存中的数据，最后将数据写回磁盘’。</p>
<p>之所以能同时保证原子性和持久化，是因为以下特点：</p>
<p>A.更新数据前记录Undo log。</p>
<p>B.为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。</p>
<p>C.Undo log<br>必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的，可以用来回滚事务。</p>
<p>D.如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p>
<p>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即</p>
<h4 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h4><p>记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，<br>但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。</p>
<p>-Undo+Redo<br>事务的简化过程</p>
<p>假设有A、B两个数据，值分别为1,2.</p>
<p>A.事务开始.</p>
<p>B.记录A=1到undolog.</p>
<p>C.修改A=3.</p>
<p>D.记录A=3到redolog.</p>
<p>E.记录B=2到undolog.</p>
<p>F.修改B=4.</p>
<p>G.记录B=4到redolog.</p>
<p>H.将redolog写入磁盘。</p>
<p>I.事务提交</p>
<p>-Undo+Redo<br>事务的特点</p>
<p>A.为了保证持久性，必须在事务提交前将<br>RedoLog持久化。</p>
<p>B.数据不需要在事务提交前写入磁盘，而是缓存在内存中。</p>
<p>C.RedoLog保证事务的持久性。</p>
<p>D.UndoLog保证事务的原子性。</p>
<p>E.有一个隐含的特点，数据必须要晚于redolog写入持久存</p>
<h2 id="mysql有哪些索引类型？有哪些存储引擎？有什么区别"><a href="#mysql有哪些索引类型？有哪些存储引擎？有什么区别" class="headerlink" title="mysql有哪些索引类型？有哪些存储引擎？有什么区别"></a>mysql有哪些索引类型？有哪些存储引擎？有什么区别</h2><ul>
<li>索引类型<ul>
<li>FULLTEXT：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%”这类针对文本的模糊查询效率较低的问题。</li>
<li>HASH：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</li>
<li>BTREE：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</li>
<li>RTREE：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。</li>
</ul>
</li>
<li>索引种类：<ul>
<li>普通索引：仅加速查询。</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>
<li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索</li>
</ul>
</li>
<li>存储引擎<ul>
<li>InnoDB<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1343758042_8526.png" alt="image"><ul>
<li>InnoDB 也采用 B+Tree这种数据结构来实现 B-Tree索引。而很大的区别在于，InnoDB 存储引擎采用“聚集索引”的数据存储方式实现B-Tree索引，所谓“聚集”，就是指数据行和相邻的键值紧凑地存储在一起，注意 InnoDB 只能聚集一个叶子页（16K）的记录（即聚集索引满足一定的范围的记录），因此包含相邻键值的记录可能会相距甚远。</li>
<li>当InnoDB做全表扫描时并不高效，因为 InnoDB 实际上并没有顺序读取,在大多情况下是在随机读取。做全表扫描时,InnoDB 会按主键顺序扫描页面和行。这应用于所有的InnoDB 表，包括碎片化的表。如果主键页表没有碎片（存储主键和行的页表),全表扫描是相当快，因为读取顺序接近物理存储顺序。但是当主键页有碎片时，该扫描就会变得十分缓慢</li>
<li>遵循ACID原则(atomicity原子性，consistency一致性，isolation隔离性，durability持久性)，具有事务特性的能力：commit，rollback，crash-recovery。<ul>
<li>仅InnoDB和NDB(Network DB clustered database engine)支持事务和MVCC</li>
</ul>
</li>
<li>行级锁和Oracle风格的读一致性，提高多用户下的并发度和性能，提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”。<ul>
<li>只有通过索引条件检索数据，InnoDB才使用行级锁，否则仍然使用表锁</li>
<li>读一致性：query时使用snapshot快照，允许其他事务进行修改，之后再根据undo log调整数据</li>
<li>默认的隔离级别是可重复读，即同一个事务中多次读取，数据相同</li>
</ul>
</li>
<li>使用主键优化查询，主键索引是聚集索引(Clustered index，仅InnoDB支持)，使查询主键时的I/O最小化<ul>
<li>聚集索引是指整个表是按照这个索引来组织的，物理存储顺序与索引顺序相同，所以聚集索引字段的修改需要很大开销</li>
<li>InnoDB聚集索引的实现方式，同时也体现了一张 innoDB表的结构，可以看到，InnoDB 中，主键索引和数据是一体的，没有分开。</li>
</ul>
</li>
<li>支持外码约束</li>
<li>崩溃后能很好地恢复<ul>
<li>未完成的事务将根据redo log的数据重做</li>
<li>已提交但未写入的修改，将从doublewrite buffer重做</li>
<li>系统闲时会purge buffer</li>
</ul>
</li>
<li>维护一个内存中的buffer pool缓冲池，数据被访问时，表和索引数据会被缓存</li>
<li>对增删改的change buffering策略，如果被修改数据的页不在缓冲池中，则这个修改可以存在change buffer中，等相应页被放进缓冲池(发生对该页的访问)时，再写入修改，称为merge</li>
<li>adaptive hash index，经常被访问的页会自动在内存建立一个哈希索引，适于=和IN的查询。buffer pool中会预留这种索引需要的内存空间。建立在已有的B树索引基础上，哈希索引可以是部分的，B树索引不需要全部缓存在缓冲池中</li>
<li>使用checksum校验和机制检测内存或硬盘的损坏</li>
<li>InnoDB是为处理巨大数据量的最大性能设计</li>
<li>可以在一个查询中join混用InnoDB引擎的表和其他引擎的表</li>
</ul>
</li>
<li>MyISAM<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1343757655_1008.png" alt="image"><ul>
<li>适用场景：read-only or read-mostly workloads in Web and data warehousing configurations(查询效率很高，适合大量读操作的场景)</li>
<li>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。MyISAM索引文件【.MYI (MYIndex)】和数据文件【.MYD (MYData)】是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些地址来读取页，进而读取被索引的行</li>
<li>MyISAM 默认会把索引读入内存，直接在内存中操作</li>
<li>Innodb强调多功能性，支持的拓展功能比较多，myisam主要侧重于性能</li>
<li>将创建3个文件，一个.frm文件，一个.MYD(MYData)文件存数据，一个.MYI(MYIndex)文件存索引</li>
<li>数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>所有数据值都按小字节(low byte first)存储，因此独立于操作系统(可移植性)。但没有明显降低速度，只是需要多处理一下对齐问题，况且获取列值所花的时间不是最主要的</li>
<li>所有数字键都按大字节(high byte first)存储，利于压缩</li>
<li>BLOB和TEXT列可以创建索引</li>
<li>每一个character列可以使用不同的字符编码</li>
<li>会保存表的具体行数</li>
<li>使用B树索引，string索引会被压缩，当string是索引第一项时还会压缩前缀</li>
<li>支持真正的变长字段varchar</li>
<li>支持并发的insert</li>
</ul>
</li>
<li>区别<ul>
<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>
</ul>
</li>
<li>如何选择<ul>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ul>
</li>
<li>ARCHIVE<ul>
<li>适用场景：作为仓库，存储大量的独立的作为历史记录的数据(插入速度快但查询支持较差）</li>
<li>不支持索引</li>
<li>没有存储大小限制(InnoDB是64TB)</li>
<li>能很好地压缩数据</li>
<li>使用行级锁</li>
<li>支持INSERT, REPLACE, SELECT, 不支持 DELETE, UPDATE</li>
<li>使用zlib 无损数据压缩。数据insert后即被压缩，放在一个压缩缓冲区中，select操作会导致清空缓冲区，此时数据被真正存储。支持批处理insert。</li>
<li>行会根据需要解压，不设缓冲。select会导致全表扫描。select是读一致性的。大量查询during insertion会影响压缩。使用REPAIR TABLE或OPTIMIZE TABLE能获取更好的压缩。</li>
</ul>
</li>
<li>BLACKHOLE<ul>
<li>适用场景:转发器（会保存SQL语句的日志，并且复制给slave servers）</li>
<li>过滤器（设置使用黑洞引擎的“dummy” slave进程，依据一定规则将master的日志进行过滤并在BLACKHOLE表写一个新的日志，再复制给slaves，这样只会导致很少的开销）</li>
<li>像黑洞一样接受数据但不存储</li>
<li>创建table A会生成一个A.frm表文件，没有其他文件</li>
<li>支持所有索引</li>
<li>会保存SQL语句的日志，并且复制给slave servers，适合做转发器或过滤器</li>
<li>会导致错误，因为不论log文件是row-based还是statement-based，blackhole表不会存储自增列的数据，所以在slaves上insert时会出现重复的主码错误</li>
<li>使用row-based replication时，如果slaves的表的字段比master少，那么过滤机制其实是在slaves上。如果缺失字段是私密的，不能给slaves获取的；或是有很多slaves，需要在发送数据前就把数据过滤掉以减少网络负载，就不适合这种方式。BLACKHOLE表就能实现在master上进行过滤。</li>
</ul>
</li>
<li>MRG_MYISAM<ul>
<li>适用场景：Good for VLDB environments such as data warehousing</li>
<li>要求多个Mylsam表要有相同的列信息(包括顺序)和索引信息(包括索引的order)</li>
<li>这些信息不同不会影响表合并<ul>
<li>列名和索引名</li>
<li>所有的备注comment</li>
<li>表的选项，例如 <code>AVG_ROW_LENGTH</code>, <code>MAX_ROWS</code>, or <code>PACK_KEYS</code></li>
</ul>
</li>
<li>创建merge表时会创建2个文件，一个是存数据的.frm文件，一个是.mrg文件(存储哪些表应当merge起来使用)</li>
<li>merge表中的表可以存于不同的数据库中</li>
<li>支持merge表的增删改查，前提是必须拥有处理其中所有表的权限</li>
<li>drop table只是删除了merge表，实际存储数据的表不会被删除</li>
<li>建表需要指定UNION=(list-of-tables)表明使用哪些表，以及INSERT_METHOD=LAST/FIRST表明在哪一个表中插入数据，否则无法执行insert操作</li>
<li>merge表没有主键，因为不能强制实行唯一索引</li>
</ul>
</li>
<li>FEDERATED<ul>
<li>适用场景：Very good for distributed or data mart environments</li>
<li>数据不存储在本地，而是在远程数据库，本地访问时会pull远程数据库的数据</li>
<li>远程数据库的表可以是任何存储引擎的表</li>
<li>本地表和远程表应有相同的定义</li>
<li>本地用.frm文件存储表定义，并且包含一个指向远程数据库的连接字符串</li>
<li>本地执行操作时，会发送给远程去执行，使用MySQL client API</li>
<li>远程表可以是一个FEDERATED表，但注意不要造成一个循环</li>
<li>FEDERATED表不支持一般意义上的索引，要远程表上有索引才有效</li>
<li>如果一个查询语句不能使用远程表的索引，会导致全表扫描，本地数据库会获取全表数据（存在本地内存中，如果数据量过大会引起交换和挂起），再在本地进行过滤</li>
<li>不支持alter table或drop table，执行drop table只会删除本地FEDERATED表</li>
<li>不支持分区</li>
<li>如果远程表改变，本地表无法获知</li>
</ul>
</li>
<li>PERFORMANCE_SCHEMA<ul>
<li>关注收集mysql server运行中的性能数据，会监视server的所有events</li>
<li>performance_schema数据库名及其表名都是小写的，查询时要用小写</li>
<li>很多表都是只读的，对数据库所有表的GRANT ALL授权是不允许的</li>
<li>数据库中表的更改不会写在日志中</li>
<li>是完全in-memory的，不占用磁盘空间，mysql服务启动时表会被重新填充，关闭服务时便丢弃</li>
<li>数据收集的实现是在源码中添加”监控点”(instrumentation)，没有用额外的线程(不像”复制”或”事件调度”)</li>
<li>用户不能创建存储该类型的表</li>
</ul>
</li>
<li>MEMORY<ul>
<li>适用场景：存储临时、不重要的数据，例如作为缓存，适合大量读的情形 (limited updates)</li>
<li>不支持变长的数据类型variable-length data types (including BLOB and TEXT)</li>
<li>不支持外码约束</li>
<li>不支持压缩</li>
<li>不支持MVCC</li>
<li>支持哈希索引和B树索引，不支持全文索引和T树索引</li>
<li>mysql服务关闭或重启，数据会消失(表还在)</li>
<li>数据量不能超过内存大小</li>
<li>性能限制<ul>
<li>单线程执行</li>
<li>表更新用表级锁(高并发读写情形下，表级锁严重降低性能，还不如InnoDB快)</li>
</ul>
</li>
<li>内置的临时表(也在内存中)太大时会自动转成磁盘存储，但用户自创的内存表永远不会转化</li>
<li>可以从persistent data source装载数据到内存表</li>
<li>被删除的row会放进一个链表(不会回收内存)，等插入新数据时拿出来复用，只有整个表被删除后才会回收内存。采用定长的行存储，即使是varchar也是定长存储的。</li>
<li>默认使用哈希索引，并且允许非唯一的哈希索引(但如果字段含大量重复值，性能会很低，这种情况最好用B树索引)，被索引字段可以有NULL。</li>
</ul>
</li>
<li>CSV<ul>
<li>创建一个csv表，除了.frm文件外，还创建一个.csv文件用于存储数据，还有一个.csm文件存储表状态、行数等信息，称为metafile</li>
<li>所有字段都必须NOT NULL</li>
<li>不支持索引、分区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对索引的理解，组合索引，索引的最佳实践"><a href="#对索引的理解，组合索引，索引的最佳实践" class="headerlink" title="对索引的理解，组合索引，索引的最佳实践"></a>对索引的理解，组合索引，索引的最佳实践</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li>B-Tree 索引：MySQL 中最主要的索引；</li>
<li>RTREE 索引：仅仅是 MyISAM，GIS；</li>
<li>哈希索引：MyISAM，5.6 开始的 Innodb。</li>
</ul>
<h3 id="BTREE-索引能做什么？"><a href="#BTREE-索引能做什么？" class="headerlink" title="BTREE 索引能做什么？"></a>BTREE 索引能做什么？</h3><ul>
<li>直接查看 KEY=5 的所有列；</li>
<li>找到 KEY &gt; 5 的列，范围查找；</li>
<li>查找 5&lt;KEY&lt;10 之间的所有列，封闭范围查找；</li>
<li>不能找到 KEY 的最后一个数字是 0 的列（这个不是范围查找）。</li>
</ul>
<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><ul>
<li>字符串索引实际上也没什么不同，按照字典顺序排列，例如 ”AAAA” &lt; “AAAB”;</li>
<li>like 前缀是一个特殊排序，例如 LIKE “ABC%” 意味着 “ABC[LOWEST]”&lt;KEY&lt;“ABC[HIGHEST]”，但是 LIKE “%ABC” 不走索引。</li>
</ul>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><ul>
<li>按照定义的顺序从左往右进行比较，例如在 KEY(col1,col2,col3) 中，(1,2,3) &lt; (1,3,1)；</li>
<li>多列索引仍然是一个 BTREE 索引，但不是每列都是一个单独的 BTREE。</li>
</ul>
<h3 id="MySQL-怎么使用索引"><a href="#MySQL-怎么使用索引" class="headerlink" title="MySQL 怎么使用索引"></a>MySQL 怎么使用索引</h3><h4 id="在数据查询中使用索引"><a href="#在数据查询中使用索引" class="headerlink" title="在数据查询中使用索引"></a>在数据查询中使用索引</h4><p>用了索引 LAST_NAME<br><code>SELECT * FROM EMPLOYEES WHERE LAST_NAME=“Smith”;</code></p>
<p>用了索引 (DEPT,LAST_NAME)</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * <span class="keyword">FROM</span> EMPLOYEES WHERE</span><br><span class="line"> <span class="attribute">LAST_NAME</span>=“Smith” <span class="keyword">AND</span></span><br><span class="line"> <span class="attribute">DEPT</span>=“Accounting”</span><br></pre></td></tr></table></figure>
<p>这里虽然索引字段顺序和查询的顺序颠倒，依然会走索引，不是因为最左匹配不走索引。</p>
<p>多列索引会变的困难，对于索引 (A,B,C)：</p>
<ul>
<li>下面的条件会走索引:<ul>
<li>A&gt;5</li>
<li>A=5 AND B&gt;6</li>
<li>A=5 AND B=6 AND C=7</li>
<li>A=5 AND B IN (2,3) AND C&gt;5</li>
<li>下面的条件不走索引，因为不符合最左匹配，缺少第一列</li>
<li>B &gt; 5</li>
<li>B = 6 AND C = 7</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 MySQL5.7 中使用 explain 执行了一下，发现还是会走索引的，估计 MySQL 底层做了什么优化？</p>
</blockquote>
<ul>
<li>下面条件会走部分索引<ul>
<li>A&gt;5 AND B=2</li>
<li>A=5 AND B&gt;6 AND C=2</li>
</ul>
</li>
</ul>
<p>SQL 优化的第一原则：</p>
<p>MySQL 在多列索引中，一遇到 （&lt;,&gt;,between）就会停止使用 key，然而能继续使用 key 直到 in 范围的右边。</p>
<h4 id="在排序中使用索引"><a href="#在排序中使用索引" class="headerlink" title="在排序中使用索引"></a>在排序中使用索引</h4><p>排序</p>
<p><code>SELECT * FROM PLAYERS ORDER BY SCORE DESC LIMIT 10</code></p>
<ul>
<li>该 SQL 会使用建立在 SCORE 列上的 索引；</li>
<li>如果排序的时候没有使用索引，将会导致非常耗时的文件排序；</li>
<li>在排序中经常会考虑组合索引， 例如下面的 SQL 可以考虑(COUNTRY,SCORE) 索引：</li>
</ul>
<p><code>SELECT * FROM PLAYERS WHERE COUNTRY=“US” ORDER BY   SCORE DESC LIMIT 10</code><br>使用多列索引进行高效的排序，在排序中使用索引有很多的限制，对于 KEY(A，B）:</p>
<ul>
<li>下面排序会使用索引：<ul>
<li>ORDER BY A：主列索引；</li>
<li>A=5 ORDER BY B：通过第一列过滤数据，第二列进行排序；</li>
<li>ORDER BY A DESC, B DESC：用相同的排序进行排序；</li>
<li>A&gt;5 ORDER BY A：主列上进行查询和排序</li>
</ul>
</li>
<li>下面的语句不会使用索引：<ul>
<li>ORDER BY B ：非主列索引排序；</li>
<li>A&gt;5 ORDER BY B：第一列上使用范围，第二列进行排序；</li>
<li>A IN(1,2) ORDER BY B：第一列上用 IN；</li>
<li>ORDER BY A ASC, B DESC：两列的排列顺序不同。</li>
</ul>
</li>
</ul>
<p>使用索引进行排序的规则</p>
<ul>
<li>两列的排列顺序不能不一致；</li>
<li>非排序的列中索引部分只能用 =，in 也不能用。</li>
</ul>
<h4 id="表中存在多个索引"><a href="#表中存在多个索引" class="headerlink" title="表中存在多个索引"></a>表中存在多个索引</h4><ul>
<li>MySQL 中可以存在多个索引：会有索引合并；</li>
<li>SELECT * FROM TBL WHERE A=5 AND B=6：该语句能分别使用在 A 和 B 上的索引，但是在 （A,B) 上建立索引是更好的；</li>
<li>SELECT * FROM TBL WHERE A=5 OR B=6：该语句使用两个独立的索引，但不会使用在（A,B) 上建立的索引</li>
</ul>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>可以在索引最左边一列上建立前缀索引：</p>
<ul>
<li>ALTER TABLE TITLE ADD KEY(TITLE(20));</li>
<li>需要在 BLOB/TEXT 上建立索引；</li>
<li>能显著的提升效率；</li>
<li>不能被用作覆盖索引；</li>
<li>选择合适的前缀长度是一个问题。</li>
</ul>
<h2 id="Explain命令详解"><a href="#Explain命令详解" class="headerlink" title="Explain命令详解"></a>Explain命令详解</h2><p><strong> EXPLAIN 输出格式</strong></p>
<p>EXPLAIN 命令的输出内容大致如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>各列的含义如下:</p>
<ul>
<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<p>接下来我们来重点看一下比较重要的几个字段.</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type 表示了查询的类型, 它的常用取值有:</p>
<ul>
<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>
<li>PRIMARY, 表示此查询是最外层的查询</li>
<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>
<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li>
<li>UNION RESULT, UNION 的结果</li>
<li>SUBQUERY, 子查询中的第一个 SELECT</li>
<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>
</ul>
<p>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型, 例如:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; (SELECT * FROM user_info WHERE id IN (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">| <span class="type">id</span> | <span class="type">select_type</span>  | <span class="type">table</span>      | <span class="type">partitions</span> | <span class="type">type</span>  | <span class="type">possible_keys</span> | <span class="type">key</span>     | <span class="type">key_len</span> | <span class="type">ref</span>  | <span class="type">rows</span> | <span class="type">filtered</span> | <span class="type">Extra</span>           |<span class="type"></span></span><br><span class="line"><span class="type">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="type">|  1</span> | <span class="type">PRIMARY</span>      | <span class="type">user_info</span>  | <span class="type">NULL</span>       | <span class="type">range</span> | <span class="type">PRIMARY</span>       | <span class="type">PRIMARY</span> | <span class="type">8</span>       | <span class="type">NULL</span> |    <span class="type">3</span> |   <span class="type">100</span><span class="number">.00</span> | <span class="type">Using</span> <span class="keyword">where</span>     |<span class="type"></span></span><br><span class="line"><span class="type">|  2</span> | <span class="type">UNION</span>        | <span class="type">user_info</span>  | <span class="type">NULL</span>       | <span class="type">range</span> | <span class="type">PRIMARY</span>       | <span class="type">PRIMARY</span> | <span class="type">8</span>       | <span class="type">NULL</span> |    <span class="type">3</span> |   <span class="type">100</span><span class="number">.00</span> | <span class="type">Using</span> <span class="keyword">where</span>     |<span class="type"></span></span><br><span class="line"><span class="type">| NULL</span> | <span class="type">UNION</span> RESULT | <span class="type">&lt;union1</span>,<span class="number">2</span>&gt; | <span class="type">NULL</span>       | <span class="type">ALL</span>   | <span class="type">NULL</span>          | <span class="type">NULL</span>    | <span class="type">NULL</span>    | <span class="type">NULL</span> | <span class="type">NULL</span> |     <span class="type">NULL</span> | <span class="type">Using</span> temporary |<span class="type"></span></span><br><span class="line"><span class="type">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="type">3</span> rows <span class="built_in">in</span> <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.</p>
<h4 id="type-常用类型"><a href="#type-常用类型" class="headerlink" title="type 常用类型"></a>type 常用类型</h4><p>type 常用的取值有:</p>
<ul>
<li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li>
<li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li>
<li><p>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">user_info,</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_info.id</span> <span class="string">=</span> <span class="string">order_info.user_id\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">314</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">where;</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">2.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">eq_ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">test.order_info.user_id</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="number">2</span> <span class="string">rows</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">user_info,</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_info.id</span> <span class="string">=</span> <span class="string">order_info.user_id</span> <span class="string">AND</span> <span class="string">order_info.user_id</span> <span class="string">=</span> <span class="number">5</span><span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">2.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">2</span> <span class="string">rows</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.01</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</p>
</li>
</ul>
<p>例如下面的例子就是一个范围查询:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT *</span><br><span class="line">    -&gt;         <span class="keyword">FROM</span> user_info</span><br><span class="line">    -&gt;         WHERE id BETWEEN 2 <span class="keyword">AND</span> 8 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.</li>
</ul>
<p>例如:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">name</span> <span class="string">FROM</span>  <span class="string">user_info</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">name_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">152</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.</p>
<ul>
<li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">age</span> <span class="string">FROM</span>  <span class="string">user_info</span> <span class="string">WHERE</span> <span class="string">age</span> <span class="string">=</span> <span class="number">20</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ALL</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">10.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">where</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
<p><strong>type 类型的性能比较</strong></p>
<p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p>
<ul>
<li>字符串<ul>
<li>char(n): n 字节长度</li>
<li>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</li>
</ul>
</li>
<li>数值类型:<ul>
<li>TINYINT: 1字节</li>
<li>SMALLINT: 2字节</li>
<li>MEDIUMINT: 3字节</li>
<li>INT: 4字节</li>
<li>BIGINT: 8字节 </li>
</ul>
</li>
<li>时间类型<ul>
<li>DATE: 3字节</li>
<li>TIMESTAMP: 4字节</li>
<li>DATETIME: 8字节</li>
</ul>
</li>
</ul>
<p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p>
<p>我们来举两个简单的栗子:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_info <span class="keyword">WHERE</span> user_id &lt; <span class="number">3</span> <span class="keyword">AND</span> product_name = <span class="string">'p1'</span> <span class="keyword">AND</span> productor = <span class="string">'WHH'</span> \G</span><br><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         <span class="built_in">type</span>: range</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          <span class="keyword">key</span>: user_product_detail_index</span><br><span class="line">      key_len: <span class="number">9</span></span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: <span class="number">5</span></span><br><span class="line">     filtered: <span class="number">11.11</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; Using <span class="keyword">index</span></span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>上面的例子是从表 <code>order_info</code>中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure></p>
<p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 <code>user_id</code> 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 EXPLAIN 中, 显示的 <code>key_len</code> 为 9. 因为 <code>user_id</code> 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将<code>user_id</code> 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 <code>key_length</code> 应该是8.</p>
<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>
<p>接下来我们来看一下下一个例子:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_id</span> <span class="string">=</span> <span class="number">1</span> <span class="string">AND</span> <span class="string">product_name</span> <span class="string">=</span> <span class="string">'p1'</span> <span class="string">\G;</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">161</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const,const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
<p>这次的查询中, 我们没有使用到范围查询, <code>key_len</code> 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>
<ul>
<li>Using filesort<ul>
<li>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li>
</ul>
</li>
</ul>
<p>例如下面的例子:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">product_name</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">253</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index;</span> <span class="string">Using</span> <span class="string">filesort</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<p>我们的索引是<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure></p>
<p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为<code>ORDER BY user_id, product_name,</code> 那么就不会出现 <code>Using filesort</code> 了. 例如:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">user_id,</span> <span class="string">product_name</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">253</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Using index<ul>
<li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>
</ul>
</li>
<li>Using temporary<ul>
<li>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>
</ul>
</li>
</ul>
<h2 id="数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？"><a href="#数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？" class="headerlink" title="数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？"></a>数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>主要有两种情况，会导致缓存和 DB 的一致性问题：</p>
<ul>
<li>并发的场景下，导致读取老的 DB 数据，更新到缓存中。</li>
<li>缓存和 DB 的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致。</li>
</ul>
<p>当然，有一点我们要注意，缓存和 DB 的一致性，我们指的更多的是最终一致性。我们使用缓存只要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。例如说，我们可能缓存用户钱包的余额在缓存中，在前端查询钱包余额时，读取缓存，在使用钱包余额时，读取数据库。</p>
<h3 id="更新缓存的设计模式"><a href="#更新缓存的设计模式" class="headerlink" title="更新缓存的设计模式"></a>更新缓存的设计模式</h3><h4 id="Cache-Aside-Pattern-旁路缓存"><a href="#Cache-Aside-Pattern-旁路缓存" class="headerlink" title="Cache Aside Pattern(旁路缓存)"></a>Cache Aside Pattern(旁路缓存)</h4><p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<ul>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li>命中：应用程序从cache中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225116942.png" alt="image"></p>
<p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</p>
<blockquote>
<p>要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</p>
</blockquote>
<h4 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h4><p>在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</p>
<p>Read Through</p>
<p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<p>Write Through</p>
<p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p>
<p>下图自来Wikipedia的Cache词条。其中的Memory你可以理解为就是我们例子里的数据库。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225333630.png" alt="image"></p>
<h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>Write Behind 又叫 Write Back。write back就是Linux文件系统的Page Cache的算法。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。</p>
<blockquote>
<p>这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
</blockquote>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图，基本逻辑如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225423934.png" alt="image"></p>
<h3 id="缓存架构设计"><a href="#缓存架构设计" class="headerlink" title="缓存架构设计"></a>缓存架构设计</h3><h4 id="更新缓存-VS-淘汰缓存"><a href="#更新缓存-VS-淘汰缓存" class="headerlink" title="更新缓存 VS 淘汰缓存"></a>更新缓存 VS 淘汰缓存</h4><p>更新缓存：数据不但写入数据库，还会写入缓存；优点：缓存不会增加一次miss，命中率高</p>
<p>淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉；优点：简单</p>
<p>这两者的选择主要取决于“更新缓存的复杂度”。</p>
<p>例如，上述场景，只是简单的把余额money设置成一个值，那么：</p>
<p>（1）淘汰缓存的操作为deleteCache(uid)</p>
<p>（2）更新缓存的操作为setCache(uid, money)</p>
<p>更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率</p>
<p>如果余额是通过很复杂的数据计算得出来的，例如业务上除了账户表account，还有商品表product，折扣表discount</p>
<p>account(uid, money)</p>
<p>product(pid, type, price, pinfo)</p>
<p>discount(type, zhekou)</p>
<p>业务场景是用户买了一个商品product，这个商品的价格是price，这个商品从属于type类商品，type类商品在做促销活动要打折扣zhekou，购买了商品过后，这个余额的计算就复杂了，需要：</p>
<p>（1）先把商品的品类，价格取出来：SELECT type, price FROM product WHERE pid=XXX</p>
<p>（2）再把这个品类的折扣取出来：SELECT zhekou FROM discount WHERE type=XXX</p>
<p>（3）再把原有余额从缓存中查询出来money = getCache(uid)</p>
<p>（4）再把新的余额写入到缓存中去setCache(uid, money-price*zhekou)</p>
<p>更新缓存的代价很大，此时我们应该更倾向于淘汰缓存。</p>
<p>总之，淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。</p>
<h4 id="先操作数据库-vs-先操作缓存"><a href="#先操作数据库-vs-先操作缓存" class="headerlink" title="先操作数据库 vs 先操作缓存"></a>先操作数据库 vs 先操作缓存</h4><p>当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，又面临两种抉择：</p>
<p>（1）先写数据库，再淘汰缓存</p>
<p>（2）先淘汰缓存，再写数据库</p>
<p>对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，解决这个问题的方向是：如果出现不一致，谁先做对业务的影响较小，就谁先执行。</p>
<p>由于写数据库与淘汰缓存不能保证原子性，谁先谁后同样要遵循上述原则。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225728222.png" alt="image"></p>
<p>假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225736738.png" alt="image"></p>
<p>假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。</p>
<p>结论：数据和缓存的操作时序：先淘汰缓存，再写数据库。</p>
<h4 id="缓存架构优化"><a href="#缓存架构优化" class="headerlink" title="缓存架构优化"></a>缓存架构优化</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225756637.png" alt="image"></p>
<p>上述缓存架构有一个缺点：业务方需要同时关注缓存与DB，主要有两种优化方案：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2019070822580935.png" alt="image"></p>
<p>一种方案是服务化：加入一个服务层，向上游提供帅气的数据访问接口，向上游屏蔽底层数据存储的细节，这样业务线不需要关注数据是来自于cache还是DB。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225823969.png" alt="image"></p>
<p>另一种方案是异步缓存更新：业务线所有的写操作都走数据库，所有的读操作都总缓存，由一个异步的工具来做数据库与缓存之间数据的同步，具体细节是：</p>
<p>（1）要有一个init cache的过程，将需要缓存的数据全量写入cache</p>
<p>（2）如果DB有写操作，异步更新程序读取binlog，更新cache</p>
<p>在（1）和（2）的合作下，cache中有全部的数据，这样：</p>
<p>（a）业务线读cache，一定能够hit（很短的时间内，可能有脏数据），无需关注数据库</p>
<p>（b）业务线写DB，cache中能得到异步更新，无需关注缓存</p>
<p>这样将大大简化业务线的调用逻辑，存在的缺点是，如果缓存的数据业务逻辑比较复杂，async-update异步更新的逻辑可能也会比较复杂。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>（1）淘汰缓存是一种通用的缓存处理方式</p>
<p>（2）先淘汰缓存，再写数据库</p>
<p>（3）服务化是向业务方屏蔽底层数据库与缓存复杂性的一种通用方式</p>
<h3 id="缓存和DB一致性的解决方案"><a href="#缓存和DB一致性的解决方案" class="headerlink" title="缓存和DB一致性的解决方案"></a>缓存和DB一致性的解决方案</h3><h4 id="先淘汰缓存，再写数据库"><a href="#先淘汰缓存，再写数据库" class="headerlink" title="先淘汰缓存，再写数据库"></a>先淘汰缓存，再写数据库</h4><p>因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。因为先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。</p>
<p>但是，这种方案会存在缓存和 DB 的数据会不一致的情况，参照《缓存与数据库一致性优化》 所说。</p>
<p>我们需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。</p>
<ul>
<li>在写请求时，先淘汰缓存之前，获取该分布式锁。</li>
<li>在读请求时，发现缓存不存在时，先获取分布式锁。</li>
</ul>
<p>这样，缓存的并行写就成功的变成串行写落。写请求时，是否主动更新缓存，根据自己业务的需要，是否有，都没问题。</p>
<h4 id="先写数据库，再更新缓存"><a href="#先写数据库，再更新缓存" class="headerlink" title="先写数据库，再更新缓存"></a>先写数据库，再更新缓存</h4><p>按照“先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在“同一个事务”中，从而实现最终一致性。</p>
<p>基于定时任务来实现</p>
<ul>
<li>首先，写入数据库。</li>
<li>然后，在写入数据库所在的事务中，插入一条记录到任务表。该记录会存储需要更新的缓存 KEY 和 VALUE 。</li>
<li>【异步】最后，定时任务每秒扫描任务表，更新到缓存中，之后删除该记录。</li>
</ul>
<p>基于消息队列来实现</p>
<ul>
<li>首先，写入数据库。</li>
<li>然后，发送带有缓存 KEY 和 VALUE 的事务消息。此时，需要有支持事务消息特性的消息队列，或者我们自己封装消息队列，支持事务消息。</li>
<li>【异步】最后，消费者消费该消息，更新到缓存中。</li>
</ul>
<p>这两种方式，可以进一步优化，可以先尝试更新缓存，如果失败，则插入任务表，或者事务消息。</p>
<p>另外，极端情况下，如果并发写执行时，先更新成功 DB 的，结果后更新缓存：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225900770.png" alt="image"></p>
<p>理论来说，希望的更新缓存顺序是，线程 1 快于线程 2 ，但是实际线程1 晚于线程 2 ，导致数据不一致。</p>
<p>图中一直是基于定时任务或消息队列来实现异步更新缓存，如果网络抖动，导致【插入任务表，或者事务消息】的顺序不一致。</p>
<p>那么怎么解决呢？需要做如下三件事情：</p>
<p>1、在缓存值中，拼接上数据版本号或者时间戳。例如说：value = {value: 原值, version: xxx} 。</p>
<p>2、在任务表的记录，或者事务消息中，增加上数据版本号或者时间戳的字段。</p>
<p>3、在定时任务或消息队列执行更新缓存时，先读取缓存，对比版本号或时间戳，大于才进行更新。 当然，此处也会有并发问题，所以还是得引入分布式锁或 CAS 操作。</p>
<p>关于 Redis 分布式锁，可以看看 <a href="http://svip.iocoder.cn/Redis/Interview" target="_blank" rel="noopener">《精尽 Redis 面试题》</a> 的 <a href="http://svip.iocoder.cn/Cache/Interview/#" target="_blank" rel="noopener">「如何使用 Redis 实现分布式锁？」 </a>问题。</p>
<p>关于 Redis CAS 操作，可以看看 <a href="http://svip.iocoder.cn/Redis/Interview" target="_blank" rel="noopener">《精尽 Redis 面试题》</a> 的 <a href="http://svip.iocoder.cn/Cache/Interview/#" target="_blank" rel="noopener">「什么是 Redis 事务？」 </a>问题。</p>
<h4 id="基于数据库的-binlog-日志"><a href="#基于数据库的-binlog-日志" class="headerlink" title="基于数据库的 binlog 日志"></a>基于数据库的 binlog 日志</h4><h5 id="重客户端"><a href="#重客户端" class="headerlink" title="重客户端"></a>重客户端</h5><p>写入缓存：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230031559.png" alt="image"></p>
<ul>
<li>应用同时更新数据库和缓存</li>
<li>如果数据库更新成功，则开始更新缓存，否则如果数据库更新失败，则整个更新过程失败。</li>
<li>判断更新缓存是否成功，如果成功则返回</li>
<li>如果缓存没有更新成功，则将数据发到MQ中</li>
<li>应用监控MQ通道，收到消息后继续更新Redis。</li>
</ul>
<p>问题点：如果更新Redis失败，同时在将数据发到MQ之前的时间，应用重启了，这时候MQ就没有需要更新的数据，如果Redis对所有数据没有设置过期时间，同时在读多写少的场景下，只能通过人工介入来更新缓存。</p>
<p>读缓存：</p>
<p>如何来解决这个问题？那么在写入Redis数据的时候，在数据中增加一个时间戳插入到Redis中。在从Redis中读取数据的时候，首先要判断一下当前时间有没有过期，如果没有则从缓存中读取，如果过期了则从数据库中读取最新数据覆盖当前Redis数据并更新时间戳。具体过程如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230102585.png" alt="image"></p>
<h5 id="客户端数据库与缓存解耦"><a href="#客户端数据库与缓存解耦" class="headerlink" title="客户端数据库与缓存解耦"></a>客户端数据库与缓存解耦</h5><p>上述方案对于应用的研发人员来讲比较重，需要研发人员同时考虑数据库和Redis是否成功来做不同方案，如何让研发人员只关注数据库层面，而不用关心缓存层呢？请看下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230139385.png" alt="image"></p>
<ul>
<li>应用直接写数据到数据库中。</li>
<li>数据库更新binlog日志。</li>
<li>利用Canal中间件读取binlog日志。</li>
<li>Canal借助于限流组件按频率将数据发到MQ中。</li>
<li>应用监控MQ通道，将MQ的数据更新到Redis缓存中。</li>
</ul>
<p>可以看到这种方案对研发人员来说比较轻量，不用关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。</p>
<p>PS：下面这两种比较实用</p>
<p>“先淘汰缓存，再写数据库”的方案，并且无需引入分布式锁。</p>
<p>“先写数据库，再更新缓存”的方案，并且无需引入定时任务或者消息队列。</p>
<p>使用缓存过程中，经常会遇到缓存数据的不一致性和脏读现象。一般情况下，采取缓存双淘汰机制，在更新数据库的前淘汰缓存。此外，设定超时时间，例如三十分钟。</p>
<p>极端场景下，即使有脏数据进入缓存，这个脏数据也最存在一段时间后自动销毁。</p>
<h3 id="主从DB与cache一致性优化"><a href="#主从DB与cache一致性优化" class="headerlink" title="主从DB与cache一致性优化"></a><a href="https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-master-and-slave-database.html" target="_blank" rel="noopener">主从DB与cache一致性优化</a></h3><h2 id="聚簇索引-非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"><a href="#聚簇索引-非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？" class="headerlink" title="聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"></a>聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p> 1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
<p>2.所有结点存储一个关键字；</p>
<p>3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p>
<p>如：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1.JPG" alt="image"></p>
<p>二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；</p>
<p>否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入</p>
<p>右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</p>
<p>如果 二叉搜索树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么 二叉搜索树</p>
<p>的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变 二叉搜索树结构</p>
<p>（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p>如：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2.JPG" alt="image"></p>
<p>但 二叉搜索树在经过多次插入与删除后，有可能导致不同的结构：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/31.JPG" alt="image"></p>
<p>右边也是一个 二叉搜索树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的</p>
<p>树结构索引；所以，使用 二叉搜索树还要考虑尽可能让 二叉搜索树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      </p>
<p>实际使用的 二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即“平衡二叉树”；如何保持 二叉搜索树</p>
<p>结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在 二叉搜索树中插入和删除结点的策略；</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>是一种多路搜索树（并不是二叉的）：</p>
<p>1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
<p>2.根结点的儿子数为[2, M]；</p>
<p>3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
<p>4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
<p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
<p>7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
<p>8.所有叶子结点位于同一层；</p>
<p>如：（M=3）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/4.JPG" alt="image"></p>
<p>  B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果</p>
<p>命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为</p>
<p>空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<p>1.关键字集合分布在整颗树中；</p>
<p>2.任何一个关键字出现且只出现在一个结点中；</p>
<p>3.搜索有可能在非叶子结点结束；</p>
<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>5.自动层次控制；</p>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少</p>
<p>利用率，其最底搜索性能为：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0.JPG" alt="image"></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；</p>
<p>所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；</p>
<p>由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p> B+树是B-树的变体，也是一种多路搜索树：</p>
<p>1.其定义基本与B-树同，除了：</p>
<p>2.非叶子结点的子树指针与关键字个数相同；</p>
<p>3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树</p>
<p>（B-树是开区间）；</p>
<p>5.为所有叶子结点增加一个链指针；</p>
<p>6.所有关键字都在叶子结点出现；<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/5.JPG" alt="image"></p>
<p> B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p>
<p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p>B+的特性：</p>
<p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好</p>
<p>是有序的；</p>
<p>2.不可能在非叶子结点命中；</p>
<p>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储</p>
<p>（关键字）数据的数据层；</p>
<p>4.更适合文件索引系统；</p>
<h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h3><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/6.JPG" alt="image"></p>
<p><code>B*</code>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3</p>
<p>（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据</p>
<p>复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父</p>
<p>结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分</p>
<p>数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字</p>
<p>（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之</p>
<p>间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>
<p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：</p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中</p>
<p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111257402.png" alt="image"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111258238.png" alt="image"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<p>InnoDB索引实现</p>
<p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111259913.png" alt="image"></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111300494.png" alt="image"></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<ul>
<li>MyisAM顺序储存数据，索引叶子节点保存对应数据行地址，辅助索引跟主键索引相差无几（主键索引key不能相同）；InnoDB主键节点同时保存数据行，其他辅助索引保存的是主键索引的值；</li>
</ul>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调(可能是指“非递增”的意思)的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调(可能是指“非递增”的意思)的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h3 id="为什么选用B-Tree"><a href="#为什么选用B-Tree" class="headerlink" title="为什么选用B+/-Tree"></a>为什么选用B+/-Tree</h3><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>
<p>B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。</p>
<p>B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。</p>
<h2 id="MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？"><a href="#MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？" class="headerlink" title="MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？"></a>MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？</h2><h3 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>mysql 默认的隔离级别:可重复读</li>
<li>Oracle 默认的隔离</li>
<li>级别:读已提交</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。<br>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能</p>
<p>了解MVCC前，我们先学习下Mysql架构和数据库事务隔离级别</p>
<h4 id="MYSQL-架构"><a href="#MYSQL-架构" class="headerlink" title="MYSQL 架构"></a>MYSQL 架构</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190706105542781.png" alt="image"></p>
<p>MySQL从概念上可以分为四层，顶层是接入层，不同语言的客户端通过mysql的协议与mysql服务器进行连接通信，接入层进行权限验证、连接池管理、线程管理等。下面是mysql服务层，包括sql解析器、sql优化器、数据缓冲、缓存等。再下面是mysql中的存储引擎层，mysql中存储引擎是基于表的。最后是系统文件层，保存数据、索引、日志等。</p>
<h4 id="MVCC是为了解决什么问题"><a href="#MVCC是为了解决什么问题" class="headerlink" title="MVCC是为了解决什么问题?"></a>MVCC是为了解决什么问题?</h4><ul>
<li>大多数的MYSQL事务型存储引擎,如,InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制.事实上,他们都和MVCC–多版本并发控制来一起使用。</li>
<li>大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销。</li>
</ul>
<h4 id="MVCC具体实现"><a href="#MVCC具体实现" class="headerlink" title="MVCC具体实现"></a>MVCC具体实现</h4><p>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。<br>下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</p>
<ul>
<li>SELECT<ul>
<li>InnoDB会根据以下两个条件检查每行记录：<ul>
<li>1、InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>2、行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
<li>只有符合上述两个条件的记录，才能返回作为查询结果。</li>
</ul>
</li>
</ul>
</li>
<li>INSERT<ul>
<li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li>
</ul>
</li>
<li>DELETE<ul>
<li>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li>
</ul>
</li>
<li>UPDATE<ul>
<li>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li>
<li>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作</li>
</ul>
</li>
</ul>
<p>举例Demo<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> riemann( </span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure></p>
<p>transaction 1:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'riemann'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'chow'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<p>假设系统初始事务ID为1；</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>transaction 2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> riemann ;  //(1)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> riemann ;  //(2)</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>
<h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务3：</p>
<p>transaction 3:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'peng'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>3</td>
<td>peng</td>
<td>3</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>事务3执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务3新增的记录在事务2中是查不出来的，这就通过乐观锁的方式避免了幻读的产生。</p>
<h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务4：</p>
<p>transaction session 4:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> riemann <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'edgar'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>edgar</td>
<td>4</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>事务4执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务修改的记录在事务2中是查不出来的，这样就保证了事务在两次读取时读取到的数据的状态是一致的。</p>
<h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务5：</p>
<p>transaction session 5:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> riemann <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>事务5执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2、并且过期时间大于等于2，所以id=2的记录在事务2 语句2中，也是可以查出来的,这样就保证了事务在两次读取时读取到的数据的状态是一致的。</p>
<h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p>MVCC(Multi-Version Concurrent Control)：多版本并发控制，只作用于RC和RR隔离级别，主要是为了避免脏读、非重复读，而非幻读，很多文章说通过MVCC避免幻读，其实这种说法是不完善的，RR隔离级别是通过next-key lock 来避免幻读。</p>
<p>优点：避免了许多需要加锁的情形</p>
<p>缺点：需要维护每行记录版本号，造成额外资源消耗</p>
<p>怎么避免脏读、不可重复读、幻读？</p>
<p>采用RR隔离级别，结合MVCC特性，可以避免脏读、非重复读，有些文章说MVCC用来避免幻读，其实这是不准确的，MVCC通过多版本并发控制来避免非重复读，像幻读定义所说的情况即使有MVCC还是会存在。RR隔离级别是通过禁用innodb_locks_unsafe_for_binlog，在搜索和扫描索引的时候使用next-key locks来避免幻读（下面有对锁说明）。也就是为什么RR隔离级别下，非主键索引DML的操作并发性能会下降的原因了。</p>
<p>为了减少Next-key lock影响，可以设置innodb_locks_unsafe_for_binlog=1，就是disable Next-Key lock，但是并不建议。</p>
<p>想要真正避免幻读只能采取serializable串行化隔离级别，因为都要加表级共享锁或排他锁，所以性能会很差，一般不会采用。</p>
<p>MVCC如何避免非重复读：</p>
<p>MVCC为查询提供了一个基于时间的点的快照。这个查询只能看到在自己之前提交的数据，而在查询开始之后提交的数据是不可以看到的。</p>
<p>在每行记录后面记录两个隐藏的列，一个记录创建时间，一个记录删除时间，记录的是版本号，这里可以理解为事物号。</p>
<p>INSERT：Innodb 为新插入的每一行保存当前系统版本号作为行版本号；</p>
<p>DELETE：Innodb 为删除的每一行保存当前系统版本号作为行删除标识；</p>
<p>UPDATE：Innodb 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<h4 id="RR隔离级别下锁介绍"><a href="#RR隔离级别下锁介绍" class="headerlink" title="RR隔离级别下锁介绍"></a>RR隔离级别下锁介绍</h4><h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h5><p>在主键或唯一索引上对单行记录加锁</p>
<h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h5><p>针对非唯一索引而言，锁定一个范围的记录，但不包括记录本身。锁加在未使用的空闲空间上，可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。</p>
<p>如果更新两端的记录会影响到间隙锁，那么操作会被挂起，等待间隙锁释放。</p>
<p>比如锁定范围（4，7），update table set v1=6 where v1=1; 虽然1不在此范围，但是6在（4，7）范围还是会锁定。</p>
<h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><p>针对非唯一索引而言，行记录锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p>
<p>通过一个例子介绍间隙锁</p>
<p>表test5中存在如下数据：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113023312.png" alt="image"></p>
<p>select * from test5 where v1=45 for update; 对v1=45的行加X锁，此时会对(40,45][45,50)加间隙锁，其他事物不能操作在此范围内的数据。</p>
<p>但是为什么在左侧值为40，右侧值为50的时候，有时候操作会被挂起，有时候操作不会挂起呢？</p>
<p>update table set v1=41 where v1=40;41在(40，50)范围会被锁定。</p>
<p>update table set v1=39 where v1=40; 39不在(40，50)范围不会被锁定。</p>
<p>update table set v1=42 where v1=1; 42在(40，50)范围会被锁定。</p>
<p>update table set v1=30 where v1=45; 30不在(40，50)范围，但是45行上面存在的行级record lock，45行记录也被加了锁。</p>
<p>insert into table(id,name) values(14,40);可以插入</p>
<p>insert into table(id,name) values(20,40);不可以插入</p>
<p>insert into table(id,name) values(13,50);不可以插入</p>
<p>insert into table(id,name) values(21,40);可以插入</p>
<p>当插入左侧值的时候，即插入v1=40的时候，要求插入的id值小于id=16的范围。当v1=40的记录有多条的时候，插入的id值要小于其中的最大id值。则可以成功插入；</p>
<p>当插入右侧值的时候，即插入v1=50的时候，要求插入的id值要大于id=18的范围。当v1=50的记录有多条的时候，插入的id值要大于其中的最小id值。则可以成功插入。</p>
<p>所以为什么RR隔离级别下并发性能会有所下降，就是因为存在间隙锁。我们应该尽量使用主键或唯一索引，因为唯一索引会把Next-Key Lock降级为Record Lock。</p>
<h5 id="AUTO-INC-Lock"><a href="#AUTO-INC-Lock" class="headerlink" title="AUTO-INC Lock"></a>AUTO-INC Lock</h5><p>只针对存在主键的insert操作，由innodb_autoinc_lock_mode参数决定锁粒度。</p>
<p>在了解自增锁前需要知道mysql都有哪些insert操作：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT-like</td>
<td>所有可以向表中增加行的语句</td>
</tr>
<tr>
<td>Simple inserts</td>
<td>可以预先确定要插入的行数insert…values…</td>
</tr>
<tr>
<td>Bulk inserts</td>
<td>事先不知道要插入的行数（INSERT…SELECT,REPLACE…SELECT,LOAD  DATA）</td>
</tr>
<tr>
<td>Mixed-mode inserts</td>
<td>一些是“Simple  inserts”语句但是有一些是null的自增值</td>
</tr>
</tbody>
</table>
<p>innodb_autoinc_lock_mode= 0 传统锁定模式（所有insert采用传统AUTO-INC机制），所有“INSERT-like”语句获得一个特殊的表级AUTO-INC锁，在存在自增列的表获得一个特殊的表级AUTO-INC锁，(statement-based replication)操作是安全。</p>
<p>innodb_autoinc_lock_mode= 1 默认锁定模式（bulk-insert采用表级锁）</p>
<p>“bulk inserts”仍然使用AUTO-INC表级锁,并保持到语句结束；“Simple inserts”（要插入的行数事先已知）通过在mutex（轻量锁）的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁，只在分配的时间内持有，不是整个语句，(statement-based replication)操作是安全。</p>
<p>innodb_autoinc_lock_mode= 2 轻量锁定模式(所有insert采用轻量级）</p>
<p>所有类INSERT(“INSERT-like” )语句都不会使用表级AUTO-INC lock，”批量插入”时，在由任何给定语句分配的自动递增值中可能存在间隙，(statement-based replication)操作是不安全。</p>
<p>可以汇总为如下表格：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113110216.png" alt="image"></p>
<p>示例：innodb_autoinc_lock_mode= 1时不连续</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建一个表id为自增主键：</span><br><span class="line"></span><br><span class="line">CREATE TABLE `test6` (</span><br><span class="line"></span><br><span class="line">id int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">name int(11),</span><br><span class="line">modified TIMESTAMP<span class="built_in"> DEFAULT </span>CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB <span class="attribute">AUTO_INCREMENT</span>=1<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<p>先插入一条记录，然后再多次自插入数据，发现id没有5、10~12，如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113601623.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711355127.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711351276.png" alt="image"></p>
<p>这种情况就是上面锁说的，insert…select…属于Bulk insert，不能预判要插入多少条数据，所以在自增值分配上每次都会按照2^n-1分配：</p>
<p>第一次，先分配一个自增值，因为只有一条数据，正好</p>
<p>第二次，先分配一个自增值3，发现还有数据，继续按2^n-1分配，分配4、5，此时只剩一条数据4，但5已经被分配出去。</p>
<p>第三次，因为5已经被分配出去，此时只能从6开始，以此类推。</p>
<h5 id="Dead-lock"><a href="#Dead-lock" class="headerlink" title="Dead lock"></a>Dead lock</h5><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。</p>
<p>死锁检测开关innodb_deadlock_detect 5.7.15后引入，关闭会提升性能，一般应用在秒杀等场景。</p>
<p>出现死锁场景很多，绝大多数是高并发下同时操作一行数据，加锁顺序相反引起。</p>
<p>先删再插，两条insert当需要进行唯一性冲突检测时，需要先加一个S锁，也会产生死锁。</p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p>
<h3 id="MySQL-中RC和RR隔离级别的区别"><a href="#MySQL-中RC和RR隔离级别的区别" class="headerlink" title="MySQL 中RC和RR隔离级别的区别"></a>MySQL 中RC和RR隔离级别的区别</h3><p>MySQL数据库中默认隔离级别为RR，但是实际情况是使用RC 和 RR隔离级别的都不少。好像淘宝、网易都是使用的 RC 隔离级别。那么在MySQL中 RC 和 RR有什么区别呢？我们该如何选择呢？为什么MySQL将RR作为默认的隔离级别呢？</p>
<h4 id="RC-与-RR-在锁方面的区别"><a href="#RC-与-RR-在锁方面的区别" class="headerlink" title="RC 与 RR 在锁方面的区别"></a>RC 与 RR 在锁方面的区别</h4><p>1&gt; 显然 RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR；</p>
<p>2&gt; RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉(虽然这里破坏了“两阶段加锁原则”)；但是RR隔离级别，即使不符合where条件的记录，也不会是否行锁和gap lock；所以从锁方面来看，RC的并发应该要好于RR；另外 insert into t select … from s where 语句在s表上的锁也是不一样的，参见下面的例子2；</p>
<p>下面是来自 <a href="http://www.itpub.net/thread-1941624-1-1.html" target="_blank" rel="noopener">github</a> 的一个例子：</p>
<p>MySQL5.6, 隔离级别RR，autocommit=off;</p>
<p>表结构：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">create</span> table t1\G</span><br><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line">       Table: t1</span><br><span class="line"><span class="keyword">Create</span> Table: <span class="keyword">CREATE</span> TABLE <span class="symbol">`t1`</span> (</span><br><span class="line">  <span class="symbol">`a`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`b`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`c`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`d`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`e`</span> varchar(<span class="number">20</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="symbol">`idx_t1_bcd`</span> (<span class="symbol">`b`</span>,<span class="symbol">`c`</span>,<span class="symbol">`d`</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>表数据：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from t1;</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">|<span class="string"> a </span>|<span class="string"> b </span>|<span class="string"> c </span>|<span class="string"> d </span>|<span class="string"> e    </span>|</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> a    </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> b    </span>|</span><br><span class="line">|<span class="string"> 3 </span>|<span class="string"> 3 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> c    </span>|</span><br><span class="line">|<span class="string"> 4 </span>|<span class="string"> 3 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> d    </span>|</span><br><span class="line">|<span class="string"> 5 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 5 </span>|<span class="string"> e    </span>|</span><br><span class="line">|<span class="string"> 6 </span>|<span class="string"> 6 </span>|<span class="string"> 4 </span>|<span class="string"> 4 </span>|<span class="string"> f    </span>|</span><br><span class="line">|<span class="string"> 7 </span>|<span class="string"> 4 </span>|<span class="string"> 5 </span>|<span class="string"> 5 </span>|<span class="string"> g    </span>|</span><br><span class="line">|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> h    </span>|</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>session 1:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from <span class="built_in">t1</span> where <span class="keyword">b&gt;2 </span><span class="keyword">and </span><span class="keyword">b&lt;5 </span><span class="keyword">and </span>c=<span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>执行计划如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> t1 where b&gt;2 <span class="keyword">and</span> b&lt;5 <span class="keyword">and</span> <span class="attribute">c</span>=2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: idx_t1_bcd</span><br><span class="line">          key: idx_t1_bcd</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>session 2:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span> <span class="built_in">from</span> t1 where <span class="keyword">a</span>=<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>结果 session 2 被锁住。<br>session 3:<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from information_schema.innodb_locks;</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">|<span class="string"> lock_id       </span>|<span class="string"> lock_trx_id </span>|<span class="string"> lock_mode </span>|<span class="string"> lock_type </span>|<span class="string"> lock_table  </span>|<span class="string"> lock_index </span>|<span class="string"> lock_space </span>|<span class="string"> lock_page </span>|<span class="string"> lock_rec </span>|<span class="string"> lock_data </span>|</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">|<span class="string"> 38777:390:3:5 </span>|<span class="string"> 38777       </span>|<span class="string"> X         </span>|<span class="string"> RECORD    </span>|<span class="string"> `test`.`t1` </span>|<span class="string"> PRIMARY    </span>|<span class="string">        390 </span>|<span class="string">         3 </span>|<span class="string">        5 </span>|<span class="string"> 4         </span>|</span><br><span class="line">|<span class="string"> 38771:390:3:5 </span>|<span class="string"> 38771       </span>|<span class="string"> X         </span>|<span class="string"> RECORD    </span>|<span class="string"> `test`.`t1` </span>|<span class="string"> PRIMARY    </span>|<span class="string">        390 </span>|<span class="string">         3 </span>|<span class="string">        5 </span>|<span class="string"> 4         </span>|</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br></pre></td></tr></table></figure></p>
<p>根据锁及ICP的知识，此时加锁的情况应该是在索引  <code>idx_t1_bcd</code> 上的<code>b&gt;2 and b&lt;5</code>之间加<code>gap lock</code>, <code>idx_t1_bcd</code>上的c=2 加 X锁主键 a=3 加 x 锁。<br>应该a=4上是没有加X锁的，可以进行删除与更改。<br>但是从session3上的结果来，此时a=4上被加上了X锁。<br>求大牛解惑，谢谢。</p>
<p>要理解这里为什么 a=4 被锁住了，需要理解 gap lock，锁处理 RR 隔离级别和RC隔离级别的区别等等。</p>
<p>这里的原因如下：</p>
<p>很简单，我们注意到：<code>key_len</code>: 4 和 Extra: Using index condition<br>这说明了，仅仅使用了索引 <code>idx_t1_bcd</code> 中的 b 一列，没有使用到 c 这一列。c 这一列是在ICP时进行过滤的。所以：</p>
<p><code>delete from t1 where b&gt;2 and b&lt;5 and c=2</code> 其实锁定的行有：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where b&gt;2 and b&lt;=6;</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">| a | b | c | d | e    |</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">| 3 | 3 | 2 | 2 | c    |</span><br><span class="line">| 4 | 3 | 1 | 1 | d    |</span><br><span class="line">| 6 | 6 | 4 | 4 | f    |</span><br><span class="line">| 7 | 4 | 5 | 5 | g    |</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>所以显然 <code>delete from t1 where a=4</code>就被阻塞了。那么为什么 <code>delete from t1 where a=6</code> 也会被阻塞呢？？？</p>
<p>这里 <code>b&lt;=6</code>的原因是，b 列中没有等于 5 的记录，所以 <code>and b&lt;5</code> 实现为锁定 <code>b&lt;=6</code> 的所有索引记录，这里有等于号的原因是，如果我们不锁定 =6 的索引记录，那么怎么实现锁定 <code>&lt;5</code> 的gap 呢？也就是说锁定 b=6 的索引记录，是为了实现锁定 <code>b&lt; 5</code> 的gap。也就是不能删除 b=6 记录的原因。<br>而这里 b &gt;2 没有加等于号(b&gt;=2) 的原因，是因为 b&gt;2的这个gap 是由 b=3这个索引记录(的gap)来实现的，不是由 b=2索引记录(的gap) 来实现的，b=2的索引记录的gap lock只能实现锁定<code>&lt;2</code>的gap，b&gt;2的gap锁定功能，需要由 b=3的索引记录对应的gap来实现(b&gt;2，<code>b&lt;3</code>的gap)。<br>所以我们在session2中可以删除：a=1,2,5,8的记录，但是不能删除 a=6(因为该行的b=6)的记录。</p>
<p>如果我们使用 RC 隔离级别时，则不会发生阻塞，其原因就是：</p>
<p>RC和RR隔离级别中的锁处理不一样，RC隔离级别时，在使用c列进行ICP where条件过滤时，对于不符合条件的记录，锁会释放掉，而RR隔离级别时，即使不符合条件的记录，锁也不会释放(虽然违反了“2阶段锁”原则)。所以RC隔离级别时session 2不会被阻塞。</p>
<p>Gap lock: This is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</p>
<p>例子2：<code>insert into t select ... from s where</code> 在RC 和 RR隔离级别下的加锁过程</p>
<p>下面是官方文档中的<a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-locks-set.html" target="_blank" rel="noopener">说明</a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> ... <span class="keyword">sets</span> an exclusive <span class="keyword">index</span> <span class="built_in">record</span> <span class="keyword">lock</span> (<span class="keyword">without</span> a gap <span class="keyword">lock</span>) <span class="keyword">on</span> <span class="keyword">each</span> <span class="keyword">row</span> inserted <span class="keyword">into</span> T. <span class="keyword">If</span> the <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED, <span class="keyword">or</span> innodb_locks_unsafe_for_binlog <span class="keyword">is</span> enabled <span class="keyword">and</span> the <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">SERIALIZABLE</span>, <span class="keyword">InnoDB</span> does the <span class="keyword">search</span> <span class="keyword">on</span> S <span class="keyword">as</span> a <span class="keyword">consistent</span> <span class="keyword">read</span> (<span class="keyword">no</span> locks). Otherwise, <span class="keyword">InnoDB</span> <span class="keyword">sets</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">on</span> <span class="keyword">rows</span> <span class="keyword">from</span> S. <span class="keyword">InnoDB</span> has <span class="keyword">to</span> <span class="keyword">set</span> locks <span class="keyword">in</span> the latter <span class="keyword">case</span>: <span class="keyword">In</span> roll-forward <span class="keyword">recovery</span> <span class="keyword">from</span> a <span class="keyword">backup</span>, every <span class="keyword">SQL</span> <span class="keyword">statement</span> must be executed <span class="keyword">in</span> exactly the same way it was done originally.</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ... <span class="keyword">SELECT</span> ... performs the <span class="keyword">SELECT</span> <span class="keyword">with</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">or</span> <span class="keyword">as</span> a <span class="keyword">consistent</span> <span class="keyword">read</span>, <span class="keyword">as</span> <span class="keyword">for</span> <span class="keyword">INSERT</span> ... SELECT.</span><br><span class="line"></span><br><span class="line"><span class="keyword">When</span> a <span class="keyword">SELECT</span> <span class="keyword">is</span> used <span class="keyword">in</span> the constructs <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> s <span class="keyword">WHERE</span> ... <span class="keyword">or</span> <span class="keyword">UPDATE</span> t ... <span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> s ...), <span class="keyword">InnoDB</span> <span class="keyword">sets</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">on</span> <span class="keyword">rows</span> <span class="keyword">from</span> <span class="keyword">table</span> s.</span><br></pre></td></tr></table></figure>
<p><code>insert inot t select ... from s where ...</code>语句和 <code>create table ... select ... from s where</code>加锁过程是相似的(RC 和 RR 加锁不一样)：</p>
<p>1&gt; RC 隔离级别时和 RR隔离级别但是设置<code>innodb_locks_unsafe_for_binlog=1</code> 时，<code>select ... from s where</code>对 s 表进行的是一致性读，所以是无需加锁的；</p>
<p>2&gt; 如果是RR隔离级别(默认<code>innodb_locks_unsafe_for_binlog</code>=0)，或者是 serializable隔离级别，那么对 s 表上的每一行都要加上 <code>shared next-key lock</code>.</p>
<p>这个区别是一个很大的不同，下面是生成中的一个 <code>insert into t select ... from s where</code>导致的系统宕机的案例：</p>
<p>一程序猿执行一个分表操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_async_src_acct_201508 <span class="keyword">select</span> * <span class="keyword">from</span> tb_async_src_acct </span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> src_status=<span class="number">3</span> <span class="keyword">and</span> create_time&gt;=<span class="string">'2015-08-01 00:00:00'</span> <span class="keyword">and</span> create_time &lt;= <span class="string">'2015-08-31 23:59:59'</span>;</span><br></pre></td></tr></table></figure></p>
<p>表 <code>tb_async_src_acct</code>有4000W数据。分表的目的是想提升下性能。结果一执行该语句，该条SQL被卡住，然后所有向 <code>tb_async_src_acct</code>的写操作，要么是 get lock fail, 要么是 lost connection，全部卡住，然后主库就宕机了。</p>
<p>显然这里的原因，就是不知道默认RR隔离级别中 <code>insert into t select ... from s where</code>语句的在 s 表上的加锁过程，该语句一执行，所有符合 where 条件的 s 表中的行记录都会加上 <code>shared next-key lock</code>(如果没有使用到索引，还会锁住表中所有行)，在整个事务过程中一直持有，因为表 <code>tb_async_src_acct</code> 数据很多，所以运行过程是很长的，所以加锁过程也是很长，所以其它所有的对<code>tb_async_src_acct</code> 的insert, delete, update, DDL 都会被阻塞掉，这样被阻塞的事务就越来越多，而事务也会申请其它的表中的行锁，结果就是系统中被卡住的事务越来越多，系统自然就宕机了。</p>
<h4 id="RC-与-RR-在复制方面的区别"><a href="#RC-与-RR-在复制方面的区别" class="headerlink" title="RC 与 RR 在复制方面的区别"></a>RC 与 RR 在复制方面的区别</h4><ul>
<li>RC 隔离级别不支持 statement 格式的bin log，因为该格式的复制，会导致主从数据的不一致；只能使用 mixed 或者 row 格式的bin log; 这也是为什么MySQL默认使用RR隔离级别的原因。复制时，我们最好使用：<code>binlog_format=row</code></li>
<li>MySQL5.6 的早期版本，RC隔离级别是可以设置成使用statement格式的bin log，后期版本则会直接报错；</li>
</ul>
<h4 id="RC-与-RR-在一致性读方面的区别"><a href="#RC-与-RR-在一致性读方面的区别" class="headerlink" title="RC 与 RR 在一致性读方面的区别"></a>RC 与 RR 在一致性读方面的区别</h4><p>简单而且，RC隔离级别时，事务中的每一条select语句会读取到他自己执行时已经提交了的记录，也就是每一条select都有自己的一致性读ReadView; 而RR隔离级别时，事务中的一致性读的ReadView是以第一条select语句的运行时，作为本事务的一致性读snapshot的建立时间点的。只能读取该时间点之前已经提交的数据。</p>
<h4 id="RC-支持半一致性读，RR不支持"><a href="#RC-支持半一致性读，RR不支持" class="headerlink" title="RC 支持半一致性读，RR不支持"></a>RC 支持半一致性读，RR不支持</h4><p>RC隔离级别下的update语句，使用的是半一致性读(semi consistent)；而RR隔离级别的update语句使用的是当前读；当前读会发生锁的阻塞。</p>
<p>1&gt; 半一致性读：</p>
<blockquote>
<p>A type of read operation used for UPDATE statements, that is a combination of read committed and consistent read. When an UPDATE statement examines a row that is already locked, InnoDB returns the latest committed version to MySQL so that MySQL can determine whether the row matches the WHERE condition of the UPDATE. If the row matches (must be updated), MySQL reads the row again, and this time InnoDB either locks it or waits for a lock on it. This type of read operation can only happen when the transaction has the read committed isolation level, or when the innodb_locks_unsafe_for_binlog option is enabled.</p>
</blockquote>
<p>简单来说，semi-consistent read是read committed与consistent read两者的结合。一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足 update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)。semi-consistent read只会发生在read committed隔离级别下，或者是参数<code>innodb_locks_unsafe_for_binlog</code>被设置为true(该参数即将被废弃)。</p>
<p>对比RR隔离级别，update语句会使用当前读，如果一行被锁定了，那么此时会被阻塞，发生锁等待。而不会读取最新的提交版本，然后来判断是否符合where条件。</p>
<p>半一致性读的优点：</p>
<p>减少了update语句时行锁的冲突；对于不满足update更新条件的记录，可以提前放锁，减少并发冲突的概率。</p>
<p>具体可以<a href="http://hedengcheng.com/?p=220" target="_blank" rel="noopener">参见</a>：</p>
<p>Oracle中的update好像有“重启动”的概念。</p>
<h2 id="MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁"><a href="#MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁" class="headerlink" title="MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁"></a>MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁</h2><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>之前我们介绍了排他锁，其实innodb下的记录锁（也叫行锁），间隙锁，next-key锁统统属于排他锁。</p>
<p>行锁<br>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。</p>
<p>生活中的间隙锁<br>编程的思想源于生活，生活中的例子能帮助我们更好的理解一些编程中的思想。<br>生活中排队的场景，小明，小红，小花三个人依次站成一排，此时，如何让新来的小刚不能站在小红旁边，这时候只要将小红和她前面的小明之间的空隙封锁，将小红和她后面的小花之间的空隙封锁，那么小刚就不能站到小红的旁边。<br>这里的小红，小明，小花，小刚就是数据库的一条条记录。<br>他们之间的空隙也就是间隙，而封锁他们之间距离的锁，叫做间隙锁。</p>
<p>Mysql中的间隙锁<br>下表中（见图一），id为主键，number字段上有非唯一索引的二级索引，有什么方式可以让该表不能再插入number=5的记录？<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-ad0d50c44dc041be.png" alt="image"></p>
<p>图一<br>根据上面生活中的例子，我们自然而然可以想到，只要控制几个点，number=5之前不能插入记录，number=5现有的记录之间不能再插入新的记录，number=5之后不能插入新的记录，那么新的number=5的记录将不能被插入进来。</p>
<p>那么，mysql是如何控制number=5之前，之中，之后不能有新的记录插入呢（防止幻读）？<br>答案是用间隙锁，在RR级别下，mysql通过间隙锁可以实现锁定number=5之前的间隙，number=5记录之间的间隙，number=5之后的间隙，从而使的新的记录无法被插入进来。</p>
<p>间隙是怎么划分的？</p>
<p>注：为了方面理解，我们规定（id=A,number=B）代表一条字段id=A,字段number=B的记录，（C，D）代表一个区间，代表C-D这个区间范围。</p>
<p>图一中，根据number列，我们可以分为几个区间：（无穷小，2），（2，4），（4，5），（5，5），（5,11），（11，无穷大）。<br>只要这些区间对应的两个临界记录中间可以插入记录，就认为区间对应的记录之间有间隙。<br>例如：区间（2，4）分别对应的临界记录是（id=1,number=2），（id=3，number=4），这两条记录中间可以插入（id=2,number=3）等记录，那么就认为（id=1,number=2）与（id=3，number=4）之间存在间隙。</p>
<p>很多人会问，那记录（id=6，number=5）与（id=8，number=5）之间有间隙吗？<br>答案是有的，（id=6，number=5）与（id=8，number=5）之间可以插入记录（id=7，number=5），因此（id=6,number=5）与（id=8,number=5）之间有间隙的，</p>
<p>间隙锁锁定的区域<br>根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。<br>图一中，where number=5的话，那么间隙锁的区间范围为（4,11）；</p>
<p>间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的：<br>（1）防止间隙内有新数据被插入<br>（2）防止已存在的数据，更新成间隙内的数据（例如防止numer=3的记录通过update变成number=5）</p>
<p>innodb自动使用间隙锁的条件：<br>（1）必须在RR级别下<br>（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</p>
<p>接下来，通过实际操作观察下间隙锁的作用范围</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-ad0d50c44dc041be.png" alt="image"></p>
<h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">4</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">2</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">5</span>);#（执行成功）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">5</span>);#（执行成功）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);#（执行成功）</span><br></pre></td></tr></table></figure>
<p>检索条件number=4,向左取得最靠近的值2作为左区间，向右取得最靠近的5作为右区间，因此，session 1的间隙锁的范围（2，4），（4，5），如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-b1ddc3677c81c9b5.png" alt="image"></p>
<p>间隙锁锁定的区间为（2，4），（4，5），即记录（id=1,number=2）和记录（id=3,number=4）之间间隙会被锁定，记录（id=3,number=4）和记录（id=6,number=5）之间间隙被锁定。</p>
<p>因此记录（id=2,number=4），（id=2,number=2），（id=4,number=4），（id=4,number=5）正好处在（id=3,number=4）和（id=6,number=5）之间，所以插入不了，需要等待锁的释放，而记录(id=7,number=5)，（id=9,number=5），（id=11,number=5）不在上述锁定的范围内，因此都会插入成功。</p>
<h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">13</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">11</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">14</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">15</span>,<span class="number">12</span>);#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">14</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">11</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(执行成功)</span><br></pre></td></tr></table></figure>
<p>检索条件number=13,向左取得最靠近的值11作为左区间，向右由于没有记录因此取得无穷大作为右区间，因此，session 1的间隙锁的范围（11，无穷大），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-1f499d02104728e0.png" alt="image"></p>
<p>此表中没有number=13的记录的，innodb依然会为该记录左右两侧加间隙锁，间隙锁的范围（11，无穷大）。</p>
<p>有人会问，为啥update news set id=14 where number=11会阻塞，但是update news set id=11 where number=11却执行成功呢？</p>
<p>间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，此图间隙锁锁定的区域是（11，无穷大），也就是记录（id=13,number=11）之后不能再插入记录，update news set id=14 where number=11这条语句如果执行的话，将会被插入到（id=13,number=11）的后面，也就是在区间（11，无穷大）之间，由于该区间被间隙锁锁定，所以只能阻塞等待，而update news set id=11 where number=11执行后是会被插入到（id=13,number=11）的记录前面，也就不在（11，无穷大）的范围内，所以无需等待，执行成功。</p>
<h4 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">5</span>,<span class="number">5</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">12</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> <span class="keyword">number</span>=<span class="number">5</span> <span class="keyword">where</span> id=<span class="number">1</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">11</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#（执行成功）</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">4</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#（阻塞）</span><br></pre></td></tr></table></figure>
<p>检索条件number=5,向左取得最靠近的值4作为左区间，向右取得11为右区间，因此，session 1的间隙锁的范围（4，5），（5，11），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-35dc3a0aed8a0f9a.png" alt="image"></p>
<p>有人会问，为啥<code>insert into news value(9,12)</code>会执行成功？间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，（id=9,number=12）很明显在记录（13,11）的后面，因此不再锁定的间隙范围内。</p>
<p>为啥u<code>pdate news set number=5 where id=1</code>会阻塞？<br>number=5的记录的前面，后面包括中间都被封锁了，你这个update news set number=5 where id=1根本没法执行，因为innodb已经把你可以存放的位置都锁定了，因为只能等待。</p>
<p>同理，<code>update news set id=11 where number=11</code>由于记录（id=10,number=5）与记录（id=13,number=11）中间的间隙被封锁了，你这句sql也没法执行，必须等待，因为存放的位置被封锁了。</p>
<h4 id="案例四"><a href="#案例四" class="headerlink" title="案例四"></a>案例四</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>&gt;<span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction;</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#(执行成功)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">4</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">5</span> ;#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">3</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="literal">null</span>,<span class="number">13</span>);#(阻塞)</span><br></pre></td></tr></table></figure>
<p>检索条件number&gt;4,向左取得最靠近的值4作为左区间，向右取无穷大，因此，session 1的间隙锁的范围（4，无穷大），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-3e7aaef9e3865926.png" alt="image"></p>
<p>session2中之所以有些阻塞，有些执行成功，其实就是因为插入的区域被锁定，从而阻塞。</p>
<p>next-key锁</p>
<p>next-key锁其实包含了记录锁和间隙锁，即锁定一个范围，并且锁定记录本身，InnoDB默认加锁方式是next-key 锁。<br>上面的案例一session 1中的sql是：select * from news where number=4 for update ;<br>next-key锁锁定的范围为间隙锁+记录锁，即区间（2，4），（4，5）加间隙锁，同时number=4的记录加记录锁。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>MySQL有三种锁的级别：页级、表级、行级。</p>
<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
<p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<p>算法：</p>
<p>next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap<br>Gap锁，不锁记录，仅仅记录前面的Gap</p>
<p>Recordlock锁（锁数据，不锁Gap）</p>
<p>所以其实 Next-KeyLocks=Gap锁+ Recordlock锁</p>
<h5 id="什么情况下会造成死锁"><a href="#什么情况下会造成死锁" class="headerlink" title="什么情况下会造成死锁"></a>什么情况下会造成死锁</h5><p>所谓死锁<code>&lt;DeadLock&gt;</code>: 是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</p>
<p>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。</p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p>
<h4 id="一些常见的死锁案例"><a href="#一些常见的死锁案例" class="headerlink" title="一些常见的死锁案例"></a>一些常见的死锁案例</h4><h5 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h5><p>需求：将投资的钱拆成几份随机分配给借款人。</p>
<p>起初业务程序思路是这样的：</p>
<p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条<code>select for update</code> 去更新借款人表里面的余额等。</p>
<p>抽象出来就是一个session通过for循环会有几条如下的语句：<br><code>Select * from xxx where id=&#39;随机id&#39; for update</code></p>
<p>基本来说，程序开启后不一会就死锁。<br>这可以是说最经典的死锁情形了。</p>
<p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2<br>B用户金额随机分为2份，分给借款人2，1由于加锁的顺序不一样，死锁当然很快就出现了。</p>
<p>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</p>
<p><code>Select * from xxx where id in (xx,xx,xx) for update</code></p>
<p>在in里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">例如（以下会话<span class="built_in">id</span>为主键）：</span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (<span class="number">8</span>,<span class="number">9</span>) <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">|  <span class="number">8</span> | WA     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-02</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">|  <span class="number">9</span> | JX     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-01</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">8</span>,<span class="number">5</span>) <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中……</span><br><span class="line"></span><br><span class="line">其实这个时候<span class="built_in">id</span>=<span class="number">10</span>这条记录没有被锁住的，但<span class="built_in">id</span>=<span class="number">5</span>的记录已经被锁住了，锁的等待在<span class="built_in">id</span>=<span class="number">8</span>的这里。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">不信请看</span><br><span class="line"></span><br><span class="line">Session3:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">5</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session4:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="number">10</span> | JB     | g    | <span class="number">2016</span><span class="number">-03</span><span class="number">-10</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">05</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">在其它session中<span class="built_in">id</span>=<span class="number">5</span>是加不了锁的，但是<span class="built_in">id</span>=<span class="number">10</span>是可以加上锁的。</span><br></pre></td></tr></table></figure></p>
<h5 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h5><p>在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">以id为主键为例，目前还没有id=22的行</span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">22</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">session2:</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">23</span>  <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">values</span>(<span class="number">22</span>,<span class="string">'ac'</span>,<span class="string">'a'</span>,<span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line">锁等待中……</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">values</span>(<span class="number">23</span>,<span class="string">'bc'</span>,<span class="string">'b'</span>,<span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get <span class="keyword">lock</span>; try restarting transaction</span><br></pre></td></tr></table></figure>
<p>当对存在的行进行锁的时候(主键)，mysql就只有行锁。</p>
<p>当对未存在的行进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有gap锁）</p>
<p>锁住的范围为：</p>
<p>(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</p>
<p>如：如果表中目前有已有的id为（11 ， 12）</p>
<p>那么就锁住（12，无穷大）</p>
<p>如果表中目前已有的id为（11 ， 30）</p>
<p>那么就锁住（11，30）</p>
<p>对于这种死锁的解决办法是：</p>
<p><code>insert into t3(xx,xx) on duplicate key update `xx`=&#39;XX&#39;;</code></p>
<p>用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</p>
<h5 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">9</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">|  <span class="number">9</span> | JX     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-01</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>&lt;<span class="number">20</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line">mysql&gt; insert <span class="keyword">into</span> t3 values(<span class="number">7</span>,'ae','a',now());</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found when trying <span class="keyword">to</span> <span class="keyword">get</span> lock; <span class="keyword">try</span> restarting <span class="keyword">transaction</span></span><br></pre></td></tr></table></figure>
<p>这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</p>
<p>Session2在等待Session1的id=9的锁，session2又持了1到8的锁（注意9到19的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</p>
<p>这种一般是在业务需求中基本不会出现，因为你锁住了id=9，却又想插入id=7的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</p>
<h2 id="有两个表，table-a，table-b，写SQL查询出仅在table-a中的数据、仅在table-b中的数据、既在table-a-又在table-b-中的数据？"><a href="#有两个表，table-a，table-b，写SQL查询出仅在table-a中的数据、仅在table-b中的数据、既在table-a-又在table-b-中的数据？" class="headerlink" title="有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？"></a>有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/05/18/面试分享(二).框架相关(Spring)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/面试分享(二).框架相关(Spring)/" itemprop="url">面试分享(二).框架相关(Spring)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T18:33:00+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/18/面试分享(二).框架相关(Spring)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/05/18/面试分享(二).框架相关(Spring)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="框架相关（Spring）"><a href="#框架相关（Spring）" class="headerlink" title="框架相关（Spring）"></a>框架相关（Spring）</h1><h2 id="Spring源码看过没有，会多少讲多少？"><a href="#Spring源码看过没有，会多少讲多少？" class="headerlink" title="Spring源码看过没有，会多少讲多少？"></a>Spring源码看过没有，会多少讲多少？</h2><p>灵魂问题，，，自己发挥</p>
<h3 id="各个组件"><a href="#各个组件" class="headerlink" title="各个组件"></a>各个组件</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>是对资源的抽象，每一个接口实现类都代表了一种资源类型，如 ClasspathResource 、 URLResource ， FileSystemResource 等。每一个资源类型都封装了对某一种特定资源的访问策略。它是 spring 资源访问策略的一个基础实现，应用在很多场景。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/ead09fcb-3c6c-3740-9e36-6de33fd65cca.jpg" alt="image"></p>
<h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>用来抽象和描述一个具体 bean 对象。是描述一个 bean 对象的基本数据结构。</p>
<h4 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h4><p>BeanDefinitionReader 将外部资源对象描述的 bean 定义统一转化为统一的内部数据结构 BeanDefinition 。对应不同的描述需要有不同的 Reader 。如 XmlBeanDefinitionReader 用来读取 xml 描述配置的 bean 对象。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c4143d16-02e2-3d7b-9734-4d19a9a984dd.jpg" alt="image"></p>
<h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>用来定义一个很纯粹的 bean 容器。它是一个 bean 容器的必备结构。同时和外部应用环境等隔离。 BeanDefinition 是它的基本数据结构。它维护一个 BeanDefinitions Map, 并可根据 BeanDefinition 的描述进行 bean 的创建和管理。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/24095923-75cd-363b-bc2f-9fbc603c341f.jpg" alt="image"></p>
<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>从名字来看叫应用上下文，是和应用环境息息相关的。没错这个就是我们平时开发中经常直接使用打交道的一个类，应用上下文，或者也叫做 spring 容器。其实它的基本实现是会持有一个 BeanFactory 对象，并基于此提供一些包装和功能扩展。为什么要这么做呢？因为 BeanFactory 实现了一个容器基本结构和功能，但是与外部环境隔离。那么读取配置文件，并将配置文件解析成 BeanDefinition ，然后注册到 BeanFactory 的这一个过程的封装自然就需要 ApplicationContext 。 ApplicationContext 和应用环境细细相关，常见实现有 <code>ClasspathXmlApplicationContext</code>,<code>FileSystemXmlApplicationContext</code>,<code>WebApplicationContext</code> 等。 Classpath 、 xml 、 FileSystem 、 Web 等词都代表了应用和环境相关的一些意思，从字面上不难理解各自代表的含义。</p>
<p>当然 ApplicationContext 和 BeanFactory 的区别远不止于此，有：</p>
<ol>
<li><p>资源访问功能：在 Resource 和 ResourceLoader 的基础上可以灵活的访问不同的资源。</p>
</li>
<li><p>支持不同的信息源。</p>
</li>
<li><p>支持应用事件：继承了接口 ApplicationEventPublisher ，这样在上下文中为 bean 之间提供了事件机制。</p>
</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c456f949-7b9c-34db-ad1a-ca3141219b6d.jpg" alt="image"></p>
<p>以上 5 个组件基本代表了 ioc 容器的一个最基本组成，而组件的组合是放在 ApplicationContext 的实现这一层来完成。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/d9a0e8c8-29d6-36a3-888e-e22c2d1bb44f.jpg" alt="image"><br>左边黄色部分是 ApplicationContext 体系继承结构，右边是 BeanFactory 的结构体系,两个结构是典型模板方法设计模式的使用。</p>
<p>从该继承体系可以看出：</p>
<ol>
<li><p>BeanFactory 是一个 bean 工厂的最基本定义，里面包含了一个 bean 工厂的几个最基本的方法， getBean(…) 、 containsBean(…) 等 ,是一个很纯粹的bean工厂，不关注资源、资源位置、事件等。 ApplicationContext 是一个容器的最基本接口定义，它继承了 BeanFactory, 拥有工厂的基本方法。同时继承了 ApplicationEventPublisher 、 MessageSource 、 ResourcePatternResolver 等接口，使其 定义了一些额外的功能，如资源、事件等这些额外的功能。</p>
</li>
<li><p>AbstractBeanFactory 和 AbstractAutowireCapableBeanFactory 是两个模板抽象工厂类。 AbstractBeanFactory 提供了 bean 工厂的抽象基类，同时提供了 ConfigurableBeanFactory 的完整实现。 AbstractAutowireCapableBeanFactory 是继承了 AbstractBeanFactory 的抽象工厂，里面提供了 bean 创建的支持，包括 bean 的创建、依赖注入、检查等等功能，是一个核心的 bean 工厂基类。</p>
</li>
<li><p>ClassPathXmlApplicationContext之 所以拥有 bean 工厂的功能是通过持有一个真正的 bean 工厂 DefaultListableBeanFactory 的实例，并通过 代理 该工厂完成。</p>
</li>
<li><p>ClassPathXmlApplicationContext 的初始化过程是对本身容器的初始化同时也是对其持有的 DefaultListableBeanFactory 的初始化。</p>
</li>
</ol>
<h3 id="容器初始化过程"><a href="#容器初始化过程" class="headerlink" title="容器初始化过程"></a>容器初始化过程</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/370101b5-b3d1-3b79-b9b2-3bba91d092d7.jpg" alt="image"><br>整个过程可以理解为是容器的初始化过程。第一个过程是 ApplicationContext 的职责范围，第二步是 BeanFactory 的职责范围。可以看出 ApplicationContext 是一个运行时的容器需要提供不容资源环境的支持，屏蔽不同环境的差异化。而 BeanDifinition 是内部关于 bean 定义的基本结构。 Bean 的创建就是基于它，回头会介绍一下改结构的定义。下面看一下整个容器的初始化过程。</p>
<p>容器的初始化是通过调用 refresh() 来实现。该方法是非常重要的一个方法，定义在 AbstractApplicationContext 接口里。 AbstractApplicationContext 是容器的最基础的一个抽象父类。也就是说在该里面定义了一个容器初始化的基本流程，流程里的各个方法有些有提供了具体实现，有些是抽象的 ( 因为不同的容器实例不一样 ) ，由继承它的每一个具体容器完成定制。看看 refresh 的基本流程：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;  </span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.  </span></span><br><span class="line">        prepareRefresh();  </span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.  </span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  </span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.  </span></span><br><span class="line">        prepareBeanFactory(beanFactory);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.  </span></span><br><span class="line">            postProcessBeanFactory(beanFactory);  </span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.  </span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.  </span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);  </span><br><span class="line">            <span class="comment">// Initialize message source for this context.  </span></span><br><span class="line">            initMessageSource();  </span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.  </span></span><br><span class="line">            initApplicationEventMulticaster();  </span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.  </span></span><br><span class="line">            onRefresh();  </span><br><span class="line">            <span class="comment">// Check for listener beans and register them.  </span></span><br><span class="line">            registerListeners();  </span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.  </span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.  </span></span><br><span class="line">            finishRefresh();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.  </span></span><br><span class="line">            beanFactory.destroySingletons();  </span><br><span class="line">            <span class="comment">// Reset 'active' flag.  </span></span><br><span class="line">            cancelRefresh(ex);  </span><br><span class="line">            <span class="comment">// Propagate exception to caller.  </span></span><br><span class="line">            <span class="keyword">throw</span> ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2187e288-5c0b-313b-8053-82992267fab6.jpg" alt="image"></p>
<h3 id="Bean-的创建过程"><a href="#Bean-的创建过程" class="headerlink" title="Bean 的创建过程"></a>Bean 的创建过程</h3><p>Bean的创建过程基本是BeanFactory所要完成的事情.</p>
<p>根据以上过程，将会重点带着以下两个个问题来理解核心代码：</p>
<p>1.Bean 的创建时机</p>
<p>bean 是在什么时候被创建的，有哪些规则。</p>
<p>2.Bean 的创建过程</p>
<p>bean 是怎么创建的，会选择哪个构造函数？依赖如何注入？ InitializingBean 的 set 方法什么时候被调用？实现 ApplicationContextAware, BeanFactoryAware,BeanNameAware, ResourceLoaderAware 这些接口的 bean 的 set 方法何时被调用？</p>
<p>在解释这两个问题前，先看一下 BeanDefinition 接口的定义。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2beb44aa-4b38-3d87-a444-308d8f380e87.jpg" alt="image"></p>
<p>从该接口定义可以看出，通过 bean 定义能够得到 bean 的详细信息，如类名子、工厂类名称、 scope 、是否单例、是否抽象、是否延迟加载等等。基于此，来看一下以下两个问题：</p>
<h4 id="问题-1-：-Bean-的创建时机"><a href="#问题-1-：-Bean-的创建时机" class="headerlink" title="问题 1 ： Bean 的创建时机"></a>问题 1 ： Bean 的创建时机</h4><p>bean 是在什么时候被创建的，有哪些规则？</p>
<p>容器初始化的时候会预先对单例和非延迟加载的对象进行预先初始化。其他的都是延迟加载是在第一次调用 getBean 的时候被创建。从 DefaultListableBeanFactory 的 preInstantiateSingletons 里可以看到这个规则的实现。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> void preInstantiateSingletons() throws <span class="keyword">BeansException </span>&#123;  </span><br><span class="line">    <span class="meta">if</span> (this.logger.isInfoEnabled()) &#123;  </span><br><span class="line">        this.logger.info(<span class="string">"Pre-instantiating singletons in "</span> + this)<span class="comment">;  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    synchronized (this.<span class="keyword">beanDefinitionMap) </span>&#123;  </span><br><span class="line">        for (<span class="keyword">Iterator </span><span class="keyword">it </span>= this.<span class="keyword">beanDefinitionNames.iterator(); </span><span class="keyword">it.hasNext();) </span>&#123;  </span><br><span class="line">            <span class="keyword">String </span><span class="keyword">beanName </span>= (<span class="keyword">String) </span><span class="keyword">it.next(); </span> </span><br><span class="line">            RootBeanDefinition <span class="keyword">bd </span>= getMergedLocalBeanDefinition(<span class="keyword">beanName); </span> </span><br><span class="line">            <span class="meta">if</span> (!<span class="keyword">bd.isAbstract() </span>&amp;&amp; <span class="keyword">bd.isSingleton() </span>&amp;&amp; !<span class="keyword">bd.isLazyInit()) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对非抽象、单例的和非延迟加载的对象进行实例化。  </span><br><span class="line">                <span class="meta">if</span> (isFactoryBean(<span class="keyword">beanName)) </span>&#123;  </span><br><span class="line">                    FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + <span class="keyword">beanName); </span> </span><br><span class="line">                    <span class="meta">if</span> (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean) factory).isEagerInit()) &#123;  </span><br><span class="line">                        getBean(<span class="keyword">beanName); </span> </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="meta">else</span> &#123;  </span><br><span class="line">                    getBean(<span class="keyword">beanName); </span> </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面来看对于以下配置，只有 singletonBean 会被预先创建。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"GB2312"</span><span class="meta">?&gt;</span></span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"otherBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.OtherBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.MyBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.SingletonBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="问题二：Bean-的创建过程"><a href="#问题二：Bean-的创建过程" class="headerlink" title="问题二：Bean 的创建过程"></a>问题二：Bean 的创建过程</h4><p>对于 bean 的创建过程其实都是通过调用工厂的 getBean 方法来完成的。这里面将会完成对构造函数的选择、依赖注入等。</p>
<p>无论预先创建还是延迟加载都是调用getBean实现，AbstractBeanFactory 定义了 getBean 的过程：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doGetBean(  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> name, <span class="keyword">final</span> Class requiredType, <span class="keyword">final</span> <span class="keyword">Object</span>[] args, <span class="built_in">boolean</span> typeCheckOnly) <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> beanName = transformedBeanName(name);  </span><br><span class="line">    <span class="keyword">Object</span> bean = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.  </span></span><br><span class="line">    <span class="keyword">Object</span> sharedInstance = getSingleton(beanName);  </span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +  </span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance:  </span></span><br><span class="line">        <span class="comment">// We're assumably within a circular reference.  </span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.  </span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();  </span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;  </span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.  </span></span><br><span class="line">            <span class="keyword">String</span> nameToLookup = originalBeanName(name);  </span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.  </span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, args);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.  </span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;  </span><br><span class="line">            markBeanAsCreated(beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);  </span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guarantee initialization of beans that the current bean depends on.  </span></span><br><span class="line">        <span class="keyword">String</span>[] dependsOn = mbd.getDependsOn();  </span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependsOn.length; i++) &#123;  </span><br><span class="line">                <span class="keyword">String</span> dependsOnBean = dependsOn[i];  </span><br><span class="line">                getBean(dependsOnBean);  </span><br><span class="line">                registerDependentBean(dependsOnBean, beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// Create bean instance.  </span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;<span class="comment">//单例对象创建过程,间接通过getSingleton方法来创建，里面会实现将单例对象缓存 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there  </span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.  </span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.  </span></span><br><span class="line">                        destroySingleton(beanName);  </span><br><span class="line">                        <span class="keyword">throw</span> ex;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;<span class="comment">//非单例对象创建</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.  </span></span><br><span class="line">            <span class="keyword">Object</span> prototypeInstance = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                beforePrototypeCreation(beanName);  </span><br><span class="line">                prototypeInstance = createBean(beanName, mbd, args);<span class="comment">//直接调用createBean</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">finally</span> &#123;  </span><br><span class="line">                afterPrototypeCreation(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">String</span> scopeName = mbd.getScope();  </span><br><span class="line">            <span class="keyword">final</span> Scope scope = (Scope) <span class="keyword">this</span>.scopes.<span class="built_in">get</span>(scopeName);  </span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope '"</span> + scopeName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">Object</span> scopedInstance = scope.<span class="built_in">get</span>(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                        beforePrototypeCreation(beanName);  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">finally</span> &#123;  </span><br><span class="line">                            afterPrototypeCreation(beanName);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,  </span><br><span class="line">                        <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; "</span> +  </span><br><span class="line">                        <span class="string">"consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,  </span><br><span class="line">                        ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.  </span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> bean;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GetBean 的大概过程：</p>
<p>1.先试着从单例缓存对象里获取。</p>
<p>2.从父容器里取定义，有则由父容器创建。</p>
<p>3.如果是单例，则走单例对象的创建过程：在 spring 容器里单例对象和非单例对象的创建过程是一样的。都会调用父类 AbstractAutowireCapableBeanFactory 的 createBean 方法。 不同的是单例对象只创建一次并且需要缓存起来。 DefaultListableBeanFactory 的父类 DefaultSingletonBeanRegistry 提供了对单例对象缓存等支持工作。所以是单例对象的话会调用 DefaultSingletonBeanRegistry 的 getSingleton 方法，它会间接调用 AbstractAutowireCapableBeanFactory 的 createBean 方法。</p>
<p>如果是 Prototype 多例则直接调用父类 AbstractAutowireCapableBeanFactory 的 createBean 方法。</p>
<p>bean的创建是由AbstractAutowireCapableBeanFactory来定义：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> createBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="keyword">Object</span>[] args)  </span><br><span class="line">            <span class="keyword">throws</span> BeanCreationException &#123;  </span><br><span class="line">    AccessControlContext acc = AccessController.getContext();  </span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Object</span> run() &#123;  </span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// Make sure bean class is actually resolved at this point.  </span></span><br><span class="line">            resolveBeanClass(mbd, beanName);  </span><br><span class="line">            <span class="comment">// Prepare method overrides.  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                mbd.prepareMethodOverrides();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(),  </span><br><span class="line">                        beanName, <span class="string">"Validation of method overrides failed"</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.  </span></span><br><span class="line">                <span class="keyword">Object</span> bean = resolveBeforeInstantiation(beanName, mbd);  </span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> bean;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,  </span><br><span class="line">                        <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">Object</span> beanInstance = doCreateBean(beanName, mbd, args);  </span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> beanInstance;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;, acc);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>createBean 会调用 doCreateBean 方法：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doCreateBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="keyword">Object</span>[] args) &#123;  </span><br><span class="line">    <span class="comment">// Instantiate the bean.  </span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;  </span><br><span class="line">        instanceWrapper = (BeanWrapper) <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Object</span> bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);  </span><br><span class="line">    Class beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.  </span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;  </span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);  </span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references  </span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.  </span></span><br><span class="line">    <span class="built_in">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;  </span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));  </span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +  </span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Initialize the bean instance.  </span></span><br><span class="line">    <span class="keyword">Object</span> exposedObject = bean;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);  </span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;  </span><br><span class="line">        <span class="keyword">Object</span> earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);  </span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;  </span><br><span class="line">                exposedObject = earlySingletonReference;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;  </span><br><span class="line">                <span class="keyword">String</span>[] dependentBeans = getDependentBeans(beanName);  </span><br><span class="line">                Set actualDependentBeans = <span class="keyword">new</span> LinkedHashSet(dependentBeans.length);  </span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependentBeans.length; i++) &#123;  </span><br><span class="line">                    <span class="keyword">String</span> dependentBean = dependentBeans[i];  </span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;                         actualDependentBeans.<span class="built_in">add</span>(dependentBean);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,  </span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +  </span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +  </span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +  </span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +  </span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +  </span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Register bean as disposable.  </span></span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);  </span><br><span class="line">    <span class="keyword">return</span> exposedObject;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>doCreateBean 的流程：</p>
<p>1.会创建一个 BeanWrapper 对象 用于存放实例化对象。</p>
<p>2.如果没有指定构造函数，会通过反射拿到一个默认的构造函数对象，并赋予 beanDefinition.resolvedConstructorOrFactoryMethod 。</p>
<p>3.调用 spring 的 BeanUtils 的 instantiateClass 方法，通过反射创建对象。</p>
<p>4.applyMergedBeanDefinitionPostProcessors</p>
<p>5.populateBean(beanName, mbd, instanceWrapper); 根据注入方式进行注入。根据是否有依赖检查进行依赖检查。</p>
<p>执行 bean 的注入里面会选择注入类型：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||  </span><br><span class="line">                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">    MutablePropertyValues <span class="keyword">new</span><span class="type">Pvs</span> = <span class="keyword">new</span> <span class="type">MutablePropertyValues</span>(pvs);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add property values based on autowire by name if applicable.  </span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;  </span><br><span class="line">        autowireByName(beanName, mbd, bw, <span class="keyword">new</span><span class="type">Pvs</span>);  </span><br><span class="line">    &#125;<span class="comment">//根据名字注入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add property values based on autowire by type if applicable.  </span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">        autowireByType(beanName, mbd, bw, <span class="keyword">new</span><span class="type">Pvs</span>);  </span><br><span class="line">    &#125;<span class="comment">//根据类型注入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pvs = <span class="keyword">new</span><span class="type">Pvs</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.initializeBean(beanName, exposedObject, mbd);</p>
<p>判断是否实现了 BeanNameAware 、 BeanClassLoaderAware 等 spring 提供的接口，如果实现了，进行默认的注入。同时判断是否实现了 InitializingBean 接口，如果是的话，调用 afterPropertySet 方法。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">protected</span> Object initializeBean(<span class="keyword">String </span><span class="keyword">beanName, </span>Object <span class="keyword">bean, </span>RootBeanDefinition mbd) &#123;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanNameAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanNameAware) </span><span class="keyword">bean).setBeanName(beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanClassLoaderAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanClassLoaderAware) </span><span class="keyword">bean).setBeanClassLoader(getBeanClassLoader()); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanFactoryAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanFactoryAware) </span><span class="keyword">bean).setBeanFactory(this); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    Object wrappedBean = <span class="keyword">bean; </span> </span><br><span class="line">    <span class="meta">if</span> (mbd == null <span class="title">||</span> !mbd.isSynthetic()) &#123;  </span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, <span class="keyword">beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        invokeInitMethods(<span class="keyword">beanName, </span>wrappedBean, mbd)<span class="comment">;  </span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    catch (Throwable ex) &#123;  </span><br><span class="line">        throw new <span class="keyword">BeanCreationException( </span> </span><br><span class="line">                (mbd != null ? mbd.getResourceDescription() : null),  </span><br><span class="line">                <span class="keyword">beanName, </span><span class="string">"Invocation of init method failed"</span>, ex)<span class="comment">;  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (mbd == null <span class="title">||</span> !mbd.isSynthetic()) &#123;  </span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, <span class="keyword">beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    return wrappedBean<span class="comment">;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中invokeInitMethods实现如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> invokeInitMethods(<span class="keyword">String</span> beanName, <span class="keyword">Object</span> bean, RootBeanDefinition mbd)  </span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);  </span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        ((InitializingBean) bean).afterPropertiesSet();<span class="comment">//调用afterPropertiesSet方法  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">String</span> initMethodName = (mbd != <span class="keyword">null</span> ? mbd.getInitMethodName() : <span class="keyword">null</span>);  </span><br><span class="line">    <span class="keyword">if</span> (initMethodName != <span class="keyword">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;  </span><br><span class="line">            !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;  </span><br><span class="line">        invokeCustomInitMethod(beanName, bean, initMethodName, mbd.isEnforceInitMethod());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring-xml-ioc-容器常用标签和自定义标签"><a href="#Spring-xml-ioc-容器常用标签和自定义标签" class="headerlink" title="Spring  xml ioc 容器常用标签和自定义标签"></a>Spring  xml ioc 容器常用标签和自定义标签</h3><p>以 Xml 资源定义的容器配置是我们最常见的一种方式。</p>
<p>Spring 容器需要解析 xml 的标签，并把 xml 里 bean 的定义转化为内部的结构 BeanDifinition 。</p>
<p>Spring 的标签有很多种，其支持的常见的标签有：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;bean&gt;</code></td>
<td>最常用的，定义一个普通 bean。</td>
<td><code>&lt;bean id=&quot;myBean&quot;          class=&quot;com.test.MyBean&quot; lazy-init=&quot;true&quot;/&gt;</code></td>
</tr>
<tr>
<td><code>&lt;tx&gt;</code></td>
<td>如<code>&lt;tx: advice&gt;</code> 等,提供事务配置通用支持。</td>
<td><code>&lt;tx:advice id=&quot;txAdvice&quot;transaction-manager=&quot;transactionManager&quot;&gt;  &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot;/&gt;  &lt;tx:method name=&quot;remove*&quot;/&gt;   &lt;tx:method name=&quot;*&quot; read-only=&quot;true&quot;/&gt;  &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;</code></td>
</tr>
<tr>
<td><code>&lt;aop&gt;</code></td>
<td><code>&lt;aop:config&gt;</code>,<code>&lt;aop: aspectj-autoproxy&gt;</code> 等提供代理 bean 通用配置支持。</td>
<td><code>&lt;aop:configproxy-target-class=&quot;true&quot;&gt;  &lt;aop:advisor pointcut=&quot;...&quot; advice-ref=&quot;txAdvice&quot;/&gt; &lt;aop:advisorpointcut=&quot;...&quot; advice-ref=&quot;fooAdvice&quot;/&gt;   &lt;/aop:config&gt;</code></td>
</tr>
<tr>
<td><code>&lt;util&gt;</code></td>
<td>提供在容器内配置一些JDK自带的工具类、集合类和常量的支持。</td>
<td><code>&lt;util:list id=&quot;list&quot;list-class=&quot;java.util.ArrayList&quot;&gt;&lt;value&gt;listValue1&lt;/value&gt;   &lt;value&gt;listValue2&lt;/value&gt;  &lt;/util:list&gt;  &lt;util:map id=&quot;map&quot;&gt;  &lt;entry key=&quot;key1&quot;  value=&quot;mapValue1&quot;&gt;&lt;/entry&gt;&lt;entry key=&quot;key12&quot; value=&quot;mapValue2&quot;&gt;&lt;/entry&gt;  &lt;/util:map&gt;</code></td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>属性的简单访问。</td>
<td><code>&lt;bean id=&quot;loginAction&quot; class=&quot;com.test.LoginAction&quot; p:name=&quot;test&quot;&gt;&lt;/bean&gt;</code></td>
</tr>
<tr>
<td><code>&lt;lang&gt;</code></td>
<td><code>&lt;lang:groovy&gt; &lt;lang:jruby&gt;</code>等，提供对动态脚本的支持。</td>
<td><code>&lt;lang:groovy id=&quot;test&quot;  refresh-check-delay=&quot;5000&quot; script-source=&quot;classpath:com/test/groovy/test.groovy&quot;&gt;  &lt;/lang:groovy&gt;</code></td>
</tr>
<tr>
<td><code>&lt;jee&gt;</code></td>
<td><code>&lt;jee:jndi-lookup/&gt;</code>等，对一些javaEE规范的bean配置的简化，如jndi等。</td>
<td><code>&lt;jee:jndi-lookup id=&quot;simple&quot; jndi-name=&quot;jdbc/MyDataSource&quot;    cache=&quot;true&quot;  resource-ref=&quot;true&quot;    lookup-on-startup=&quot;false&quot; expected-type=&quot;com.myapp.DefaultFoo&quot;     proxy-interface=&quot;com.myapp.Foo&quot;/&gt;</code></td>
</tr>
</tbody>
</table>
<p>基本上每一种标签都是用来定义一类 bean 的（P标签除外）。以上都是 spring 自带的一些标签，当然 spring 也支持自定义标签。其实 <code>&lt;tx&gt;&lt;aop&gt;</code> 这些也可以认为是自定义标签，不过是由 spring 扩展的而已。</p>
<p>其实所有的bean定义都可以用bean标签来实现定义的。而衍生这种自定义标签来定义 bean 有几个好处：</p>
<ol>
<li><p>见名知意。</p>
</li>
<li><p>对于同一类的通用 bean。封装不必要的配置，只给外部暴露一个简单易用的标签和一些需要配置的属性。很多时候对于一个框架通用的 bean ，我们不需要把 bean 的所有配置都暴露出来，甚至像类名、默认值等我们都想直接封装，这个时候就可以使用自定义标签了，如： &lt;services:property-placeholder /&gt; 可能这个标签就默认代表配置了一个支持 property placeholder 的通用 bean ，我们都不需要去知道配这样一个 bean 的类路径是什么。</p>
</li>
</ol>
<p>可以说自定义标签是 spring 的 xml 容器的一个扩展点，本身 spring 自己的很多标签也是基于这个设计上面来构造出来的。</p>
<h3 id="Spring-对于自定义（声明式）bean标签解析如何设计"><a href="#Spring-对于自定义（声明式）bean标签解析如何设计" class="headerlink" title="Spring 对于自定义（声明式）bean标签解析如何设计"></a>Spring 对于自定义（声明式）bean标签解析如何设计</h3><p>Bean 的定义方式有千千万万种，无论是何种标签，无论是何种资源定义，无论是何种容器，最终的 bean 定义内部表示都将转换为内部的唯一结构： BeanDefinition 。外部的各种定义说白了就是为了方便配置。</p>
<p>Spring 提供对其支持的标签解析的天然支持。所以只要按照 spring 的规范编写 xml 配置文件。所有的配置，在启动时都会正常的被解析成 BeanDefinition 。但是如果我们要实现一个自定义标签，则需要提供对自定义标签的全套支持。</p>
<p>我们知道要去完成一个自定义标签，需要完成的事情有：</p>
<ol>
<li><p>编写自定义标签 schema 定义文件，放在某个 classpath 下。</p>
</li>
<li><p>在 classpath 的在 META-INF 下面增加 spring.schemas 配置文件，指定 schema 虚拟路径和实际 xsd 的映射。我们在 xml 里的都是虚拟路径，如：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">            "</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"otherBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.OtherBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.MyBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.SingletonBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>头部的<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans http:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans<span class="regexp">/spring-beans-2.5.xsd</span></span><br></pre></td></tr></table></figure></p>
<p> 就是一个虚拟路径，其对应的真实路径在spring jar包里的META-INF/spring.schemas里面有映射到classpath定义：<br> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans<span class="regexp">/spring-beans-2.5.xsd=org/</span>springframework<span class="regexp">/beans/</span>factory<span class="regexp">/xml/</span>spring-beans-<span class="number">2.5</span>.xsd</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>增加一个 NamespaceHandler 和 BeanDefinitionParser ，用于解析自定义的标签，将自定义标签的 bean 解析成一个 BeanDefinition 返回。</li>
</ol>
<ol start="4">
<li><p>在 classpath 的在 META-INF 下面增加 spring.handlers 配置文件，指定标签命名空间和 handlers 的映射。</p>
<p>为什么要做以上几个事情？我们来看看设计：</p>
</li>
</ol>
<p>Spring 对标签解析的设计的过程如下：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/a2d7e37b-e394-3f90-bf20-7f480db1dc5d.jpg" alt="image"></p>
<p>解释：</p>
<p>Step 1： 将 xml 文件解析成 Dom 树。将 xml 文件解析成 dom 树的时候，需要 xml 标签定义 schema 来验证文件的语法结构。 Spring 约定将所有的 shema 的虚拟路径和真是文件路径映射定义在 classpath 的在 META-INF/spring.schemas 下面。在容器启动时 Spring 会扫描所有的 META-INF/spring.schemas 并将映射维护到一个 map 里。</p>
<p>如 spring jar 包里会有自带的标签的 schemas 映射，可以看一下部分配置：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/aop/spring-aop-<span class="number">2.0</span>.xsd  =  org/springframework/aop/config/spring-aop-<span class="number">2.0</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/aop/spring-aop-<span class="number">2.5</span>.xsd  =  org/springframework/aop/config/spring-aop-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/aop/spring-aop.xsd  =  org/springframework/aop/config/spring-aop-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/beans/spring-beans-<span class="number">2.0</span>.xsd  =  org/springframework/beans/factory/xml/spring-beans-<span class="number">2.0</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/beans/spring-beans-<span class="number">2.5</span>.xsd  =  org/springframework/beans/factory/xml/spring-beans-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/beans/spring-beans.xsd  =  org/springframework/beans/factory/xml/spring-beans-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/context/spring-context-<span class="number">2.5</span>.xsd  =  org/springframework/context/config/spring-context-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/context/spring-context.xsd  =  org/springframework/context/config/spring-context-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jee/spring-jee-<span class="number">2.0</span>.xsd  =  org/springframework/ejb/config/spring-jee-<span class="number">2.0</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jee/spring-jee-<span class="number">2.5</span>.xsd  =  org/springframework/ejb/config/spring-jee-<span class="number">2.5</span>.xsd  </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>等号左边是虚拟路径，右边是真是路径(classpath下的)。<br>虚拟路径用在我们的bean定义配置文件里，如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans <span class="attribute">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">    xmlns:<span class="attribute">xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:<span class="attribute">context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">    xmlns:<span class="attribute">p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>  </span><br><span class="line">    xsi:<span class="attribute">schemaLocation</span>=<span class="string">"  </span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&gt;  </span></span><br><span class="line"><span class="string">&lt;bean&gt;  </span></span><br><span class="line"><span class="string">&lt;/beans&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>beans里面的<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans http:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans<span class="regexp">/spring-beans-2.5.xsd</span></span><br></pre></td></tr></table></figure></p>
<p>就是个虚拟路径。</p>
<p>Step 2： 将 dom 树解析成 BeanDifinition 。将定义 bean 的标签和 xml 定义解析成 BeanDefinition 的过程。如果是默认的 bean 标签， spring 会直接进行解析。而如果不是默认的 bean 标签，包括自定义和 spring 扩展的 <code>&lt;aop&gt;</code>、 <code>&lt;p&gt;</code>、 <code>&lt;util&gt;</code> 等标签，则需要提供专门的 xmlparser 来处理。 paorser由自己定义和编写，并通过handler注册到容器。Spring 约定了 META-INF/spring.handlers 文件，在这里面定义了标签命名空间和 handler 的映射。容器起来的时候会加载 handler ， handler 会向容器注册该命名空间下的标签和解析器。在解析的自定义标签的时候， spring 会根据标签的命名空间和标签名找到一个解析器。由该解析器来完成对该标签内容的解析，并返回一个 BeanDefinition 。</p>
<p>以下是 spring jar 包自带的一些自定义标签扩展的 spring.handlers 文件，可以看到定义了 aop\p 等其扩展标签的 handlers 。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jms=org.springframework.jms.config.JmsNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/tx=org.springframework.transaction.config.TxNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</span><br></pre></td></tr></table></figure></p>
<p>看看UtilNamespaceHandler的代码实现<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void init() &#123;  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"constant"</span>, <span class="keyword">new</span> <span class="type">ConstantBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"property-path"</span>, <span class="keyword">new</span> <span class="type">PropertyPathBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"list"</span>, <span class="keyword">new</span> <span class="type">ListBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"set"</span>, <span class="keyword">new</span> <span class="type">SetBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"map"</span>, <span class="keyword">new</span> <span class="type">MapBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"properties"</span>, <span class="keyword">new</span> <span class="type">PropertiesBeanDefinitionParser</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现了标签和对应parser的映射注册。</p>
<p>ListBeanDefinitionParser的实现如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">ListBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Class</span> getBeanClass(<span class="type">Element</span> element) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="type">ListFactoryBean</span>.<span class="keyword">class</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> void doParse(<span class="type">Element</span> element, <span class="type">ParserContext</span> parserContext, <span class="type">BeanDefinitionBuilder</span> builder) &#123;  </span><br><span class="line">        <span class="type">String</span> listClass = element.getAttribute(<span class="string">"list-class"</span>);  </span><br><span class="line">        <span class="type">List</span> parsedList = parserContext.getDelegate().parseListElement(element, builder.getRawBeanDefinition());  </span><br><span class="line">        builder.addPropertyValue(<span class="string">"sourceList"</span>, parsedList);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="type">StringUtils</span>.hasText(listClass)) &#123;  </span><br><span class="line">            builder.addPropertyValue(<span class="string">"targetListClass"</span>, listClass);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">String</span> scope = element.getAttribute(<span class="type">SCOPE_ATTRIBUTE</span>);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="type">StringUtils</span>.hasLength(scope)) &#123;  </span><br><span class="line">            builder.setScope(scope);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里父类代码不贴了，主要完成的是beanDifinition的生成。</p>
<h4 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h4><p>Spring 对于自定义（声明式）bean标签源码实现大概的源码结构如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1486692b-7ba3-3d1d-a6f6-1c70aa45a21e.jpg" alt="image"><br>XmlBeanDefinitionReader 是核心类，它接收 spring 容器传给它的资源 resource 文件，由它负责完成整个转换。它调用 DefaultDocumentLoader 来完成将 Resource 到 Dom 树的转换。调用 DefaultBeanDefinitionDocumentReader 完成将 Dom 树到 BeanDefinition 的转换。</p>
<p>具体的代码流程细节完全可以基于这个结构去阅读，下面就贴几个核心源码段：</p>
<p>源码段 1 ： 加载 spring.shemas，在PluggableSchemaResolver.java里实现：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluggableSchemaResolver</span> <span class="title">implements</span> <span class="title">EntityResolver</span> </span>&#123;  </span><br><span class="line"><span class="comment">/***定义schema location的映射文件路径***/</span>  </span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> String DEFAULT_SCHEMA_MAPPINGS_LOCATION = <span class="string">"META-INF/spring.schemas"</span>;  </span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> Log logger = LogFactory.getLog(PluggableSchemaResolver.<span class="keyword">class</span>);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String schemaMappingsLocation;  </span><br><span class="line">    <span class="comment">/** Stores the mapping of schema URL -&gt; local schema path */</span>  </span><br><span class="line">    <span class="keyword">private</span> Properties schemaMappings;  </span><br><span class="line">    <span class="keyword">public</span> PluggableSchemaResolver(ClassLoader classLoader) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;  </span><br><span class="line">        <span class="keyword">this</span>.schemaMappingsLocation = DEFAULT_SCHEMA_MAPPINGS_LOCATION;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> PluggableSchemaResolver(ClassLoader classLoader, String schemaMappingsLocation) &#123;  </span><br><span class="line">        Assert.hasText(schemaMappingsLocation, <span class="string">"'schemaMappingsLocation' must not be empty"</span>);  </span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;  </span><br><span class="line">        <span class="keyword">this</span>.schemaMappingsLocation = schemaMappingsLocation;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**==========中间省略部分代码=========**/</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/***此处完成schema的加载***/</span>  </span><br><span class="line">    <span class="keyword">protected</span> String getSchemaMapping(String systemId) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.schemaMappings == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Loading schema mappings from ["</span> + <span class="keyword">this</span>.schemaMappingsLocation + <span class="string">"]"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">this</span>.schemaMappings =  </span><br><span class="line">                        PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.schemaMappingsLocation, <span class="keyword">this</span>.classLoader);  </span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                    logger.debug(<span class="string">"Loaded schema mappings: "</span> + <span class="keyword">this</span>.schemaMappings);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> new FatalBeanException(  </span><br><span class="line">                        <span class="string">"Unable to load schema mappings from location ["</span> + <span class="keyword">this</span>.schemaMappingsLocation + <span class="string">"]"</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.schemaMappings.getProperty(systemId);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码段 2 ： 加载 spring.handlers,在 DefaultNamespaceHandlerResolver里实现：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DefaultNamespaceHandlerResolver</span> <span class="keyword">implements</span> <span class="title">NamespaceHandlerResolver</span> </span>&#123;  </span><br><span class="line">    <span class="comment"><span class="markdown">/** </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     * The location to look for </span></span>the<span class="markdown"> mapping files. Can be present in multiple JAR files. </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span>  </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> DEFAULT_HANDLER_MAPPINGS_LOCATION = <span class="string">"META-INF/spring.handlers"</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** Logger available to subclasses *</span>/</span></span>  </span><br><span class="line">    protected <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());  </span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** ClassLoader to use for NamespaceHandler classes *</span>/</span></span>  </span><br><span class="line">    private <span class="keyword">final</span> ClassLoader classLoader;  </span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** Resource location to search for *</span>/</span></span>  </span><br><span class="line">    private <span class="keyword">final</span> <span class="built_in">String</span> handlerMappingsLocation;  </span><br><span class="line">    <span class="comment"><span class="markdown">/** Stores </span>the<span class="markdown"> mappings from namespace URI to NamespaceHandler class name / instance */</span></span>  </span><br><span class="line">    private <span class="built_in">Map</span> handlerMappings;  </span><br><span class="line">  </span><br><span class="line">    public DefaultNamespaceHandlerResolver() &#123;  </span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, DEFAULT_HANDLER_MAPPINGS_LOCATION);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public DefaultNamespaceHandlerResolver(ClassLoader classLoader) &#123;  </span><br><span class="line">        <span class="keyword">this</span>(classLoader, DEFAULT_HANDLER_MAPPINGS_LOCATION);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public DefaultNamespaceHandlerResolver(ClassLoader classLoader, <span class="built_in">String</span> handlerMappingsLocation) &#123;  </span><br><span class="line">        Assert.notNull(handlerMappingsLocation, <span class="string">"Handler mappings location must not be null"</span>);  </span><br><span class="line">        <span class="keyword">this</span>.classLoader = (classLoader != <span class="keyword">null</span> ? classLoader : ClassUtils.getDefaultClassLoader());  </span><br><span class="line">        <span class="keyword">this</span>.handlerMappingsLocation = handlerMappingsLocation;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">**==========中间省略部分代码=========**</span>/</span></span>  </span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">       <span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>* </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     * Load </span></span>the<span class="markdown"> specified NamespaceHandler mappings lazily. </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        *  此处加载延迟加载spring.handlers，只有第一次自定义标签被解析到，才会被加载。 </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        ****************************/</span></span></span>  </span><br><span class="line">    private <span class="built_in">Map</span> getHandlerMappings() &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                Properties mappings =  </span><br><span class="line">                        PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.handlerMappingsLocation, <span class="keyword">this</span>.classLoader);  </span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                    logger.debug(<span class="string">"Loaded mappings ["</span> + mappings + <span class="string">"]"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> HashMap(mappings);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">                IllegalStateException ise = <span class="keyword">new</span> IllegalStateException(  </span><br><span class="line">                        <span class="string">"Unable to load NamespaceHandler mappings from location ["</span> + <span class="keyword">this</span>.handlerMappingsLocation + <span class="string">"]"</span>);  </span><br><span class="line">                ise.initCause(ex);  </span><br><span class="line">                <span class="keyword">throw</span> ise;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handlerMappings;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码段3 ： xml 到 dom 树的解析。</p>
<p>在 XmlBeanDefinitionReader.java 的 doLoadBeanDefinitions 方法里，调用 DefaultDocumentLoader 完成。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource,<span class="built_in"> Resource </span>resource)  </span><br><span class="line">            throws BeanDefinitionStoreException &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        int validationMode = getValidationModeForResource(resource);  </span><br><span class="line">        Document doc = this.documentLoader.loadDocument(  </span><br><span class="line">                inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());  </span><br><span class="line">        return registerBeanDefinitions(doc, resource);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (BeanDefinitionStoreException ex) &#123;  </span><br><span class="line">        throw ex;  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (SAXParseException ex) &#123;  </span><br><span class="line">        throw new XmlBeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> +<span class="built_in"> resource </span>+ <span class="string">" is invalid"</span>, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (SAXException ex) &#123;  </span><br><span class="line">        throw new XmlBeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"XML document from "</span> +<span class="built_in"> resource </span>+ <span class="string">" is invalid"</span>, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (ParserConfigurationException ex) &#123;  </span><br><span class="line">        throw new BeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (IOException ex) &#123;  </span><br><span class="line">        throw new BeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"IOException parsing XML document from "</span> + resource, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (Throwable ex) &#123;  </span><br><span class="line">        throw new BeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getEntityResolver</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>会完成spring.schemas的装载,里面会间接调用源码段1。穿进去的entityResolver作为标签解析使用。</p>
<p>源码段4 ： dom 树到 Beandifinition：</p>
<p>在 XmlBeanDefinitionReader .java 的 doLoadBeanDefinitions 方法里，调用 BeanDefinitionDocumentReader 完成。</p>
 <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">    <span class="comment">// Support old XmlBeanDefinitionParser SPI for backwards-compatibility.  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parserClass != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        XmlBeanDefinitionParser parser =  </span><br><span class="line">                (XmlBeanDefinitionParser) BeanUtils.instantiateClass(<span class="keyword">this</span>.parserClass);  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> parser.<span class="title">registerBeanDefinitions</span><span class="params">(<span class="keyword">this</span>, doc, resource)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Read document based on new BeanDefinitionDocumentReader SPI.  </span></span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();  </span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();  </span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));  </span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AOP底层实现原理"><a href="#AOP底层实现原理" class="headerlink" title="AOP底层实现原理"></a>AOP底层实现原理</h3><p>代理设计模式</p>
<p>什么是代理模式</p>
<p>通过代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。既(AOP微实现) ,AOP核心技术面向切面编程。</p>
<p>代理模式应用场景</p>
<p>SpringAOP、事物原理、日志打印、权限控制、远程调用、安全代理 可以隐蔽真实角色</p>
<p>代理的分类</p>
<p>静态代理(静态定义代理类)</p>
<p>动态代理(动态生成代理类)</p>
<p>Jdk自带动态代理</p>
<p>Cglib 、javaassist（字节码操作库）</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>什么是静态代理</p>
<p>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"已经保存数据..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代理类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao <span class="keyword">target</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(IUserDao iuserDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = iuserDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启事物..."</span>);</span><br><span class="line">        <span class="keyword">target</span>.save();</span><br><span class="line">        System.out.println(<span class="string">"关闭事物..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h4><p>1.代理对象,不需要实现接口</p>
<p>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</p>
<p>3.动态代理也叫做:JDK代理,接口代理</p>
<h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>1)原理：是根据类加载器和接口创建代理类（此代理类是接口的实现类，所以必须使用接口 面向接口生成代理，位于java.lang.reflect包下）</p>
<p>2)实现方式：</p>
<p>通过实现InvocationHandler接口创建自己的调用处理器 <code>IvocationHandler handler = new InvocationHandlerImpl(…);</code></p>
<p>通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类<code>Class clazz = Proxy.getProxyClass(classLoader,new Class[]{…});</code></p>
<p>通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型<code>Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});</code></p>
<p>通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入<code>Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));</code></p>
<p>缺点：jdk动态代理，必须是面向接口，目标业务类必须实现接口<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">target</span>;<span class="comment">// 这其实业务实现类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerImpl</span><span class="params">(Object <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"调用开始处理"</span>);</span><br><span class="line">        result = method.invoke(<span class="keyword">target</span>, args);</span><br><span class="line">        System.out.println(<span class="string">"调用结束处理"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> NoSuchMethodException, SecurityException, InstantiationException,</span><br><span class="line">            IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">// 被代理对象</span></span><br><span class="line">        IUserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        InvocationHandlerImpl invocationHandlerImpl = <span class="keyword">new</span> InvocationHandlerImpl(userDao);</span><br><span class="line">        ClassLoader loader = userDao.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = userDao.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 主要装载器、一组接口及调用处理动态代理实例</span></span><br><span class="line">        IUserDao newProxyInstance = (IUserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);</span><br><span class="line">        newProxyInstance.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>原理：利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>什么是CGLIB动态代理</p>
<p>使用cglib[Code Generation Library]实现动态代理，并不要求委托类必须实现接口，底层采用asm字节码生成框架生成代理类的字节码</p>
<p>CGLIB动态代理相关代码</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> targetObject;</span><br><span class="line">    <span class="comment">// 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> getInstance(<span class="keyword">Object</span> target) &#123;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        <span class="keyword">this</span>.targetObject = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> intercept(<span class="keyword">Object</span> obj, Method method, <span class="keyword">Object</span>[] args, MethodProxy proxy) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"开启事物"</span>);</span><br><span class="line">        <span class="keyword">Object</span> result = proxy.invoke(targetObject, args);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"关闭事物"</span>);</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        UserDao userDao = (UserDao) cglibProxy.getInstance(<span class="keyword">new</span> UserDao());</span><br><span class="line">        userDao.<span class="built_in">save</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CGLIB动态代理与JDK动态区别"><a href="#CGLIB动态代理与JDK动态区别" class="headerlink" title="CGLIB动态代理与JDK动态区别"></a>CGLIB动态代理与JDK动态区别</h5><p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p>
<p>而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>Spring中。</p>
<p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</p>
<p>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP</p>
<p>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p>
<p>JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。 CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。 因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。</p>
<h2 id="springcloud的整体架构"><a href="#springcloud的整体架构" class="headerlink" title="springcloud的整体架构"></a>springcloud的整体架构</h2><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>心跳检测机制，如果某个实例在规定的时间内没有进行通讯则会自动被剔除掉，避免了某个实例挂掉而影响服务，Eureka就自动具有了注册中心、负载均衡、故障转移的功能。</p>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>Hystrix会在某个服务连续调用N次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix间隔时间会再次检查此服务，如果服务恢复将继续提供服务。 </p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>解决分布式系统的配置管理方案。它包含了Client和Server两个部分，Server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，Client通过接口获取数据、并依据此数据初始化自己的应用。 </p>
<h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其它的消息指令中。Spring Cloud Bus的一个核心思想是通过分布式的启动器对Spring Boot应用进行扩展，也可以用来建立一个或多个应用之间的通信频道。目前唯一实现的方式是用AMQP消息代理作为通道。 有了Spring Cloud Bus之后，当我们改变配置文件提交到版本库中时，会自动的触发对应实例的Refresh。</p>
<h3 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h3><p>Spring Cloud体系中支持API Gateway落地的技术就是Zuul。Spring Cloud Zuul路由是微服务架构中不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。 它的具体作用就是服务转发，接收并转发所有内外部的客户端调用。使用Zuul可以作为资源的统一访问入口，同时也可以在网关做一些权限校验等类似的功能。 </p>
<h3 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a>链路跟踪</h3><p>Spring Cloud Sleuth和Zipkin，Spring Cloud Sleuth为服务之间调用提供链路追踪。通过Sleuth可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长时间。从而让我们可以很方便的理清各微服务间的调用关系。Zipkin是Twitter的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口 。</p>
<h3 id="Feign技术"><a href="#Feign技术" class="headerlink" title="Feign技术"></a>Feign技术</h3><p>利用此技术可以伪造接口实现。</p>
<h2 id="负载均衡的算法有哪些"><a href="#负载均衡的算法有哪些" class="headerlink" title="负载均衡的算法有哪些"></a>负载均衡的算法有哪些</h2><h3 id="轮询（Round-Robin）法"><a href="#轮询（Round-Robin）法" class="headerlink" title="轮询（Round Robin）法"></a>轮询（Round Robin）法</h3><p>将所有请求，依次分发到每台服务器上，适合服务器硬件相同的场景。</p>
<ul>
<li>优点：服务器请求数目相同；</li>
<li>缺点：服务器压力不一样，不适合服务器配置不同的情况，为了做到请求转移的绝对均衡，必须付出相当大的代价，因为为了保证pos变量修改的互斥性，需要引入重量级的悲观锁synchronized，这将会导致该段轮询代码的并发吞吐量发生明显的下降；</li>
</ul>
<h3 id="随机（Random）法"><a href="#随机（Random）法" class="headerlink" title="随机（Random）法"></a>随机（Random）法</h3><p>基于概率统计的理论，吞吐量越大，随机算法的效果越接近于轮询算法的效果。</p>
<ul>
<li>优点：使用简单；</li>
<li>缺点：不适合机器配置不同的场景；</li>
</ul>
<h3 id="源地址哈希（Hash）法"><a href="#源地址哈希（Hash）法" class="headerlink" title="源地址哈希（Hash）法"></a>源地址哈希（Hash）法</h3><p>源地址哈希的思想是获取客户端访问的IP地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是要访问的服务器的序号。</p>
<ul>
<li>优点：保证了相同客户端IP地址将会被哈希到同一台后端服务器，直到后端服务器列表变更。根据此特性可以在服务消费者与服务提供者之间建立有状态的session会话。</li>
<li>缺点：除非集群中服务器的非常稳定，基本不会上下线，否则一旦有服务器上线、下线，那么通过源地址哈希算法路由到的服务器是服务器上线、下线前路由到的服务器的概率非常低，如果是session则取不到session，如果是缓存则可能引发”雪崩”；</li>
</ul>
<h3 id="加权法"><a href="#加权法" class="headerlink" title="加权法"></a>加权法</h3><p>在轮询，随机，最少链接，Hash等算法的基础上，通过加权的方式，进行负载服务器分配。</p>
<ul>
<li>优点：根据权重，调节转发服务器的请求数目；</li>
<li>缺点：使用相对复杂；</li>
</ul>
<h3 id="最小连接数（Least-Connections）法"><a href="#最小连接数（Least-Connections）法" class="headerlink" title="最小连接数（Least Connections）法"></a>最小连接数（Least Connections）法</h3><p>将请求分配到连接数最少的服务器上（目前处理请求最少的服务器）。</p>
<ul>
<li>优点：根据服务器当前的请求处理情况，动态分配；</li>
<li>缺点：算法实现相对复杂，需要监控服务器请求连接数；</li>
</ul>
<h2 id="SpringBoot如何启动"><a href="#SpringBoot如何启动" class="headerlink" title="SpringBoot如何启动"></a>SpringBoot如何启动</h2><ul>
<li>如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：<ul>
<li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li>
<li>推断并设置main方法的定义类。</li>
</ul>
</li>
<li>SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</li>
<li>创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</li>
<li>遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</li>
<li>如果SpringApplication的showBanner属性被设置为true，则打印banner。</li>
<li>根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</li>
<li>ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</li>
<li>遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</li>
<li>最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</li>
<li>遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</li>
<li>调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</li>
<li>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</li>
<li>正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</li>
</ul>
<p>去除事件通知点后，整个流程如下：<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">ConfigurableApplicationContext</span> run(<span class="type">String</span>... args) &#123;</span><br><span class="line">    <span class="comment">// 开启定时器,统计启动时间</span></span><br><span class="line">   <span class="type">StopWatch</span> stopWatch = <span class="function"><span class="keyword">new</span> <span class="title">StopWatch</span>();</span></span><br><span class="line"><span class="function">   <span class="title">stopWatch</span>.<span class="title">start</span>();</span></span><br><span class="line"><span class="function">   <span class="title">ConfigurableApplicationContext</span> <span class="title">context</span> = <span class="title">null</span>;</span></span><br><span class="line"><span class="function">   <span class="title">Collection</span>&lt;<span class="title">SpringBootExceptionReporter</span>&gt; <span class="title">exceptionReporters</span> = <span class="title">new</span> <span class="title">ArrayList</span>&lt;&gt;();</span></span><br><span class="line"><span class="function">   <span class="title">configureHeadlessProperty</span>();</span></span><br><span class="line"><span class="function">    <span class="comment">// 获取并初始化所有RunListener</span></span></span><br><span class="line"><span class="function">   <span class="title">SpringApplicationRunListeners</span> <span class="title">listeners</span> = <span class="title">getRunListeners</span>(args);</span></span><br><span class="line"><span class="function">    <span class="comment">// 发布启动事件</span></span></span><br><span class="line"><span class="function">   <span class="title">listeners</span>.<span class="title">starting</span>();</span></span><br><span class="line"><span class="function">   <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="title">ApplicationArguments</span> <span class="title">applicationArguments</span> = <span class="title">new</span> <span class="title">DefaultApplicationArguments</span>(</span></span><br><span class="line"><span class="function">            args);</span></span><br><span class="line"><span class="function">    <span class="comment">// 准备好环境environment,即配置文件等</span></span></span><br><span class="line"><span class="function">      <span class="title">ConfigurableEnvironment</span> <span class="title">environment</span> = <span class="title">prepareEnvironment</span>(listeners,</span></span><br><span class="line"><span class="function">            applicationArguments);</span></span><br><span class="line"><span class="function">      <span class="title">configureIgnoreBeanInfo</span>(environment);</span></span><br><span class="line"><span class="function">    <span class="comment">// 打印SpringBoot Logo</span></span></span><br><span class="line"><span class="function">      <span class="title">Banner</span> <span class="title">printedBanner</span> = <span class="title">printBanner</span>(environment);</span></span><br><span class="line"><span class="function">    <span class="comment">// 创建我们最常用的ApplicationContext</span></span></span><br><span class="line"><span class="function">      <span class="title">context</span> = <span class="title">createApplicationContext</span>();</span></span><br><span class="line"><span class="function">    <span class="comment">// 获取异常报告器,在启动发生异常的时候用友好的方式提示用户</span></span></span><br><span class="line"><span class="function">      <span class="title">exceptionReporters</span> = <span class="title">getSpringFactoriesInstances</span>(</span></span><br><span class="line"><span class="function">            <span class="type">SpringBootExceptionReporter</span>.class,</span></span><br><span class="line"><span class="function">            new <span class="type">Class</span>[] &#123; <span class="type">ConfigurableApplicationContext</span>.class &#125;, context);</span></span><br><span class="line"><span class="function">    <span class="comment">// 准备Context,加载启动类作为source</span></span></span><br><span class="line"><span class="function">      <span class="title">prepareContext</span>(context, environment, listeners, applicationArguments,</span></span><br><span class="line"><span class="function">            printedBanner);</span></span><br><span class="line"><span class="function">    <span class="comment">// Spring初始化的核心逻辑,构建整个容器</span></span></span><br><span class="line"><span class="function">      <span class="title">refreshContext</span>(context);</span></span><br><span class="line"><span class="function">      <span class="title">afterRefresh</span>(context, applicationArguments);</span></span><br><span class="line"><span class="function">    <span class="comment">// 停止计时,统计启动耗时</span></span></span><br><span class="line"><span class="function">      <span class="title">stopWatch</span>.<span class="title">stop</span>();</span></span><br><span class="line"><span class="function">      <span class="title">if</span> (this.logStartupInfo) &#123;</span></span><br><span class="line"><span class="function">         <span class="title">new</span> <span class="title">StartupInfoLogger</span>(this.mainApplicationClass)</span></span><br><span class="line"><span class="function">               .<span class="title">logStarted</span>(getApplicationLog(), <span class="title">stopWatch</span>);</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">      <span class="title">listeners</span>.<span class="title">started</span>(context);</span></span><br><span class="line"><span class="function">    <span class="comment">// 调用runner接口供应用自定义初始化</span></span></span><br><span class="line"><span class="function">      <span class="title">callRunners</span>(context, applicationArguments);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   <span class="title">catch</span> (<span class="type">Throwable</span> ex) &#123;</span></span><br><span class="line"><span class="function">    <span class="comment">// 处理启动中抛出的异常,使用异常报告器输出</span></span></span><br><span class="line"><span class="function">      <span class="title">handleRunFailure</span>(context, ex, exceptionReporters, listeners);</span></span><br><span class="line"><span class="function">      <span class="title">throw</span> <span class="title">new</span> <span class="title">IllegalStateException</span>(ex);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="title">listeners</span>.<span class="title">running</span>(context);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   <span class="title">catch</span> (<span class="type">Throwable</span> ex) &#123;</span></span><br><span class="line"><span class="function">      <span class="title">handleRunFailure</span>(context, ex, exceptionReporters, null);</span></span><br><span class="line"><span class="function">      <span class="title">throw</span> <span class="title">new</span> <span class="title">IllegalStateException</span>(ex);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   <span class="title">return</span> <span class="title">context</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG992.jpeg" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG993.png" alt="image"></p>
<p><img src="http://image.tengj.top/springboot3-3.jpg" alt="image"></p>
<h2 id="什么是脑裂"><a href="#什么是脑裂" class="headerlink" title="什么是脑裂"></a>什么是脑裂</h2><h3 id="什么是脑裂-1"><a href="#什么是脑裂-1" class="headerlink" title="什么是脑裂"></a>什么是脑裂</h3><p>脑裂(split-brain)就是“大脑分裂”，也就是本来一个“大脑”被拆分了两个或多个“大脑”，我们都知道，如果一个人有多个大脑，并且相互独立的话，那么会导致人体“手舞足蹈”，“不听使唤”。</p>
<p>脑裂通常会出现在集群环境中，比如ElasticSearch、Zookeeper集群，而这些集群环境有一个统一的特点，就是它们有一个大脑，比如ElasticSearch集群中有Master节点，Zookeeper集群中有Leader节点。</p>
<p>章着重来给大家讲一下Zookeeper中的脑裂问题，以及是如果解决脑裂问题的。</p>
<h3 id="Zookeeper集群中的脑裂场景"><a href="#Zookeeper集群中的脑裂场景" class="headerlink" title="Zookeeper集群中的脑裂场景"></a>Zookeeper集群中的脑裂场景</h3><p>对于一个集群，想要提高这个集群的可用性，通常会采用多机房部署，比如现在有一个由6台zkServer所组成的一个集群，部署在了两个机房：</p>
<p>正常情况下，此集群只会有一个Leader，那么如果机房之间的网络断了之后，两个机房内的zkServer还是可以相互通信的，如果不考虑过半机制，那么就会出现每个机房内部都将选出一个Leader。 </p>
<p>这就相当于原本一个集群，被分成了两个集群，出现了两个“大脑”，这就是脑裂。</p>
<p>对于这种情况，我们也可以看出来，原本应该是统一的一个集群对外提供服务的，现在变成了两个集群同时对外提供服务，如果过了一会，断了的网络突然联通了，那么此时就会出现问题了，两个集群刚刚都对外提供服务了，数据该怎么合并，数据冲突怎么解决等等问题。</p>
<p>刚刚在说明脑裂场景时，有一个前提条件就是没有考虑过半机制，所以实际上Zookeeper集群中是不会出现脑裂问题的，而不会出现的原因就跟过半机制有关。</p>
<h3 id="过半机制"><a href="#过半机制" class="headerlink" title="过半机制"></a>过半机制</h3><p>在领导者选举的过程中，如果某台zkServer获得了超过半数的选票，则此zkServer就可以成为Leader了。</p>
<p>过半机制的源码实现其实非常简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuorumMaj</span> <span class="keyword">implements</span> <span class="title">QuorumVerifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(QuorumMaj.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> half;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// n表示集群中zkServer的个数（准确的说是参与者的个数，参与者不包括观察者节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuorumMaj</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.half = n/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否符合过半机制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsQuorum</span><span class="params">(Set&lt;Long&gt; set)</span></span>&#123;</span><br><span class="line">        <span class="comment">// half是在构造方法里赋值的</span></span><br><span class="line">        <span class="comment">// set.size()表示某台zkServer获得的票数</span></span><br><span class="line">        <span class="keyword">return</span> (set.size() &gt; half);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家仔细看一下上面方法中的注释，核心代码就是下面两行：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.half = n/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">set</span>.size() &gt; half);</span><br></pre></td></tr></table></figure></p>
<p>举个简单的例子： 如果现在集群中有5台zkServer，那么half=5/2=2，那么也就是说，领导者选举的过程中至少要有三台zkServer投了同一个zkServer，才会符合过半机制，才能选出来一个Leader。</p>
<p>那么有一个问题我们想一下，选举的过程中为什么一定要有一个过半机制验证？ 因为这样不需要等待所有zkServer都投了同一个zkServer就可以选举出来一个Leader了，这样比较快，所以叫快速领导者选举算法呗。</p>
<p>那么再来想一个问题，过半机制中为什么是大于，而不是大于等于呢？</p>
<p>这就是更脑裂问题有关系了，比如回到上文出现脑裂问题的场景： </p>
<p>当机房中间的网络断掉之后，机房1内的三台服务器会进行领导者选举，但是此时过半机制的条件是set.size() &gt; 3，也就是说至少要4台zkServer才能选出来一个Leader，所以对于机房1来说它不能选出一个Leader，同样机房2也不能选出一个Leader，这种情况下整个集群当机房间的网络断掉后，整个集群将没有Leader。</p>
<p>而如果过半机制的条件是set.size() &gt;= 3，那么机房1和机房2都会选出一个Leader，这样就出现了脑裂。所以我们就知道了，为什么过半机制中是大于，而不是大于等于。就是为了防止脑裂。</p>
<p>如果假设我们现在只有5台机器，也部署在两个机房： </p>
<p>此时过半机制的条件是set.size() &gt; 2，也就是至少要3台服务器才能选出一个Leader，此时机房件的网络断开了，对于机房1来说是没有影响的，Leader依然还是Leader，对于机房2来说是选不出来Leader的，此时整个集群中只有一个Leader。</p>
<p>所以，我们可以总结得出，有了过半机制，对于一个Zookeeper集群，要么没有Leader，要没只有1个Leader，这样就避免了脑裂问题。</p>
<p>有痛点才有创新，一个技术肯定都是为了解决某个痛点才出现的。</p>
<h2 id="Saga模式与TCC的区别"><a href="#Saga模式与TCC的区别" class="headerlink" title="Saga模式与TCC的区别"></a>Saga模式与TCC的区别</h2><h3 id="各种形态的分布式事务"><a href="#各种形态的分布式事务" class="headerlink" title="各种形态的分布式事务"></a>各种形态的分布式事务</h3><p>分布式事务有多种主流形态，包括：</p>
<ul>
<li>基于消息实现的分布式事务</li>
<li>基于补偿实现的分布式事务</li>
<li>基于TCC实现的分布式事务</li>
<li>基于SAGA实现的分布式事务</li>
<li>基于2PC实现的分布式事务<br>这些形态的原理已经在很多文章中进行了剖析，用“分布式事务”关键字就能搜到对应的文章，本文不再赘述这些形态的原理，并将重点放在如何根据业务选择对应的分布式事务形态上。</li>
</ul>
<h3 id="何时选择单机事务"><a href="#何时选择单机事务" class="headerlink" title="何时选择单机事务"></a>何时选择单机事务</h3><p>这个相信大家都很清楚，在条件允许的情况下，我们应该尽可能地使用单机事务，因为单机事务里，无需额外协调其他数据源，减少了网络交互时间消耗以及协调时所需的存储IO消耗，在修改等量业务数据的情况下，单机事务将会有更高的性能。</p>
<p>但单机数据库由于 业务逻辑解耦等因素进行了数据库垂直拆分、或者由于单机数据库性能压力等因素进行了数据库水平拆分之后，数据分布于多个数据库，这时若需要对多个数据库的数据进行协调变更，则需要引入分布式事务。</p>
<p>分布式事务的模式有很多种，那究竟要怎么选择适合业务的模式呢？以下我们将从使用场景、性能、开发成本这几个方面进行分析。</p>
<h3 id="何时选择基于消息实现的事务"><a href="#何时选择基于消息实现的事务" class="headerlink" title="何时选择基于消息实现的事务"></a>何时选择基于消息实现的事务</h3><p>基于消息实现的事务适用于分布式事务的提交或回滚只取决于事务发起方的业务需求，其他数据源的数据变更跟随发起方进行的业务场景。</p>
<p>举个例子，假设存在业务规则：某笔订单成功后，为用户加一定的积分。</p>
<p>在这条规则里，管理订单数据源的服务为事务发起方，管理积分数据源的服务为事务跟随者。</p>
<p>从这个过程可以看到，基于消息队列实现的事务存在以下操作：</p>
<hr>
<p>订单服务创建订单，提交本地事务<br>订单服务发布一条消息<br>积分服务收到消息后加积分<br>我们可以看到它的整体流程是比较简单的，同时业务开发工作量也不大：</p>
<ul>
<li>编写订单服务里订单创建的逻辑</li>
<li>编写积分服务里增加积分的逻辑<br>可以看到该事务形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程。因此基于消息队列实现的事务是我们除了单机事务外最优先考虑使用的形态。</li>
</ul>
<h3 id="何时选择利用补偿实现的事务？"><a href="#何时选择利用补偿实现的事务？" class="headerlink" title="何时选择利用补偿实现的事务？"></a>何时选择利用补偿实现的事务？</h3><p>但是基于消息实现的事务并不能解决所有的业务场景，例如以下场景：某笔订单完成时，同时扣掉用户的现金。</p>
<p>这里事务发起方是管理订单库的服务，但对整个事务是否提交并不能只由订单服务决定，因为还要确保用户有足够的钱，才能完成这笔交易，而这个信息在管理现金的服务里。这里我们可以引入基于补偿实现的事务，其流程如下：</p>
<ul>
<li>创建订单数据，但暂不提交本地事务</li>
<li>订单服务发送远程调用到现金服务，以扣除对应的金额</li>
<li>上述步骤成功后提交订单库的事务<br>以上这个是正常成功的流程，异常流程需要回滚的话，将额外发送远程调用到现金服务以加上之前扣掉的金额。</li>
</ul>
<p>以上流程比基于消息队列实现的事务的流程要复杂，同时开发的工作量也更多：</p>
<ul>
<li>编写订单服务里创建订单的逻辑</li>
<li>编写现金服务里扣钱的逻辑</li>
<li>编写现金服务里补偿返还的逻辑<br>可以看到，该事务流程相对于基于消息实现的分布式事务更为复杂，需要额外开发相关的业务回滚方法，也失去了服务间流量削峰填谷的功能。但其仅仅只比基于消息的事务复杂多一点，若不能使用基于消息队列的最终一致性事务，那么可以优先考虑使用基于补偿的事务形态。</li>
</ul>
<p>（题外话：阿里GTS也是利用补偿实现，只不过补偿代码自动生成，无需业务干预，同时接管应用数据源，禁止业务修改处于全局事务状态中的记录。）</p>
<h3 id="何时选择利用TCC实现的事务"><a href="#何时选择利用TCC实现的事务" class="headerlink" title="何时选择利用TCC实现的事务"></a>何时选择利用TCC实现的事务</h3><p>然而基于补偿的事务形态也并非能实现所有的需求，如以下场景：某笔订单完成时，同时扣掉用户的现金，但交易未完成，也未被取消时，不能让客户看到钱变少了。</p>
<p>这时我们可以引入TCC，其流程如下：</p>
<ul>
<li>订单服务创建订单</li>
<li>订单服务发送远程调用到现金服务，冻结客户的现金</li>
<li>提交订单服务数据</li>
<li>订单服务发送远程调用到现金服务，扣除客户冻结的现金<br>以上是正常完成的流程，若为异常流程，则需要发送远程调用请求到现金服务，撤销冻结的金额。</li>
</ul>
<p>以上流程比基于补偿实现的事务的流程要复杂，同时开发的工作量也更多：</p>
<ul>
<li>订单服务编写创建订单的逻辑</li>
<li>现金服务编写冻结现金的逻辑</li>
<li>现金服务编写扣除现金的逻辑</li>
<li>现金服务编写解冻现金的逻辑<br>TCC实际上是最为复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。</li>
</ul>
<h3 id="何时选择利用SAGA实现的事务？"><a href="#何时选择利用SAGA实现的事务？" class="headerlink" title="何时选择利用SAGA实现的事务？"></a>何时选择利用SAGA实现的事务？</h3><p>saga是30年前的一篇数据库论文提到的概念。 论文中定义saga事务是一个长事务，整个事务可以由多个本地事务组成，每个本地事务有相应的执行模块和补偿模块，当saga事务中任意一个事务出错了，可以调用相关事务进行对应的补偿恢复，达到事务的最终一致性。</p>
<p>由于分布式系统中网络带来的不可靠性，saga调用服务提出了服务应该支持幂等，在服务调用超时重试情况下，不至于产生问题。</p>
<p>saga事务没有准备阶段，不具备隔离性，如果多个saga事务同时操作同一资源会遇到多线程临界资源的情况，产生数据丢失或者脏数据。</p>
<p>为解决隔离性，可以参考TCC模式，在业务层加入session及锁机制保证操作串型化，通过业务层面达到隔离效果。</p>
<p>saga在分布式架构下，采用事务驱动方式，让服务进行相关交互，业务方订阅相关领域事件即可。 通过事件方式降低系统复杂度，提升系统扩展性，但要注意事件循环依赖的问题。</p>
<p>SAGA可以看做一个异步的、利用队列实现的补偿事务。</p>
<p>其适用于无需马上返回业务发起方最终状态的场景，例如：你的请求已提交，请稍后查询或留意通知 之类。</p>
<p>将上述补偿事务的场景用SAGA改写，其流程如下：</p>
<ul>
<li>订单服务创建最终状态未知的订单记录，并提交事务</li>
<li>现金服务扣除所需的金额，并提交事务</li>
<li>订单服务更新订单状态为成功，并提交事务<br>以上为成功的流程，若现金服务扣除金额失败，那么，最后一步订单服务将会更新订单状态为失败。</li>
</ul>
<p>其业务编码工作量比补偿事务多一点，包括以下内容：</p>
<ul>
<li>订单服务创建初始订单的逻辑</li>
<li>订单服务确认订单成功的逻辑</li>
<li>订单服务确认订单失败的逻辑</li>
<li>现金服务扣除现金的逻辑</li>
<li>现金服务补偿返回现金的逻辑<br>但其相对于补偿事务形态有性能上的优势，所有的本地子事务执行过程中，都无需等待其调用的子事务执行，减少了加锁的时间，这在事务流程较多较长的业务中性能优势更为明显。同时，其利用队列进行进行通讯，具有削峰填谷的作用。</li>
</ul>
<p>因此该形式适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。</p>
<p>但当然SAGA也可以进行稍微改造，变成与TCC类似、可以进行资源预留的形态。</p>
<h3 id="2PC事务"><a href="#2PC事务" class="headerlink" title="2PC事务"></a>2PC事务</h3><p>其适用于参与者较少，单个本地事务执行时间较少，并且参与者自身可用性很高的场景，否则，其很可能导致性能下降严重。</p>
<h3 id="并非一种事务形态就能打遍天下"><a href="#并非一种事务形态就能打遍天下" class="headerlink" title="并非一种事务形态就能打遍天下"></a>并非一种事务形态就能打遍天下</h3><p>通过分析我们可以发现，并不存在一种事务形态能解决所有的问题，我们需要根据特定的业务场景选择合适的事务形态。甚至于有时需要混合多种事务形态才能更好的完成目标，如 上面提到的 订单、积分、钱包混合的场景：订单的成功与否需要依赖于钱包的余额，但不依赖于积分的多少，因此可以混合基于消息的事务形态以加积分 及 基于补偿的事务形态以确保扣钱成功，从而得到一个性能更好，编码量更少的形态。</p>
<p>然而目前很多框架都专注于某单一方面的事务形态，如TCC单独一个框架，可靠消息单独一个框架，SAGA单独一个框架，他们各自独立，容易导致以下问题：</p>
<ul>
<li>由于前期只采用了其中一种类型事务的框架，因为工具目前只有锤子，引入其他工具又涉及测试、阅读代码等过程，因此把所有问题都看做钉子，导致性能偏低或者实现不够优雅</li>
<li>由于不同框架管理事务的形态可能不一致，导致不能很好的协调工作，如某一个TCC框架和另一个基于消息的事务框架无法很好融合。</li>
</ul>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><strong>Spring事务的隔离级别</strong></p>
<ol>
<li><code>ISOLATION_DEFAULT</code>： 这是一个 PlatfromTransactionManager  默认的隔离级别，使用数据库默认的事务隔离级别.</li>
</ol>
<p>另外四个与 JDBC的隔离级别相对应:</p>
<ol start="2">
<li><code>ISOLATION_READ_UNCOMMITTED</code>： 这是事务最低的隔离级别，它允许令外一个事务可以看到这个事务未提交的数据,</li>
</ol>
<p>这种隔离级别会产生脏读，不可重复读和幻像读。</p>
<ol start="3">
<li><p><code>ISOLATION_READ_COMMITTED</code>： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</p>
</li>
<li><p><code>ISOLATION_REPEATABLE_READ</code>： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p>
</li>
<li><p><code>ISOLATION_SERIALIZABLE</code>  这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p>
</li>
</ol>
<p><strong>其中的一些概念的说明：</strong><br><strong>脏读</strong>:  指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一 个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>
<p><strong>不可重复读</strong>:  指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
<p><strong>幻觉读</strong>:指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及 到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，就会发生操作第一个事务的用户发现表中还有 没有修改的数据行,也就是说幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读,就好象发生了幻觉一样。</p>
<h2 id="事务的传播行为和隔离级别之间有什么联系"><a href="#事务的传播行为和隔离级别之间有什么联系" class="headerlink" title="事务的传播行为和隔离级别之间有什么联系"></a>事务的传播行为和隔离级别之间有什么联系</h2><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>事务传播行为(为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时,必须指定事务应该如何传播。例如:方法可能继续在现有事务中运行,也可能开启一个新事务,并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量:</p>
<h4 id="支持当前事务的情况"><a href="#支持当前事务的情况" class="headerlink" title="支持当前事务的情况"></a>支持当前事务的情况</h4><ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>: 如果当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务。</li>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>: 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>: 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(mandatory:强制性)</li>
</ul>
<h4 id="不支持当前事务的情况"><a href="#不支持当前事务的情况" class="headerlink" title="不支持当前事务的情况"></a>不支持当前事务的情况</h4><ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>: 创建一个新的事务,如果当前存在事务,则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>: 以非事务方式运行,如果当前存在事务,则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NEVER</code>: 以非事务方式运行,如果当前存在事务,则抛出异常。</li>
</ul>
<h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><ul>
<li><code>TransactionDefinition.PROPAGATION_NESTED</code>: 如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务,则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量:</p>
<ul>
<li><code>TransactionDefinition.ISOLATION_DEFAULT</code>: 使用后端数据库默认的隔离级别,Mysql 默认采用的<code>REPEATABLE_READ</code>隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code>隔离级别。</li>
<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>: 最低的隔离级别,允许读取尚未提交的数据变更,可能会导致脏读、幻读或不可重复读。</li>
<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>: 允许读取并发事务已经提交的数据,可以阻止脏读,但是幻读或不可重复读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>: 对同一字段的多次读取结果都是一致的,除非数据是被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>: 最高的隔离级别,完全服从ACID的隔离级别。所有的事务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1656058-20190611152652742-1944751292.png" alt="image"></p>
<h2 id="如何理解Spring中的AOP-和-IOC，以及DI，读过Spring源码没有？"><a href="#如何理解Spring中的AOP-和-IOC，以及DI，读过Spring源码没有？" class="headerlink" title="如何理解Spring中的AOP 和 IOC，以及DI，读过Spring源码没有？"></a>如何理解Spring中的AOP 和 IOC，以及DI，读过Spring源码没有？</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/12942196-ccb87f486fddc550.png" alt="image"></p>
<h4 id="什么是aop"><a href="#什么是aop" class="headerlink" title="什么是aop"></a>什么是aop</h4><ul>
<li>AOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。</li>
<li>在不改变原有的逻辑的基础上，增加一些额外的功能。代理也是这个功能，读写分离也能用aop来做。</li>
<li>AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</li>
<li>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</li>
<li>使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>
</ul>
<h4 id="AOP的相关概念"><a href="#AOP的相关概念" class="headerlink" title="AOP的相关概念"></a>AOP的相关概念</h4><p>(1)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
<p>(2)Aspect(切面):通常是一个类，里面可以定义切入点和通知</p>
<p>(3)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
<p>(4)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕)</p>
<p>(5)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式</p>
<p>(6)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程</p>
<p>(7)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段</p>
<p>(8)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类</p>
<p>(9)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</p>
<h4 id="Advice通知类型介绍"><a href="#Advice通知类型介绍" class="headerlink" title="Advice通知类型介绍"></a>Advice通知类型介绍</h4><p>(1)Before:在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可</p>
<p>(2)AfterReturning:在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值</p>
<p>(3)AfterThrowing:主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名</p>
<p>来访问目标方法中所抛出的异常对象</p>
<p>(4)After:在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式</p>
<p>(5)Around:环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint</p>
<h4 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h4><ul>
<li>Authentication 权限</li>
<li>Caching 缓存</li>
<li>Context passing 内容传递</li>
<li>Error handling 错误处理</li>
<li>Lazy loading　懒加载</li>
<li>Debugging　　调试</li>
<li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li>
<li>Performance optimization　性能优化</li>
<li>Persistence　　持久化</li>
<li>Resource pooling　资源池</li>
<li>Synchronization　同步</li>
<li>Transactions 事务</li>
</ul>
<h4 id="使用AOP的几种方式"><a href="#使用AOP的几种方式" class="headerlink" title="使用AOP的几种方式"></a>使用AOP的几种方式</h4><p>1.经典的基于代理的AOP</p>
<p>2.@AspectJ注解驱动的切面</p>
<p>3.纯POJO切面（纯粹通过<code>&lt;aop:fonfig&gt;</code>标签配置）</p>
<p>4.注入式AspectJ切面</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC 全称为 Inversion of Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection）,即依赖注入。</p>
<p>如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</p>
<ol>
<li>谁控制谁</li>
<li>控制什么</li>
<li>为何是反转</li>
<li>哪些方面反转了</li>
</ol>
<p>在回答这四个问题之前，我们先看 IOC 的定义：</p>
<blockquote>
<p>所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系</p>
</blockquote>
<p>上面这句话是整个 IoC 理论的核心。如何来理解这句话？我们引用一个例子来走阐述（看完该例子上面四个问题也就不是问题了）。</p>
<p>已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 年轻小伙子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungMan</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> BeautifulGirl beautifulGirl;</span><br><span class="line"></span><br><span class="line">    YoungMan()&#123;</span><br><span class="line">        <span class="comment">// 可能你比较牛逼，指腹为婚</span></span><br><span class="line">        <span class="comment">// beautifulGirl = new BeautifulGirl();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeautifulGirl</span><span class="params">(BeautifulGirl beautifulGirl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beautifulGirl = beautifulGirl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        YoungMan you = <span class="keyword">new</span> YoungMan();</span><br><span class="line">        BeautifulGirl beautifulGirl = <span class="keyword">new</span> BeautifulGirl(<span class="string">"你的各种条件"</span>);</span><br><span class="line">        beautifulGirl.setxxx(<span class="string">"各种投其所好"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后你有女票了</span></span><br><span class="line">        you.setBeautifulGirl(beautifulGirl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(<code>new BeautifulGirl()</code>)，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。</p>
<p>其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？</p>
<p>这个给我们送东西的“人” 就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。</p>
<p>诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是让别人为你服务</p>
<p>在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来</p>
<p>现在在看上面那四个问题，答案就显得非常明显了:</p>
<ul>
<li>谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li>
<li>控制什么：控制对象。</li>
<li>为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>
<li><p>哪些方面反转了：所依赖对象的获取被反转了。<br>妹子有了，但是如何拥有妹子呢？这也是一门学问。</p>
</li>
<li><p>可能你比较牛逼，刚刚出生的时候就指腹为婚了。</p>
</li>
<li>大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。</li>
<li>还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。<br>所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。</li>
</ul>
<h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><p>构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">YoungMan</span>(<span class="keyword">BeautifulGirl </span><span class="keyword">beautifulGirl)&#123;</span></span><br><span class="line"><span class="keyword"> </span>       this.<span class="keyword">beautifulGirl </span>= <span class="keyword">beautifulGirl;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。</p>
<h4 id="setter-方法注入"><a href="#setter-方法注入" class="headerlink" title="setter 方法注入"></a>setter 方法注入</h4><p>对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungMan</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> BeautifulGirl beautifulGirl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeautifulGirl</span><span class="params">(BeautifulGirl beautifulGirl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beautifulGirl = beautifulGirl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。</p>
<h4 id="接口方式注入"><a href="#接口方式注入" class="headerlink" title="接口方式注入"></a>接口方式注入</h4><p>接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>DI（Dependency Injection）依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。</p>
<h4 id="依赖注入发生的时间"><a href="#依赖注入发生的时间" class="headerlink" title="依赖注入发生的时间"></a>依赖注入发生的时间</h4><p>当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生：<br>1)、用户第一次调用 getBean()方法时，IOC 容器触发依赖注入。<br>2)、当用户在配置文件中将<code>&lt;bean&gt;</code>元素配置了 lazy-init=false 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。</p>
<p>BeanFactory 接口定义了 Spring IOC 容器的基本功能规范，是 Spring IOC 容器所应遵守的最底层和最基本的编程规范。BeanFactory 接口中定义了几个 getBean()方法，就是用户向 IOC 容器索取管理的Bean 的方法，我们通过分析其子类AbstractBeanFactory 的具体实现，理解 Spring IOC 容器在用户索取 Bean 时如何完成依赖注入。</p>
<p>AbstractBeanFactory 的 getBean()相关方法的源码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取IOC容器中指定名称的Bean</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称和类型的Bean</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T getBean(<span class="keyword">String</span> name, @Nullable Class&lt;T&gt; requiredType) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称和参数的Bean</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name, <span class="keyword">Object</span>... args) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称、类型和参数的Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T getBean(<span class="keyword">String</span> name, @Nullable Class&lt;T&gt; requiredType, @Nullable <span class="keyword">Object</span>... args)</span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="comment">//真正实现向IOC容器获取Bean的功能，也是触发依赖注入功能的地方</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T doGetBean(<span class="keyword">final</span> <span class="keyword">String</span> name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span><br><span class="line">        @Nullable <span class="keyword">final</span> <span class="keyword">Object</span>[] args, <span class="built_in">boolean</span> typeCheckOnly) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖</span></span><br><span class="line">    <span class="comment">//如果指定的是别名，将别名转换为规范的Bean名称</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> beanName = transformedBeanName(name);</span><br><span class="line">    <span class="keyword">Object</span> bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">//先从缓存中取是否已经有被创建过的单态类型的Bean</span></span><br><span class="line">    <span class="comment">//对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建</span></span><br><span class="line">    <span class="keyword">Object</span> sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">//IOC容器创建单例模式Bean实例对象</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="comment">//如果指定名称的Bean在容器中已有单例模式的Bean被创建</span></span><br><span class="line">            <span class="comment">//直接返回已经创建的Bean</span></span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理</span></span><br><span class="line">        <span class="comment">//注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是</span></span><br><span class="line">        <span class="comment">//创建创建对象的工厂Bean，两者之间有区别</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">        <span class="comment">//缓存没有正在创建的单例模式Bean</span></span><br><span class="line">        <span class="comment">//缓存中已经有已经创建的原型模式Bean</span></span><br><span class="line">        <span class="comment">//但是由于循环引用的问题导致实例化对象失败</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        <span class="comment">//对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否</span></span><br><span class="line">        <span class="comment">//能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器</span></span><br><span class="line">        <span class="comment">//的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="comment">//当前容器的父级容器存在，且当前容器中不存在指定名称的Bean</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            <span class="comment">//解析指定Bean名称的原始名称</span></span><br><span class="line">            <span class="keyword">String</span> nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                        nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="comment">//委派父级容器根据指定名称和显式的参数查找</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="comment">//委派父级容器根据指定名称和类型查找</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建的Bean是否需要进行类型验证，一般不需要</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="comment">//向容器标记指定的Bean已经被创建</span></span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据指定Bean名称获取其父级的Bean定义</span></span><br><span class="line">            <span class="comment">//主要解决Bean继承时子类合并父类公共属性问题</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            <span class="comment">//获取当前Bean所有依赖Bean的名称</span></span><br><span class="line">            <span class="keyword">String</span>[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="comment">//如果当前Bean有依赖Bean</span></span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">String</span> dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//递归调用getBean方法，获取当前Bean的依赖Bean</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="comment">//把被依赖Bean注册给当前依赖的Bean</span></span><br><span class="line">                    getBean(dep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="comment">//创建单例模式Bean的实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                <span class="comment">//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象</span></span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        <span class="comment">//显式地从容器单例模式Bean缓存中清除实例对象</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//IOC容器创建原型模式Bean实例对象</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">                <span class="comment">//原型模式(Prototype)是每次都会创建一个新的对象</span></span><br><span class="line">                <span class="keyword">Object</span> prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象</span></span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">//创建指定Bean对象实例</span></span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建</span></span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中</span></span><br><span class="line">            <span class="comment">//配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中</span></span><br><span class="line">            <span class="comment">//比较常用，如：request、session、application等生命周期</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">String</span> scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.<span class="built_in">get</span>(scopeName);</span><br><span class="line">                <span class="comment">//Bean定义资源中没有配置生命周期范围，则Bean定义不合法</span></span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span></span><br><span class="line">                    <span class="keyword">Object</span> scopedInstance = scope.<span class="built_in">get</span>(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                            <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                            <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="comment">//对创建的Bean实例对象进行类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面对向 IOC 容器获取 Bean 方法的分析，我们可以看到在 Spring 中，如果 Bean 定义的单例模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以通过其指定的生命周期范围来创建。</p>
<p>上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean实例 对象的创 建过程 由实现了AbstractBeanFactory接口 的匿名内 部类的createBean()方法 完成，AbstractBeanFactory使 用 委 派 模 式 ， 具 体 的 Bean 实 例 创 建 过 程 交 由 其 实 现 类AbstractAutowireCapableBeanFactory 完成，我们继续分析AbstractAutowireCapableBeanFactory的 createBean()方法的源码，理解其创建 Bean 实例的具体实现过程。</p>
<h4 id="开始实例化"><a href="#开始实例化" class="headerlink" title="开始实例化"></a>开始实例化</h4><p>AbstractAutowireCapableBeanFactory 类实现了 AbstractBeanFactory接口，创建容器指定的 Bean 实例对象，同时还对创建的 Bean 实例对象进行初始化处理。其创建 Bean 实例对象的方法源码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Bean实例对象</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> createBean(<span class="keyword">String</span> beanName, RootBeanDefinition mbd, @Nullable <span class="keyword">Object</span>[] args)</span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">    <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">    <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">    <span class="comment">//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="comment">//校验和准备Bean中的方法覆盖</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        <span class="comment">//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象</span></span><br><span class="line">        <span class="keyword">Object</span> bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建Bean的入口</span></span><br><span class="line">        <span class="keyword">Object</span> beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already...</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// An IllegalStateException to be communicated up to DefaultSingletonBeanRegistry...</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正创建Bean的方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doCreateBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable <span class="keyword">Object</span>[] args)</span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="comment">//封装被创建的Bean对象</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Object</span> bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">//获取实例化对象的类型</span></span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="comment">//调用PostProcessor后置处理器</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">//向容器中缓存单例模式的Bean对象，以防循环引用</span></span><br><span class="line">    <span class="built_in">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="comment">//Bean对象的初始化，依赖注入在此触发</span></span><br><span class="line">    <span class="comment">//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean</span></span><br><span class="line">    <span class="keyword">Object</span> exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//初始化Bean对象</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">//获取指定名称的已注册的单例模式Bean对象</span></span><br><span class="line">        <span class="keyword">Object</span> earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据名称获取的已注册的Bean和正在实例化的Bean是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">//当前实例化的Bean初始化完成</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="keyword">String</span>[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;<span class="keyword">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="comment">//获取当前Bean所依赖的其他Bean</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="comment">//对依赖Bean进行类型检查</span></span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.<span class="built_in">add</span>(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="comment">//注册完成依赖注入的Bean</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的源码注释，我们看到具体的依赖注入实现其实就在以下两个方法中：<br>1)、createBeanInstance()方法，生成 Bean 所包含的 java 对象实例。<br>2)、populateBean()方法，对 Bean 属性的依赖注入进行处理。<br>下面继续分析这两个方法的代码实现。</p>
<h4 id="选择-Bean-实例化策略"><a href="#选择-Bean-实例化策略" class="headerlink" title="选择 Bean 实例化策略"></a>选择 Bean 实例化策略</h4><p>在 createBeanInstance()方法中，根据指定的初始化策略，使用简单工厂、工厂方法或者容器的自动装配特性生成 Java 实例对象，创建对象的源码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Bean的实例对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    <span class="comment">//检查确认Bean是可实例化的</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用工厂方法对Bean进行实例化</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">obtainFromSupplier</span><span class="params">(instanceSupplier, beanName)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">        <span class="comment">//调用工厂方法实例化</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">instantiateUsingFactoryMethod</span><span class="params">(beanName, mbd, args)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">    <span class="comment">//使用容器的自动装配方法进行实例化</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="comment">//配置了自动装配属性，使用容器的自动装配实例化</span></span><br><span class="line">            <span class="comment">//容器的自动装配是根据参数类型匹配Bean的构造方法</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">autowireConstructor</span><span class="params">(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用默认的无参构造方法实例化</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">instantiateBean</span><span class="params">(beanName, mbd)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to determine the constructor...</span></span><br><span class="line">    <span class="comment">//使用Bean的构造方法进行实例化</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">        <span class="comment">//使用容器的自动装配特性，调用匹配的构造方法实例化</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">autowireConstructor</span><span class="params">(beanName, mbd, ctors, args)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">    <span class="comment">//使用默认的无参构造方法实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">instantiateBean</span><span class="params">(beanName, mbd)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的无参构造方法实例化Bean对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//获取系统的安全管理接口，JDK标准的安全管理API</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里是一个匿名内置类，根据实例化策略创建实例对象</span></span><br><span class="line">            beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">                    getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">                    getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将实例化的对象封装起来</span></span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的 Bean 的实例化相当比较清楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用的默认无参构造方法就需要使用相应的初始化策略(JDK 的反射机制或者 CGLib)来进行初始化了，在方法 getInstantiationStrategy().instantiate()中就具体实现类使用初始策略实例化对象。</p>
<h4 id="执行-Bean-实例化"><a href="#执行-Bean-实例化" class="headerlink" title="执行 Bean 实例化"></a>执行 Bean 实例化</h4><p>在使用默认的无参构造方法创建 Bean 的实例化对象时，方法 getInstantiationStrategy().instantiate()调用了 SimpleInstantiationStrategy 类中的实例化 Bean 的方法，其源码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用初始化策略实例化Bean对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line">    <span class="comment">//如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">        Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">        <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="comment">//获取对象的构造方法或工厂方法</span></span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="comment">//如果没有构造方法且没有工厂方法</span></span><br><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//使用JDK的反射机制，判断要实例化的Bean是否是接口</span></span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//这里是一个匿名内置类，使用反射机制获取Bean的构造方法</span></span><br><span class="line">                        constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                                (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) () -&gt; clazz.getDeclaredConstructor());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        constructorToUse =    clazz.getDeclaredConstructor();</span><br><span class="line">                    &#125;</span><br><span class="line">                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> BeanUtils.<span class="title">instantiateClass</span><span class="params">(constructorToUse)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">        <span class="comment">//使用CGLIB来实例化对象</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">instantiateWithMethodInjection</span><span class="params">(bd, beanName, owner)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码分析，我们看到了如果 Bean 有方法被覆盖了，则使用 JDK 的反射机制进行实例化，否则，使用 CGLib 进行实例化。instantiateWithMethodInjection() 方 法 调 用SimpleInstantiationStrategy 的 子 类CGLibSubclassingInstantiationStrategy 使用 CGLib 来进行初始化，其源码如下：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用CGLIB进行Bean对象实例化</span></span><br><span class="line">    <span class="keyword">public</span> Object instantiate(@Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args) &#123;</span><br><span class="line">        <span class="comment">//创建代理子类</span></span><br><span class="line">        Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="built_in">this</span>.beanDefinition);</span><br><span class="line">        Object instance;</span><br><span class="line">        <span class="keyword">if</span> (ctor == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = BeanUtils.instantiateClass(subclass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());</span><br><span class="line">                instance = enhancedSubclassConstructor.<span class="keyword">new</span><span class="type">Instance</span>(args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">BeanInstantiationException</span>(<span class="built_in">this</span>.beanDefinition.getBeanClass(),</span><br><span class="line">                        <span class="string">"Failed to invoke constructor for CGLIB enhanced subclass ["</span> + subclass.getName() + <span class="string">"]"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// SPR-10785: set callbacks directly on the instance instead of in the</span></span><br><span class="line">        <span class="comment">// enhanced class (via the Enhancer) in order to avoid memory leaks.</span></span><br><span class="line">        Factory factory = (Factory) instance;</span><br><span class="line">        factory.setCallbacks(<span class="keyword">new</span> <span class="type">Callback</span>[] &#123;NoOp.INSTANCE,</span><br><span class="line">                <span class="keyword">new</span> <span class="type">LookupOverrideMethodInterceptor</span>(<span class="built_in">this</span>.beanDefinition, <span class="built_in">this</span>.owner),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">ReplaceOverrideMethodInterceptor</span>(<span class="built_in">this</span>.beanDefinition, <span class="built_in">this</span>.owner)&#125;);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; createEnhancedSubclass(RootBeanDefinition beanDefinition) &#123;</span><br><span class="line">        <span class="comment">//CGLIB中的类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> <span class="type">Enhancer</span>();</span><br><span class="line">        <span class="comment">//将Bean本身作为其基类</span></span><br><span class="line">        enhancer.setSuperclass(beanDefinition.getBeanClass());</span><br><span class="line">        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.owner instanceof ConfigurableBeanFactory) &#123;</span><br><span class="line">            ClassLoader cl = ((ConfigurableBeanFactory) <span class="built_in">this</span>.owner).getBeanClassLoader();</span><br><span class="line">            enhancer.setStrategy(<span class="keyword">new</span> <span class="type">ClassLoaderAwareGeneratorStrategy</span>(cl));</span><br><span class="line">        &#125;</span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="type">MethodOverrideCallbackFilter</span>(beanDefinition));</span><br><span class="line">        enhancer.setCallbackTypes(CALLBACK_TYPES);</span><br><span class="line">        <span class="comment">//使用CGLIB的createClass方法生成实例对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.createClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CGLib 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 Java 字节码的生成和转换功能。JDK 的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用 CGLib。</p>
<h4 id="准备依赖注入"><a href="#准备依赖注入" class="headerlink" title="准备依赖注入"></a>准备依赖注入</h4><p>在前面的分析中我们已经了解到 Bean 的依赖注入主要分为两个步骤，首先调用 createBeanInstance()方法生成 Bean 所包含的 Java 对象实例。然后，调用 populateBean()方法，对 Bean 属性的依赖注入进行处理。<br>上面我们已经分析了容器初始化生成 Bean 所包含的 Java 实例对象的过程，现在我们继续分析生成对象后，Spring IOC 容器是如何将 Bean 的属性依赖关系注入 Bean 实例对象中并设置好的，回到AbstractAutowireCapableBeanFactory 的 populateBean()方法，对属性依赖注入的代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Bean属性设置到生成的实例对象上</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> populateBean(<span class="keyword">String</span> beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">    <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">    <span class="comment">// to support styles of field injection.</span></span><br><span class="line">    <span class="built_in">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对依赖注入处理，首先处理autowiring自动装配的依赖注入</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="comment">//根据Bean名称进行autowiring自动装配处理</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="comment">//根据Bean类型进行autowiring自动装配处理</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对非autowiring的属性进行依赖注入处理</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="built_in">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">            checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//对属性进行注入</span></span><br><span class="line">        applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析并注入依赖属性的过程</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> applyPropertyValues(<span class="keyword">String</span> beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装属性值</span></span><br><span class="line">    MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">            <span class="comment">//设置安全上下文，JDK安全机制</span></span><br><span class="line">            ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">        mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">        <span class="comment">//属性值已经转换</span></span><br><span class="line">        <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">            <span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//为实例化对象设置属性值</span></span><br><span class="line">                bw.setPropertyValues(mpvs);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                        mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取属性值对象的原始类型值</span></span><br><span class="line">        original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户自定义的类型转换</span></span><br><span class="line">    TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象的实际值</span></span><br><span class="line">    BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中</span></span><br><span class="line">    List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">        <span class="comment">//属性值不需要转换</span></span><br><span class="line">        <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">            deepCopy.<span class="built_in">add</span>(pv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//属性值需要转换</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> propertyName = pv.getName();</span><br><span class="line">            <span class="comment">//原始的属性值，即转换之前的属性值</span></span><br><span class="line">            <span class="keyword">Object</span> originalValue = pv.getValue();</span><br><span class="line">            <span class="comment">//转换属性值，例如将引用转换为IOC容器中实例化对象引用</span></span><br><span class="line">            <span class="keyword">Object</span> resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">            <span class="comment">//转换之后的属性值</span></span><br><span class="line">            <span class="keyword">Object</span> convertedValue = resolvedValue;</span><br><span class="line">            <span class="comment">//属性值是否可以转换</span></span><br><span class="line">            <span class="built_in">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">            <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">                <span class="comment">//使用用户自定义的类型转换器转换属性值</span></span><br><span class="line">                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">            <span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">            <span class="comment">//存储转换后的属性值，避免每次属性注入时的转换工作</span></span><br><span class="line">            <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">                    <span class="comment">//设置属性转换之后的值</span></span><br><span class="line">                    pv.setConvertedValue(convertedValue);</span><br><span class="line">                &#125;</span><br><span class="line">                deepCopy.<span class="built_in">add</span>(pv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是</span></span><br><span class="line">            <span class="comment">//动态生成的字符串，且属性的原始值不是集合或者数组类型</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">                    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">                    !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">                pv.setConvertedValue(convertedValue);</span><br><span class="line">                <span class="comment">//重新封装属性的值</span></span><br><span class="line">                deepCopy.<span class="built_in">add</span>(pv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">                deepCopy.<span class="built_in">add</span>(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">        <span class="comment">//标记属性值已经转换过</span></span><br><span class="line">        mpvs.setConverted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">    <span class="comment">//进行属性依赖注入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析上述代码，我们可以看出，对属性的注入过程分以下两种情况：<br>1)、属性值类型不需要强制转换时，不需要解析属性值，直接准备进行依赖注入。<br>2)、属性值需要进行类型强制转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。<br>对属性值的解析是在 BeanDefinitionValueResolver 类中的 resolveValueIfNecessary()方法中进行的，对属性值的依赖注入是通过 bw.setPropertyValues()方法实现的，在分析属性值的依赖注入之前，我们先分析一下对属性值的解析过程</p>
<h4 id="解析属性注入规则"><a href="#解析属性注入规则" class="headerlink" title="解析属性注入规则"></a>解析属性注入规则</h4><p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary()方法实现。</p>
<p>Spring IOC 容器是如何将属性的值注入到 Bean 实例对象中去的：<br>1)、对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。</p>
<p>2)、对于非集合类型的属性，大量使用了 JDK 的反射机制，通过属性的 getter()方法获取指定属性注入以前的值，同时调用属性的 setter()方法为属性设置注入后的值。看到这里相信很多人都明白了 Spring的 setter()注入原理</p>
<p>Spring DI运行时序图<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1624288-20190628135317957-1069467007.png" alt="image"></p>
<h2 id="如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？"><a href="#如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？" class="headerlink" title="如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？"></a>如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？</h2><p> 分布式中间件，我自己了解的就有</p>
<ul>
<li>seata</li>
<li>tx-lcn</li>
<li>easyTransaction</li>
<li>serviceComb</li>
</ul>
<h2 id="Dubbo有了解没有？"><a href="#Dubbo有了解没有？" class="headerlink" title="Dubbo有了解没有？"></a>Dubbo有了解没有？</h2><p>阿里开源的一款分布式框架。</p>
<h2 id="Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启-关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？"><a href="#Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启-关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？" class="headerlink" title="Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启/关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？"></a>Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启/关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？</h2><p>在一个分布式系统中，必然会有部分系统的调用会失败。Hystrix是一个通过添加超时容错和失败容错逻辑来帮助你控制这些分布式系统的交互。Hystrix通过隔离服务之间的访问，阻止他们之间的级联故障以及提供后背选项来实现这些，所有新而这些都用来提高系统的整体弹性。</p>
<p> Hystrix被设计用来解决一下几个方面</p>
<ul>
<li>通过第三方（一般来源网络）的调用，给与保护和控制延迟和失败。</li>
<li>在复杂的分布式系统中复制级联失败。</li>
<li>快速失败和修复。</li>
<li>在可能的情况下，回滚挥着优雅的失败。</li>
<li>实现几乎实时监控，警报和操作控制。</li>
</ul>
<p>复杂的分布式体系结构中的应用程序具有许多依赖关系，每个依赖关系都会在某些时候不可避免的失败。如果主机应用程序未与这些外部的故障隔离，那么可能会被这些故障拖垮。</p>
<p>例如:一个依赖30个SOA服务的系统,每个服务99.99%可用。</p>
<p>99.99%的30次方 ≈ 99.7%</p>
<p>0.3% 意味着一亿次请求 会有 3,000,00次失败</p>
<p>换算成时间大约每月有2个小时服务不稳定.</p>
<p>随着服务依赖数量的变多，服务不稳定的概率会成指数性提高.<br>而实际中可能更糟糕。</p>
<h3 id="Hystrix设计模式"><a href="#Hystrix设计模式" class="headerlink" title="Hystrix设计模式"></a>Hystrix设计模式</h3><p>设计详解（命令模式）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180719101351962.png" alt="image"><br>流程图<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/hystrix-command-flow-chart.png" alt="image"><br>流程说明</p>
<ol>
<li>构造一个HystrixCommand或者HystrixObserverCommand对象，把需要调用的依赖放在run()中</li>
<li>执行execute/queue做同步或者异步执行</li>
<li>是否做了缓存</li>
<li>熔断是否打开</li>
<li>线程池/队列/信号量是否满了</li>
<li>调用run（）或者construct（）</li>
<li>计算熔断健康度（成功，失败，拒绝，超时）的数据，上报给熔断器，用于统计从而判断熔断器状态，可以根据这些数据来决定是否进行熔断，例如：错误率在80%以上，接口等待超过预定的时间等。</li>
<li>获取Fallback，如果fallback失败，系统报错，所以要尽量防止fallback报错，当然也可以在fallback上加上一层fallback</li>
<li>返回执行结果</li>
</ol>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h4><p>下图显示了HystrixCommand或者HystrixObserverCommand如何与HystrixCircuitBreaker及其逻辑和决策流程。包括计数器在断路器中的行为方式。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/hystrix-command-flow-chart.png" alt="image"><br>熔断行为</p>
<p>断路器打开还是关闭的步骤如下</p>
<ol>
<li>假定请求的量超过预定的阈值（circuitBreakerRequestVolumeThreshold）</li>
<li>再假定错误百分比超过了设定的百分比（circuitBreakerErrorThresholdPercentage）</li>
<li>断路器会从close状态到open状态</li>
<li>当打开的状态，会短路所有针对该断路器的请求</li>
<li>过了一定时间（circuitBreakerSleepWindowInMilliseconds（短路超过一定时间会重新去请求）），下一个请求将通过，不会被短路（当前是half-open状态）。如果这个请求失败了，则断路器在睡眠窗口期间返回open状态，如果请求成功，则断路器返回close状态，并重新回到第一步逻辑判断。</li>
</ol>
<h4 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h4><p>Hystrix使用璧仓模式来隔离彼此的依赖关系，并限制对其中任何一个的并发访问。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180719101939418.png" alt="image"></p>
<h3 id="线程和线程池"><a href="#线程和线程池" class="headerlink" title="线程和线程池"></a>线程和线程池</h3><p>客户端（第三方，网络调用等）依赖和请求线程运行在不同的线程上，这个将他们从调用线程隔离开来，这样调用者就可以从一个耗时太长的依赖中隔离。如下图所示，也可以为不同的请求开启不同的线程池，彼此之间不相互干扰。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/circuit-breaker-1280.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/isolation-options-12801.png" alt="image"><br>（注：上图右边表示的是信号量模式）</p>
<h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p>1、线程隔离的好处：</p>
<ul>
<li>整个应用的即是在客户端调用失效的情况下也能健康的运行，线程池能够保证这个线程下面的失效不会影响应用其他部分的运行</li>
<li>当失效的客户端调用回复的时候，这个线程池也会被清理并且应用会立马回复健康，比tomcat那种长时间的恢复要好很多</li>
</ul>
<p>简而言之，线程隔离能够允许在不引起中断的情况下优雅的处理第三方调用的各种问题。</p>
<p>2、线程隔离的缺点</p>
<ul>
<li>主要缺点是增加了上下文切换的开销，每个明亮的执行都涉及到队列，调度和上下文切换。不过NetFix在设计这个系统的时候，已经决定接受这笔开销，以换取他的好处。</li>
</ul>
<h4 id="信号量隔离"><a href="#信号量隔离" class="headerlink" title="信号量隔离"></a>信号量隔离</h4><p>你可以使用信号量（或者计数器）来限制当前依赖调用的并发数，而不是使用线程池或者队列。如果客户端是可信的，且能快速返回，可以使用信号量来代替线程隔离，降低开销。信号量的大小可以动态调节，线程池却不行。</p>
<p>HystrixCommand和HystrixObserverCommand提供信号量隔离在下面两个地方：</p>
<ul>
<li>Fallback：当Hystrix检索fallback的时候，他心总是调用tomcat线程上执行此操作</li>
<li>如果你设置execution.isolation.strategy为SEMAPHORE的时候，Hystrix会使用信号量代替线程池去限制当前调用Command的并发数。</li>
</ul>
<h4 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h4><p>设置某个时间内的请求，合并为一个发送，例如：id和ids参数</p>
<h4 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h4><h4 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h4><p>Hystrix仪表盘</p>
<p>主要用来实时监控Hystrix的各项指标信息。通过Hystrix DashBoard反馈的实时信息，可以帮助我们快速防线系统中存在的问题，从而及时地采取对应措施。</p>
<p>开启仪表盘</p>
<p>1、在服务实例中新增spring-boot-starter-actuator，监控模块已开启监控相关的端点，并且映入断路器依赖：spring-cloud-starter-hystrix</p>
<p>2、确保在服务实例的主类中已经使用了@EnableCircuitBreaker注解，开启了断路器功能。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018071910300525.png" alt="image"></p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">MyHystrixCommand</span><span class="params">(String groupKey)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey)));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function">String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//实际调用外部的地方</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"reality invoke。"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function">String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//run抛出异常，或者调用超时之后调用fallback</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"invoke failed。"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      MyHystrixCommand hystrixCommand = <span class="keyword">new</span> MyHystrixCommand(<span class="string">"myCommand"</span>);</span><br><span class="line">      System.out.println(hystrixCommand.execute());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">reality invoke。</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解方式</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"get-demo1-test"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>, groupKey = <span class="string">"userGroup"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">getDemo1Name</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   <span class="comment">//测试重试机制</span></span><br><span class="line">   <span class="keyword">int</span> sleepTime = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>);</span><br><span class="line">   Thread.sleep(sleepTime);</span><br><span class="line">   <span class="function"><span class="keyword">return</span> demo1Service.<span class="title">getAppName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">fallback</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"erroe: "</span> + t.getMessage());</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>几个主要的配置信息：在构造方法中通过Setter设置</p>
<p> 1.1、execution.isolation. thread.timeoutinMilliseconds: 该属性用来配 置HystrixCommand执行的超时时间， 单位为毫秒。当HystrixCommand执行 时间超过该配置值之后， Hystrix会将该执行命令标记为TIMEOUT并进入服务降级 处理逻辑。默认值1000</p>
<p> 1.2、execution.isolation.semaphore.maxConcurrentRequests:当HystrixCommand的隔离策略使用信号量的时候，该属性用来配置信号量的大小（并发请求数）。 当最大并发请求数达到该设置值时， 后续的请求将会被拒绝。默认值10</p>
<p> 1.3、circuitBreaker.requestVolumeThreshold该属性设置滚动窗口中将使断路器跳闸的最小请求数量，默认值：20</p>
<p>1.4、circuitBreaker.sleepWindowInMilliseconds 断路器跳闸后，在此值的时间的内，hystrix会拒绝新的请求，只有过了这个时间断路器才会打开闸门</p>
<p>默认值：5000</p>
<p>1.5、circuitBreaker.errorThresholdPercentage 设置失败百分比的阈值。如果失败比率超过这个值，则断路器跳闸并且进入fallback逻辑</p>
<p>默认值：50</p>
<p>1.6、metrics.rollingStats.timeInMilliseconds 滚动窗口时间大小，默认10s</p>
<h2 id="Feign了解多少说多少？"><a href="#Feign了解多少说多少？" class="headerlink" title="Feign了解多少说多少？"></a>Feign了解多少说多少？</h2><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>feign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。Spring Cloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端。</p>
<p>因为feign底层是使用了ribbon作为负载均衡的客户端，而ribbon的负载均衡也是依赖于eureka 获得各个服务的地址，所以要引入eureka-client。</p>
<h4 id="Feign原理"><a href="#Feign原理" class="headerlink" title="Feign原理"></a>Feign原理</h4><ul>
<li>启动时，程序会进行包扫描，扫描所有包下所有@FeignClient注解的类，并将这些类注入到spring的IOC容器中。当定义的Feign中的接口被调用时，通过JDK的动态代理来生成RequestTemplate。</li>
<li>RequestTemplate中包含请求的所有信息，如请求参数，请求URL等。</li>
<li>RequestTemplate声场Request，然后将Request交给client处理，这个client默认是JDK的HTTPUrlConnection，也可以是OKhttp、Apache的HTTPClient等。</li>
<li>最后client封装成LoadBaLanceClient，结合ribbon负载均衡地发起调用。</li>
</ul>
<h2 id="Zookeeper，了解多少说多少？"><a href="#Zookeeper，了解多少说多少？" class="headerlink" title="Zookeeper，了解多少说多少？"></a>Zookeeper，了解多少说多少？</h2><p>ZooKeeper是一个分布式的开源协调服务，用于分布式应用程序。它公开了一组简单的原子操作，分布式应用程序可以构建这些原子操作，以实现更高级别的服务，以实现同步，配置维护以及组和命名。<br>它的设计易于编程，并使用在熟悉的文件系统目录树结构之后设计的数据模型。它运行在Java中，并且对Java和C都有绑定。</p>
<p>周所周知，协调服务是很难做到的。它们特别容易出现诸如竞态条件和死锁等错误。ZooKeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。</p>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>Zookeeper是简单的。Zookeeper允许分布式进程之间彼此协调，通过一个共享的分级命名空间，它非常像标准的文件系统。</p>
<p>ZooKeeper实现非常重视高性能，高可用性，严格有序的访问。ZooKeeper的性能方面意味着它可以在大型分布式系统中使用。<br>可靠性方面使其不会成为单点故障。严格的排序意味着可以在客户端实现复杂的同步原子操作。</p>
<p>Zookeeper是可复制的。 与它协调的分布式进程一样，ZooKeeper本身也可以在称为集合的一组主机上进行复制。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/12540413-62c81551958254dc.png" alt="image"></p>
<p>组成ZooKeeper服务的服务器必须彼此了解。它们保持状态的内存映像，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper服务就可用。<br>客户端连接到单个ZooKeeper服务器。客户端维护一个TCP连接，通过它发送请求，获取响应，获取观看事件并发送心跳。如果与服务器的TCP连接中断，则客户端将连接到其他服务器。</p>
<p><strong>Zookeeper是有序的</strong>。 ZooKeeper使用反映所有ZooKeeper事务顺序的数字标记每个更新。后续操作可以使用该顺序来实现更高级别的抽象，例如同步原子操作。</p>
<p><strong>Zookeeper是非常快的</strong>。 它在“读取主导”工作负载中速度特别快。ZooKeeper应用程序在数千台计算机上运行，并且在读取比写入更常见的情况下表现最佳，比率大约为10：1。</p>
<h3 id="数据模型和分层名称空间"><a href="#数据模型和分层名称空间" class="headerlink" title="数据模型和分层名称空间"></a>数据模型和分层名称空间</h3><p>ZooKeeper提供的名称空间非常类似于标准文件系统。名称是由斜线（/）分隔的一系列路径元素。ZooKeeper名称空间中的每个节点都由一个路径标识。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/12540413-a229d45b54a02423.png" alt="image"></p>
<h4 id="节点和临时节点"><a href="#节点和临时节点" class="headerlink" title="节点和临时节点"></a>节点和临时节点</h4><p>与标准文件系统不同的是，ZooKeeper命名空间中的每个节点都可以拥有与其相关的数据以及子级。这就像拥有一个允许文件也是目录的文件系统。（ZooKeeper旨在存储协调数据：状态信息，配置，位置信息等，因此存储在每个节点的数据通常很小，在字节到千字节范围内。）我们使用术语 znode来表明我们正在谈论ZooKeeper数据节点。</p>
<p>Znodes维护一个stat结构，包括数据更改，ACL更改和时间戳的版本号，以允许缓存验证和协调更新。每次znode的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也会收到数据的版本。</p>
<p>存储在名称空间中每个节点上的数据是以原子方式读取和写入的。读取获取与znode关联的所有数据字节，写入将替换所有数据。每个节点都有一个访问控制列表（ACL），限制谁可以做什么。</p>
<p>ZooKeeper也有临时节点的概念。只要创建znode的会话处于活动状态，就会存在这些znode。当会话结束时，znode被删除。</p>
<h4 id="有条件的更新和监视"><a href="#有条件的更新和监视" class="headerlink" title="有条件的更新和监视"></a>有条件的更新和监视</h4><p>ZooKeeper支持观察的概念。客户可以在znode上设置观察器。当znode更改时，将触发并删除观察器。</p>
<p>当观察被触发时，客户端收到一个数据包，说明znode已经改变。如果客户端和其中一个Zoo Keeper服务器之间的连接断开，客户端将收到本地通知。</p>
<h4 id="担保"><a href="#担保" class="headerlink" title="担保"></a>担保</h4><p>ZooKeeper非常快速且非常简单。但是，由于其目标是构建更复杂的服务（如同步）的基础，因此它提供了一系列保证。这些是：</p>
<ul>
<li>顺序一致性 - 客户端的更新将按照它们发送的顺序进行应用。</li>
<li>原子性 - 更新成功或失败。没有部分结果。</li>
<li>单系统映像 - 无论服务器连接到哪个服务器，客户端都会看到相同的服务视图。</li>
<li>可靠性 - 一旦应用更新，它将一直持续到客户覆盖更新为止。</li>
<li>及时性 - 系统的客户视图保证在特定时间范围内是最新的。</li>
</ul>
<h4 id="简单的API"><a href="#简单的API" class="headerlink" title="简单的API"></a>简单的API</h4><p>ZooKeeper的设计目标之一是提供一个非常简单的编程接口。因此，它仅支持以下操作：</p>
<ul>
<li>创建——在树中的某个位置创建一个节点</li>
<li>删除——删除节点</li>
<li>存在——测试某个位置是否存在节点</li>
<li>获取数据——从节点读取数据</li>
<li>设定数据——将数据写入节点</li>
<li>得到子节点——检索节点的子节点列表</li>
<li>同步——等待数据传播</li>
</ul>
<h3 id="能用zookeeper做什么"><a href="#能用zookeeper做什么" class="headerlink" title="能用zookeeper做什么"></a>能用zookeeper做什么</h3><p>1、 命名服务</p>
<p>这个似乎最简单，在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现，不见不散了。</p>
<p>2、 配置管理</p>
<p>程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。好吧，现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。</p>
<p> 3、 集群管理</p>
<p>所谓集群管理无在乎两点：是否有机器退出和加入、选举master。</p>
<p>对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。新机器加入 也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了。</p>
<p>对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p>
<p>4、  分布式锁</p>
<p>有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p>
<p>对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /<code>distribute_lock</code> 节点，最终成功创建的那个客户端也即拥有了这把锁。厕所有言：来也冲冲，去也冲冲，用完删除掉自己创建的distribute_lock 节点就释放出锁。</p>
<p>对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p>
<p>5、队列管理</p>
<p>两种类型的队列：</p>
<p>1、 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</p>
<p>2、队列按照 FIFO 方式进行入队和出队操作。</p>
<p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p>
<p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。</p>
<p>终于了解完我们能用zookeeper做什么了，可是作为一个程序员，我们总是想狂热了解zookeeper是如何做到这一点的，单点维护一个文件系统没有什么难度，可是如果是一个集群维护一个文件系统保持数据的一致性就非常困难了。</p>
<h3 id="分布式与数据复制"><a href="#分布式与数据复制" class="headerlink" title="分布式与数据复制"></a>分布式与数据复制</h3><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：</p>
<p>1、 容错<br>一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；</p>
<p>2、提高系统的扩展能力<br>把负载分布到多个节点上，或者增加节点来提高系统的负载能力；</p>
<p>3、提高性能<br>让客户端本地访问就近的节点，提高用户访问速度。</p>
<p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p>
<p>1、写主(WriteMaster)<br>对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；</p>
<p>2、写任意(Write Any)<br>对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p>
<p>对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<p>我们关注的重点还是在如何保证数据在集群所有机器的一致性，这就涉及到paxos算法。</p>
<h3 id="数据一致性与paxos算法"><a href="#数据一致性与paxos算法" class="headerlink" title="数据一致性与paxos算法"></a>数据一致性与paxos算法</h3><p>据说Paxos算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：</p>
<p>在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。</p>
<p>Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个全局写队列，所有写操作都必 须放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。没错，就是这样，可是如果master挂了呢。</p>
<p>Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会 被批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排 序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己 数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。</p>
<h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><h5 id="角色（核心就3个角色）"><a href="#角色（核心就3个角色）" class="headerlink" title="角色（核心就3个角色）"></a>角色（核心就3个角色）</h5><p>Client：客户端，发起请求并等待返回。<br>Proposer（提案者）：处理客户端请求，将客户端的请求发送到集群中，以便决定这个值是否可以被批准。<br>Acceptor（接受者）：负责处理接收到的提议，他们的回复就是一次投票。会存储一些状态来决定是否接收一个值。<br>Learner（学习者）：当有同一个value的协议被超过一半的Acceptor采纳并发送消息给Learner时，Learner采纳该协议值。<br>Leader：一个特殊的Proposer。</p>
<h5 id="Basic-Paxos算法"><a href="#Basic-Paxos算法" class="headerlink" title="Basic-Paxos算法"></a>Basic-Paxos算法</h5><p>核心实现Paxos Instance主要包括两个阶段:</p>
<p>准备阶段(prepare phase)和提议阶段(accept phase)</p>
<p>简单来说，Basic Paxos 是一个经典两阶段提交（2PC）</p>
<p>第一阶段：</p>
<ul>
<li>1a prepare 准备: proposer向acceptors提出一个协议，这里的协议就是期望的“一致性内容”</li>
<li>1a promise 承诺: acceptor承诺只接收最大协议号的协议（包括prepare和accept），并拒绝比当前协议号N小的协议，回复proposer之前接收的所有协议值。如果当前协议号N比之前都小，那么回复拒绝。</li>
</ul>
<p>第二阶段：</p>
<ul>
<li>2a Accept Request 发起“accept”请求：proposer收到acceptor反馈的足够的承诺后，给协议设最大值，如果没回复，随便设置一个值。发送”accept”请求给选定值的acceptors.</li>
<li>2b Accepted: acceptor接受协议（该acceptor之前没有承诺过大于该协议号的协议），并通知给proposer和learner</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170519183209291-1684980050.png" alt="image"><br>其中prepare阶段的作用，如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170519173152510-2089061877.png" alt="image"></p>
<p>1.S1首先发起accept(1,red)，并在S1,S2和S3达成多数派，red在S1，S2，S3上持久化</p>
<p>2.随 后S5发起accept(5,blue)，在S3，S4和S5达成多数派，blue在S<br>3，S4和S5持久化</p>
<p>3.最后的结果是，S1和S2的值是red，而S4和S5的值是blue，s3存在异议，red覆盖了blue？</p>
<p>解决方案：</p>
<ul>
<li>将提议进行排序，可以为每个提议赋予一个唯一的ID，规定这个ID越大越新，很明显（5，blue）和（1，red），5比1大,所以保留blue</li>
<li>采用两阶段方法，拒绝旧提议。</li>
</ul>
<h5 id="Muti-Paxos算法"><a href="#Muti-Paxos算法" class="headerlink" title="Muti-Paxos算法"></a>Muti-Paxos算法</h5><p>很多文章有误解说Muti-Paxos是一阶段提交，那是仅限于leader稳定时。刚选出来一个新的leader时，依然是二阶段提交如下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170522174941023-1628898506.png" alt="image"><br>如果leader稳定，不需要prepare和promise步骤，如下图（图中Proposer就是一个Leader）：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170522175104867-87240999.png" alt="image"><br>Multi Paxos中leader用于避免活锁(例如1个leader,4个Proposer,2个提议A，2个提议B不能达成一致，导致活锁)，但leader的存在会带来其他问题，一是如何选举和保持唯一leader(虽然无leader或多leader不影响一致性，但影响决议进程progress)，二是充当leader的节点会承担更多压力，如何均衡节点的负载。Mencius[1]提出节点轮流担任leader，以达到均衡负载的目的；租约(lease)可以帮助实现唯一leader，但leader故障情况下可导致服务短期不可用。</p>
<h5 id="Muti-Paxos在google-chubby中的应用"><a href="#Muti-Paxos在google-chubby中的应用" class="headerlink" title="Muti-Paxos在google chubby中的应用"></a>Muti-Paxos在google chubby中的应用</h5><p>Google Chubby是一个高可用分布式锁服务，被设计成一个需要访问中心化节点的分布式锁服务。本文只分析chubby服务端的实现。</p>
<p> Chubby服务端的基本架构大致分为三层</p>
<p>　　① 最底层是容错日志系统（Fault-Tolerant Log），通过Paxos算法能够保证集群所有机器上的日志完全一致，同时具备较好的容错性。</p>
<p>　　② 日志层之上是Key-Value类型的容错数据库（Fault-Tolerant DB），其通过下层的日志来保证一致性和容错性。</p>
<p>　　③ 存储层之上的就是Chubby对外提供的分布式锁服务和小文件存储服务。<br>　　<img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170523192819976-189903080.png" alt="image"><br>Paxos算法用于保证集群内各个副本节点的日志能够保持一致，Chubby事务日志（Transaction Log）中的每一个Value对应Paxos算法中的一个Instance（对应Proposer），由于Chubby需要对外提供不断的服务，因此事务日志会无限增长，于是在整个Chubby运行过程中，会存在多个Paxos Instance，同时，Chubby会为每个Paxos Instance都按序分配一个全局唯一的Instance编号，并将其顺序写入到事务日志中去。</p>
<p>　　在Paxos中，每一个Paxos Instance都需要进行一轮或多轮的Prepare-&gt;Promise-&gt;Propose-&gt;Accept这样完整的二阶段请求过程来完成对一个提议值的选定，为了保证正确性的前提下尽可能地提高算法运行性能，可以让多个Instance共用一套序号分配机制，并将Prepare-&gt;Promise合并为一个阶段。具体做法如下：</p>
<p>　　① 当某个副本节点通过选举成为Master后，就会使用新分配的编号N来广播一个Prepare消息，该Prepare消息会被所有未达成一致的Instance和目前还未开始的Instance共用。</p>
<p>　　② 当Acceptor接收到Prepare消息后，必须对多个Instance同时做出回应，这通常可以通过将反馈信息封装在一个数据包中来实现，假设最多允许K个Instance同时进行提议值的选定，那么：</p>
<ul>
<li>当前之多存在K个未达成一致的Instance，将这些未决的Instance各自最后接受的提议值封装进一个数据包，并作为Promise消息返回。</li>
<li>同时，判断N是否大于当前Acceptor的highestPromisedNum值（当前已经接受的最大的提议编号值），如果大于，那么就标记这些未决Instance和所有未来的Instance的highestPromisedNum的值为N，这样，这些未决Instance和所有未来Instance都不能再接受任何编号小于N的提议。</li>
</ul>
<p>　　③ Master对所有未决Instance和所有未来Instance分别执行Propose-&gt;Accept阶段的处理，如果Master能够一直稳定运行的话，那么在接下来的算法运行过程中，就不再需要进行Prepare-&gt;Promise处理了。但是，一旦Master发现Acceptor返回了一个Reject消息，说明集群中存在另一个Master并且试图使用更大的提议编号发送了Prepare消息，此时，当前Master就需要重新分配新的提议编号并再次进行Prepare-&gt;Promise阶段的处理。</p>
<p>　　可见chubby就是一个典型的Muti-Paxos算法应用，在Master稳定运行的情况下，只需要使用同一个编号来依次执行每一个Instance的Promise-&gt;Accept阶段处理。</p>
<h2 id="sentinel，了解多少说多少？"><a href="#sentinel，了解多少说多少？" class="headerlink" title="sentinel，了解多少说多少？"></a>sentinel，了解多少说多少？</h2><p>Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。</p>
<p>Sentinel 和之前常用的熔断降级库 Netflix Hystrix 有什么异同呢？Sentinel官网有一个对比的文章，这里摘抄一个总结的表格</p>
<table>
<thead>
<tr>
<th>对比内容</th>
<th>Sentinel</th>
<th>Hystrix</th>
</tr>
</thead>
<tbody>
<tr>
<td>隔离策略</td>
<td>信号量隔离</td>
<td>线程池隔离/信号量隔离</td>
</tr>
<tr>
<td>熔断降级策略</td>
<td>基于响应时间或失败比率</td>
<td>基于失败比率</td>
</tr>
<tr>
<td>实时指标实现</td>
<td>滑动窗口</td>
<td>滑动窗口（基于 RxJava）</td>
</tr>
<tr>
<td>规则配置</td>
<td>支持多种数据源</td>
<td>支持多种数据源</td>
</tr>
<tr>
<td>扩展性</td>
<td>多个扩展点</td>
<td>插件的形式</td>
</tr>
<tr>
<td>基于注解的支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>限流</td>
<td>基于 QPS，支持基于调用关系的限流</td>
<td>不支持</td>
</tr>
<tr>
<td>流量整形</td>
<td>支持慢启动、匀速器模式</td>
<td>不支持</td>
</tr>
<tr>
<td>系统负载保护</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>控制台</td>
<td>开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td>不完善</td>
</tr>
<tr>
<td>常见框架的适配</td>
<td>Servlet、Spring Cloud、Dubbo、gRPC 等</td>
<td>Servlet、Spring Cloud Netflix</td>
</tr>
</tbody>
</table>
<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>感兴趣的可以看这篇<a href="https://mp.weixin.qq.com/s/g2hyp9CquEAvTe8QmPO-3g/" target="_blank" rel="noopener">文章</a></p>
<h2 id="Spring-Cloud-Alibaba，了解多少说多少？"><a href="#Spring-Cloud-Alibaba，了解多少说多少？" class="headerlink" title="Spring Cloud Alibaba，了解多少说多少？"></a>Spring Cloud Alibaba，了解多少说多少？</h2><p>Spring Cloud 是基于 Spring Boot 设计的一套微服务规范，并增强了应用上下文。Spring Cloud Alibaba 采用阿里中间件作为基础，实现了 Spring Cloud 的微服务规范。</p>
<h2 id="对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？"><a href="#对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？" class="headerlink" title="对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？"></a>对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？</h2><p>事务拥有以下四个特性，习惯上被称为 ACID 特性：</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到（这层语义也有说应该属于原子性）。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。</li>
</ul>
<h3 id="常见分布式事务模型-ACID-实现分析"><a href="#常见分布式事务模型-ACID-实现分析" class="headerlink" title="常见分布式事务模型 ACID 实现分析"></a>常见分布式事务模型 ACID 实现分析</h3><h4 id="X-Open-XA-协议"><a href="#X-Open-XA-协议" class="headerlink" title="X/Open XA 协议"></a>X/Open XA 协议</h4><p>最早的分布式事务模型是 X/Open 国际联盟提出的 X/Open Distributed Transaction Processing（DTP）模型，也就是大家常说的 X/Open XA 协议，简称XA 协议。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG265.png" alt="image"><br>DTP 模型中包含一个全局事务管理器（TM，Transaction Manager）和多个资源管理器（RM，Resource Manager）。全局事务管理器负责管理全局事务状态与参与的资源，协同资源一起提交或回滚；资源管理器则负责具体的资源操作。</p>
<p>XA 协议描述了 TM 与 RM 之间的接口，允许多个资源在同一分布式事务中访问。</p>
<p>基于 DTP 模型的分布式事务流程大致如下：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG266.png" alt="image"></p>
<ol>
<li>应用程序（AP，Application）向 TM 申请开始一个全局事务。</li>
<li>针对要操作的 RM，AP 会先向 TM 注册（TM 负责记录 AP 操作过哪些 RM，即分支事务），TM 通过 XA 接口函数通知相应 RM 开启分布式事务的子事务，接着 AP 就可以对该 RM 管理的资源进行操作。</li>
<li>当 AP 对所有 RM 操作完毕后，AP 根据执行情况通知 TM 提交或回滚该全局事务，TM 通过 XA 接口函数通知各 RM 完成操作。TM 会先要求各个 RM 做预提交，所有 RM 返回成功后，再要求各 RM 做正式提交，XA 协议要求，一旦 RM 预提交成功，则后续的正式提交也必须能成功；如果任意一个 RM 预提交失败，则 TM 通知各 RM 回滚。</li>
<li>所有 RM 提交或回滚完成后，全局事务结束。</li>
</ol>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>XA 协议使用 2PC（Two Phase Commit，两阶段提交）原子提交协议来保证分布式事务原子性。</p>
<p>两阶段提交是指将提交过程分为两个阶段，即准备阶段（投票阶段）和提交阶段（执行阶段）：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG267.png" alt="image"></p>
<ul>
<li>准备阶段</li>
</ul>
<p>TM 向每个 RM 发送准备消息。如果 RM 的本地事务操作执行成功，则返回成功；如果 RM 的本地事务操作执行失败，则返回失败。</p>
<ul>
<li>提交阶段</li>
</ul>
<p>如果 TM 收到了所有 RM 回复的成功消息，则向每个 RM 发送提交消息；否则发送回滚消息；RM 根据 TM 的指令执行提交或者回滚本地事务操作，释放所有事务处理过程中使用的锁资源。</p>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>XA 协议中没有描述如何实现分布式事务的隔离性，但是 XA 协议要求DTP 模型中的每个 RM 都要实现本地事务，也就是说，基于 XA 协议实现的分布式事务的隔离性是由每个 RM 本地事务的隔离性来保证的，当一个分布式事务的所有子事务都是隔离的，那么这个分布式事务天然的就实现了隔离性。</p>
<p>以 MySQL 来举例，MySQL 使用 2PL（Two-Phase Locking，两阶段锁）机制来控制本地事务的并发，保证隔离性。2PL 与 2PC 类似，也是将锁操作分为加锁和解锁两个阶段，并且保证两个阶段完全不相交。加锁阶段，只加锁，不放锁。解锁阶段，只放锁，不加锁。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG268.png" alt="image"><br>如上图所示，在一个本地事务中，每执行一条更新操作之前，都会先获取对应的锁资源，只有获取锁资源成功才会执行该操作，并且一旦获取了锁资源就会持有该锁资源直到本事务执行结束。</p>
<p>MySQL 通过这种 2PL 机制，可以保证在本地事务执行过程中，其他并发事务不能操作相同资源，从而实现了事务隔离。</p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><p>前面提到一致性有两层语义，一层是确保事务执行结束后，数据库从一个一致状态转变为另一个一致状态。另一层语义是事务执行过程中的中间状态不能被观察到。</p>
<p>前一层语义的实现很简单，通过原子性、隔离性以及 RM 自身一致性的实现就可以保证。至于后一层语义，我们先来看看单个 RM 上的本地事务是怎么实现的。还是以 MySQL 举例，MySQL 通过 MVCC（Multi Version Concurrency Control，多版本并发控制）机制，为每个一致性状态生成快照（Snapshot），每个事务看到的都是各Snapshot对应的一致性状态，从而也就保证了本地事务的中间状态不会被观察到。</p>
<p>虽然单个 RM 上实现了Snapshot，但是在分布式应用架构下，会遇到什么问题呢？<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG269.png" alt="image"><br>如上图所示，在 RM1 的本地子事务提交完毕到 RM2 的本地子事务提交完毕之间，只能读到 RM1 上子事务执行的内容，读不到 RM2 上的子事务。也就是说，虽然在单个 RM 上的本地事务是一致的，但是从全局来看，一个全局事务执行过程的中间状态被观察到了，全局一致性就被破坏了。</p>
<p>XA 协议并没有定义怎么实现全局的 Snapshot，像 MySQL 官方文档里就建议使用串行化的隔离级别来保证分布式事务一致性：</p>
<p>“As with nondistributed transactions, SERIALIZABLE may be preferred if your applications are sensitive to read phenomena. REPEATABLE READ may not be sufficient for distributed transactions.”（对于分布式事务来说，可重复读隔离级别不足以保证事务一致性，如果你的程序有全局一致性读要求，可以考虑串行化隔离级别.）</p>
<p>当然，由于串行化隔离级别的性能较差，所以很多分布式数据库都自己实现了分布式 MVCC 机制来提供全局的一致性读。一个基本思路是用一个集中式或者逻辑上单调递增的东西来控制生成全局 Snapshot，每个事务或者每条 SQL 执行时都去获取一次，从而实现不同隔离级别下的一致性。比如 Google 的 Spanner 就是用 TrueTime 来控制访问全局 Snapshot。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>XA 协议通常实现在数据库资源层，直接作用于资源管理器上。因此，基于 XA 协议实现的分布式事务产品，无论是分布式数据库，还是分布式事务框架，对业务几乎都没有侵入，就像使用普通数据库一样。</p>
<p>XA 协议严格保障事务 ACID 特性，能够满足所有业务领域的功能需求，但是，这同样是一把双刃剑。</p>
<p>由于隔离性的互斥要求，在事务执行过程中，所有的资源都被锁定，只适用于执行时间确定的短事务。同时，整个事务期间都是独占数据，对于热点数据的并发性能可能会很低，实现了分布式 MVCC 或乐观锁（optimistic locking）以后，性能可能会有所提升。    </p>
<p>同时，为了保障一致性，要求所有 RM 同等可信、可靠，要求故障恢复机制可靠、快速，在网络故障隔离的情况下，服务基本不可用。</p>
<h4 id="TCC-模型"><a href="#TCC-模型" class="headerlink" title="TCC 模型"></a>TCC 模型</h4><p>TCC（Try-Confirm-Cancel）分布式事务模型相对于 XA 等传统模型，其特征在于它不依赖资源管理器（RM）对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。</p>
<p>TCC 模型认为对于业务系统中一个特定的业务逻辑，其对外提供服务时，必须接受一些不确定性，即对业务逻辑初步操作的调用仅是一个临时性操作，调用它的主业务服务保留了后续的取消权。如果主业务服务认为全局事务应该回滚，它会要求取消之前的临时性操作，这就对应从业务服务的取消操作。而当主业务服务认为全局事务应该提交时，它会放弃之前临时性操作的取消权，这对应从业务服务的确认操作。每一个初步操作，最终都会被确认或取消。</p>
<p>因此，针对一个具体的业务服务，TCC 分布式事务模型需要业务系统提供三段业务逻辑：</p>
<ol>
<li>初步操作 Try：完成所有业务检查，预留必须的业务资源。</li>
<li>确认操作 Confirm：真正执行的业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务有且只能成功一次。</li>
<li>取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG270.png" alt="image"><br>TCC 分布式事务模型包括三部分：</p>
<ul>
<li>主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。</li>
<li>从业务服务：从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作（Try）、确认操作（Confirm）、取消操作（Cancel）三个接口，供主业务服务调用。</li>
<li>业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。</li>
</ul>
<p>一个完整的 TCC 分布式事务流程如下：</p>
<ol>
<li><p>主业务服务首先开启本地事务；</p>
</li>
<li><p>主业务服务向业务活动管理器申请启动分布式事务主业务活动；</p>
</li>
<li><p>然后针对要调用的从业务服务，主业务活动先向业务活动管理器注册从业务活动，然后调用从业务服务的 Try 接口；</p>
</li>
<li><p>当所有从业务服务的 Try 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务；</p>
</li>
<li><p>若主业务服务提交本地事务，则 TCC 模型分别调用所有从业务服务的 Confirm 接口；若主业务服务回滚本地事务，则分别调用 Cancel 接口；</p>
</li>
<li><p>所有从业务服务的 Confirm 或 Cancel 操作完成后，全局事务结束。</p>
</li>
</ol>
<h5 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h5><p>TCC 模型也使用 2PC 原子提交协议来保证事务原子性。Try 操作对应2PC 的一阶段准备（Prepare）；Confirm 对应 2PC 的二阶段提交（Commit），Cancel 对应 2PC 的二阶段回滚（Rollback），可以说 TCC 就是应用层的 2PC。</p>
<h5 id="隔离性-1"><a href="#隔离性-1" class="headerlink" title="隔离性"></a>隔离性</h5><p>TCC 分布式事务模型仅提供两阶段原子提交协议，保证分布式事务原子性。事务的隔离交给业务逻辑来实现。</p>
<p>隔离的本质是控制并发，防止并发事务操作相同资源而引起的结果错乱。</p>
<p>举个例子，比如金融行业里管理用户资金，当用户发起交易时，一般会先检查用户资金，如果资金充足，则扣除相应交易金额，增加卖家资金，完成交易。如果没有事务隔离，用户同时发起两笔交易，两笔交易的检查都认为资金充足，实际上却只够支付一笔交易，结果两笔交易都支付成功，导致资损。</p>
<p>可以发现，并发控制是业务逻辑执行正确的保证，但是像两阶段锁这样的并发访问控制技术要求一直持有数据库资源锁直到整个事务执行结束，特别是在分布式事务架构下，要求持有锁到分布式事务第二阶段执行结束，也就是说，分布式事务会加长资源锁的持有时间，导致并发性能进一步下降。</p>
<p>因此，TCC 模型的隔离性思想就是通过业务的改造，在第一阶段结束之后，从底层数据库资源层面的加锁过渡为上层业务层面的加锁，从而释放底层数据库锁资源，放宽分布式事务锁协议，提高业务并发性能。</p>
<p>还是以上面的例子举例：</p>
<ol>
<li><p>第一阶段：检查用户资金，如果资金充足，冻结用户本次交易资金，这笔资金被业务隔离，不允许除本事务之外的其它并发事务动用。</p>
</li>
<li><p>第二阶段：扣除第一阶段预冻结的用户资金，增加卖家资金，完成交易。</p>
</li>
</ol>
<p>采用业务加锁的方式，隔离用户冻结资金，在第一阶段结束后直接释放底层资源锁，该用户和卖家的其他交易都可以立刻并发执行，而不用等到整个分布式事务结束，可以获得更高的并发交易能力。</p>
<h5 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h5><p>再来看看 TCC 分布式事务模型下的一致性实现。与 XA 协议实现一致性第一层语义类似，通过原子性保证事务的原子提交、业务隔离性控制事务的并发访问，实现分布式事务的一致性状态转变。</p>
<p>至于第二层语义：事务的中间状态不能被观察到。我们来看看，在 SOA分布式应用环境下是否是必须的。</p>
<p>还是以账务服务举例。转账业务（用户 A  -&gt; 用户 B），由交易服务和账务服务组成分布式事务，交易服务作为主业务服务，账务服务作为从业务服务，账务服务的 Try 操作预冻结用户 A 的资金；Commit 操作扣除用户 A 的预冻结资金，增加用户 B 的可用资金；Cancel 操作解冻用户 A 的预冻结资金。</p>
<p>当账务服务执行完 Try 阶段后，交易主业务就可以 Commit 了，然后由TCC 框架调用账务的 Commit 阶段。在账务 Commit 阶段还没执行结束的时候，用户 A 可以查询到自己的余额已扣除，但是，此时用户 B 的可用资金还没增加。</p>
<p>从系统的角度来看，确实有问题与不确定性。在第一阶段执行结束到第二阶段执行结束之间，有一段时间的延时，在这段时间内，看似任何用户都不享有这笔资产。</p>
<p>但是，从用户的角度来考虑这个问题的话，这个时间间隔可能就无所谓或者根本就不存在。特别是当这个时间间隔仅仅是几秒钟，对于具体沟通资产转移的用户来讲，这个过程是隐蔽的或确实可以接受的，且保证了结果的最终一致性。</p>
<p>当然，对于这样的系统，如果确实需要查看系统的某个一致性状态，可以采用额外的方法实现。</p>
<p>一般来讲，服务之间的一致性比服务内部的一致性要更加容易弱化，这也是为什么 XA 等直接在资源层面上实现通用分布式事务的模型会注重一致性的保证，而当上升到服务层面，服务与服务之间已经实现了功能的划分，逻辑的解耦，也就更容易弱化一致性，这就是 SOA 架构下 BASE 理论的最终一致性思想。</p>
<p>BASE 理论是指 BA（Basic Availability，基本业务可用性）；S（Soft state，柔性状态）；E（Eventual consistency，最终一致性）。该理论认为为了可用性、性能与降级服务的需要，可以适当降低一点一致性的要求，即“基本可用，最终一致”。</p>
<p>业内通常把严格遵循 ACID 的事务称为刚性事务；而基于 BASE 思想实现的事务称为柔性事务。柔性事务并不是完全放弃了 ACID，仅仅是放宽了一致性要求：事务完成后的一致性严格遵循，事务中的一致性可适当放宽。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>TCC 分布式事务模型的业务实现特性决定了其可以跨 DB、跨服务实现资源管理，将对不同的 DB 访问、不同的业务操作通过 TCC 模型协调为一个原子操作，解决了分布式应用架构场景下的事务问题。</p>
<p>TCC 模型通过 2PC 原子提交协议保证分布式事务的的原子性，把资源层的隔离性上升到业务层，交给业务逻辑来实现。TCC 的每个操作对于资源层来说，就是单个本地事务的使用，操作结束则本地事务结束，规避了资源层在 2PC 和 2PL 下对资源占用导致的性能低下问题。</p>
<p>同时，TCC 模型也可以根据业务需要，做一些定制化的功能，比如交易异步化实现削峰填谷等。</p>
<p>但是，业务接入 TCC 模型需要拆分业务逻辑成两个阶段，并实现 Try、Confirm、Cancel 三个接口，定制化程度高，开发成本高。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文首先介绍了典型的分布式事务的架构场景。分布式事务刚开始是为解决单服务多数据库资源的场景而诞生的。随着技术的发展，特别是 SOA 分布式应用架构以及微服务时代的到来，服务变成了基本业务单元。因此，又产生了跨服务的分布式事务需求。</p>
<p>然后从 XA 和 TCC 两种常用的分布式事务模型入手，介绍了其实现机制，着重分析了各模型是如何实现分布式事务 ACID 特性的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/dinghuang.png"
                alt="强壮的病猫" />
            
              <p class="site-author-name" itemprop="name">强壮的病猫</p>
              <p class="site-description motion-element" itemprop="description">学习、生活、闲谈、足球</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dinghuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">强壮的病猫</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://dinghuang-1.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
